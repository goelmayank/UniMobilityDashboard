(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('underscore'), require('ht-utility'), require('date-fns'), require('rxjs/observable/combineLatest'), require('rxjs/operators'), require('rxjs/observable/of'), require('rxjs/observable/empty')) :
	typeof define === 'function' && define.amd ? define(['exports', 'underscore', 'ht-utility', 'date-fns', 'rxjs/observable/combineLatest', 'rxjs/operators', 'rxjs/observable/of', 'rxjs/observable/empty'], factory) :
	(factory((global.htData = {}),global['-'],global.htUtility,global.dateFns,global.Rx.Observable,global.Rx.operators,global.Rx.Observable,global.Rx.Observable));
}(this, (function (exports,_,htUtility,dateFns,combineLatest,operators,of,empty) { 'use strict';

_ = _ && _.hasOwnProperty('default') ? _['default'] : _;

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var HtAction = (function () {
    function HtAction(data) {
        this.data = data;
        this.types = ["delivery", "pickup", "task", "visit", "stopover", "trip"];
        this.sortingQueryMap = {
            assigned_at: "Assigned",
            completed_at: "Completed",
            type: "Type",
            user__name: "User name",
            status: "Status"
        };
        this.ontimeFilters = [
            { event_flags: "action.delayed" },
            { event_flags: "action.completed_late" }
        ];
        this.statusQueryMap = {
            created: "Not yet started",
            "assigned,started": "Assigned",
            "started,assigned": "Assigned",
            completed: "Completed"
        };
        this.ontimeQueryMap = {
            "action.delayed": "Running delayed",
            "action.completed_late": "Completed late"
        };
        this.markerFilterMap = {
            "assigned,started": function (action) {
                return action.status == "assigned" || action.status == "started";
            },
            "started,assigned": function (action) {
                return action.status == "assigned" || action.status == "started";
            },
            completed: function (action) {
                return action.status == "completed";
            },
            created: function (action) {
                return action.status == "created";
            }
        };
    }
    Object.defineProperty(HtAction.prototype, "filterQueryMap", {
        get: function () {
            return __assign({}, this.statusQueryMap, this.ontimeQueryMap);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HtAction.prototype, "sortings", {
        get: function () {
            return Object.keys(this.sortingQueryMap);
        },
        enumerable: true,
        configurable: true
    });
    HtAction.prototype.getStatusString = function (status) {
        return this.statusQueryMap[status] || status;
    };
    HtAction.prototype.getOntimeString = function (value) {
        return this.ontimeQueryMap[value] || value;
    };
    HtAction.prototype.getFilterString = function (value) {
        return this.filterQueryMap[value] || value;
    };
    HtAction.prototype.getSortingString = function (value) {
        return this.sortingQueryMap[value] || value;
    };
    HtAction.prototype.getMarkerFilter = function (key) {
        var filter$$1 = this.markerFilterMap[key];
        if (key) {
            if (filter$$1) {
                return filter$$1;
            }
            else {
                return function () { return false; };
            }
        }
        else {
            return function () { return true; };
        }
    };
    HtAction.prototype.getMarkerSeached = function (key) {
        return function (action) {
            return ((action.lookup_id && action.lookup_id.indexOf(key) > -1) ||
                (action.user && action.user.name.indexOf(key) > -1));
        };
    };
    HtAction.prototype.isAwayFromExpected = function () {
        var action = this.data;
        if (action.expected_place && action.event_flags) {
            var flag = _.find(action.event_flags, function (flag) {
                return (flag["type"] == "action.completed_at_different_place_than_expected");
            });
            return !!flag;
        }
        return false;
    };
    HtAction.prototype.isValidMarker = function (action) {
        action = action || this.data;
        return !!((action.expected_place && action.expected_place.location) ||
            (action.completed_place && action.completed_place.location));
    };
    HtAction.prototype.getDateRangeQuery = function (query) {
        return htUtility.GetDateRangeQuery(query, "created_at");
    };
    HtAction.prototype.getPositionsObject = function () {
        var completedPosition = this.getCompletedPosition();
        var expectedPosition = this.getExpectedPosition();
        var isAwayFromExpected = this.isAwayFromExpected();
        return {
            completedPosition: completedPosition,
            expectedPosition: expectedPosition,
            isAwayFromExpected: isAwayFromExpected,
            hasEnded: this.hasEnded(),
            position: completedPosition || expectedPosition
        };
    };
    HtAction.prototype.getCompletedPosition = function () {
        var action = this.data;
        if (action && action.completed_place && action.completed_place.location) {
            var compLoc = action.completed_place.location.coordinates;
            var lat = compLoc[1];
            var lng = compLoc[0];
            return { lat: lat, lng: lng };
            // return [compLoc[1], compLoc[0]]
        }
        return null;
    };
    HtAction.prototype.getExpectedPosition = function () {
        var action = this.data;
        if (action && action.expected_place && action.expected_place.location) {
            var expLoc = action.expected_place.location.coordinates;
            var lat = expLoc[1];
            var lng = expLoc[0];
            return { lat: lat, lng: lng };
            // return [expLoc[1], expLoc[0]]
        }
        return null;
    };
    HtAction.prototype.getPosition = function () {
        return this.getPositionsObject().position;
    };
    HtAction.prototype.hasEnded = function () {
        return !!this.data.display.ended_at;
    };
    HtAction.prototype.getETATimestamp = function () {
        var action = this.data;
        if (action.display.duration_remaining) {
            return dateFns.addSeconds(new Date(), action.display.duration_remaining).toISOString();
        }
        return null;
    };
    HtAction.prototype.getHeatmapLatlng = function (item) {
        return {
            lat: item.completed_place__location[1],
            lng: item.completed_place__location[0],
        };
    };
    HtAction.prototype.getHeatLatlngs = function (items) {
        return _.reduce(items, function (acc, place) {
            var placeLatlng = [place.completed_place__location[1], place.completed_place__location[0]];
            var placeArray = Array(place.num_actions).fill(placeLatlng);
            return acc.concat(placeArray);
        }, []);
    };
    return HtAction;
}());
var htAction = function (action) { return new HtAction(action); };

var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var HtUser = (function () {
    function HtUser(data) {
        this.data = data;
        this.statusQueryMap = {
            stopped: "Stopped",
            on_trip: "Moving",
            logged_off: "Logged off",
            "location_disabled,network_offline": "Error",
            location_disabled: "Location disabled",
            network_offline: "Network offline",
            never_tracked: "Never tracked"
        };
        this.sortingQueryMap = {
            num_trips: "Trips",
            name: "Name",
            status: "Status",
            num_places: "Places",
            total_distance: "Distance",
            total_duration: "Duration",
            stop_duration: "Stop duration",
            location_disabled_duration: "Location disabled",
            network_offline_duration: "Network offline",
            num_actions: "Actions",
            last_heartbeat_at: "Last updated"
        };
        this.markerFilterMap = {
            stopped: function (user) {
                return user.status == "stopped";
            },
            on_trip: function (user) {
                return (user.status == "walk" ||
                    user.status == "run" ||
                    user.status == "cycle" ||
                    user.status == "drive" ||
                    user.status == "moving");
                //moving: walk, drive, cycle, run
            },
            logged_off: function (user) {
                return user.status == "logged_off";
            },
            location_disabled: function (user) {
                return user.status == "location_disabled";
            },
            network_offline: function (user) {
                return user.status == "network_offline";
            }
        };
    }
    HtUser.prototype.getMarkerSearched = function (key) {
        return function (user) {
            if (!user.name)
                return false;
            var name = user.name.toLowerCase();
            key = key.toLowerCase();
            return name.includes(key);
        };
    };
    HtUser.prototype.getMarkerFilter = function (key) {
        var filter$$1 = this.markerFilterMap[key];
        if (key) {
            if (filter$$1) {
                return filter$$1;
            }
            else {
                return function () { return false; };
            }
        }
        else {
            return function () { return true; };
        }
    };
    Object.defineProperty(HtUser.prototype, "sortings", {
        get: function () {
            return Object.keys(this.sortingQueryMap);
        },
        enumerable: true,
        configurable: true
    });
    HtUser.prototype.getSegmentTypes = function (userSegments) {
        return _.reduce(userSegments, function (segmentType, segment) {
            if (segment.type == "stop") {
                if (segment.location && segment.location.geojson)
                    segmentType.stopSegment.push(segment);
            }
            else {
                if (segment.encoded_polyline)
                    segmentType.tripSegment.push(segment);
            }
            return segmentType;
        }, { tripSegment: [], stopSegment: [] });
    };
    HtUser.prototype.getPosition = function () {
        var data = this.data;
        if (data.last_location && data.last_location.geojson) {
            var lat = data.last_location.geojson.coordinates[1];
            var lng = data.last_location.geojson.coordinates[0];
            return { lat: lat, lng: lng };
            // return L.latLng([item.last_location.geojson.coordinates[1], item.last_location.geojson.coordinates[0]])
        }
        else {
            return null;
        }
    };
    HtUser.prototype.isValidMarker = function (user) {
        user = user || this.data;
        return !!(user.last_location && user.last_location.geojson);
    };
    return HtUser;
}());
var htUser = function (user) {
    var extras = {
        statusQueryMap: {
            stopped: "Stopped",
            on_trip: "Moving",
            logged_off: "Logged off",
            "location_disabled,network_offline": "Error",
            location_disabled: "Location disabled",
            network_offline: "Network offline",
            never_tracked: "Never tracked"
        },
        sortingQueryMap: {
            num_trips: "Trips",
            name: "Name",
            status: "Status",
            num_places: "Places",
            total_distance: "Distance",
            total_duration: "Duration",
            stop_duration: "Stop duration",
            location_disabled_duration: "Location disabled",
            network_offline_duration: "Network offline",
            num_actions: "Actions",
            last_heartbeat_at: "Last updated"
        },
        markerFilterMap: {
            stopped: function (user) {
                return user.status == "stopped";
            },
            on_trip: function (user) {
                return (user.status == "walk" ||
                    user.status == "run" ||
                    user.status == "cycle" ||
                    user.status == "drive" ||
                    user.status == "moving");
                //moving: walk, drive, cycle, run
            },
            logged_off: function (user) {
                return user.status == "logged_off";
            },
            location_disabled: function (user) {
                return user.status == "location_disabled";
            },
            network_offline: function (user) {
                return user.status == "network_offline";
            }
        },
        getMarkerSearched: function (key) {
            return function (user) {
                if (!user.name)
                    return false;
                var name = user.name.toLowerCase();
                key = key.toLowerCase();
                return name.includes(key);
            };
        },
        getMarkerFilter: function (key) {
            var filter$$1 = this.markerFilterMap[key];
            if (key) {
                if (filter$$1) {
                    return filter$$1;
                }
                else {
                    return function () { return false; };
                }
            }
            else {
                return function () { return true; };
            }
        }
    };
    return __assign$1({ data: user, isValidMarker: function () {
            var user = this.data;
            return !!(user.last_location && user.last_location.geojson);
        },
        getPosition: function () {
            if (this.isValidMarker()) {
                return this.getValidPosition();
            }
            else {
                return null;
            }
        },
        getValidPosition: function () {
            var data = this.data;
            var lat = data.last_location.geojson.coordinates[1];
            var lng = data.last_location.geojson.coordinates[0];
            return { lat: lat, lng: lng };
        },
        // update(user) {
        //   return {...this, ...user}
        // },
        getInfoContent: function () {
            var user = this;
            return user.name;
        } }, extras);
};

var HtEvent = (function () {
    function HtEvent(data) {
        this.data = data;
    }
    HtEvent.prototype.getEventDisplay = function (event) {
        event = event || this.data;
        switch (event.type) {
            case "tracking.started":
                return {
                    text: "Tracking started",
                    subText: ""
                };
            case "tracking.ended":
                return {
                    text: "Tracking ended",
                    subText: ""
                };
            // case 'device.location.disabled':
            //   return {
            //     text: 'Location disabled',
            //     subtext: ''
            //   };
            // case 'device.location.enabled':
            //   return {
            //     text: 'Location enabled',
            //     subtext: ''
            //   };
            // case 'device.location_permission.disabled':
            //   return {
            //     text: 'Location permission disabled',
            //     subtext: ''
            //   };
            // case 'device.location_permission.enabled':
            //   return {
            //     text: 'Location permission enabled',
            //     subtext: ''
            //   };
            case "device.secondary.ignored":
                return {
                    text: "Secondary device ignored",
                    subText: ""
                };
        }
    };
    return HtEvent;
}());
var htEvent = function (event) { return new HtEvent(event); };

var __assign$3 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var CommonFunctions = {
    setEntityCountMap: function (entity, entityCountMap, uniqueProp) {
        if (entity === void 0) { entity = {}; }
        if (entityCountMap === void 0) { entityCountMap = {}; }
        if (uniqueProp === void 0) { uniqueProp = "id"; }
        var newEntityMap = __assign$3({}, entityCountMap);
        var type = entity[uniqueProp] + "-count";
        var id = entity["id"];
        var typeCount = entityCountMap[type];
        var actionShort = entityCountMap[id];
        if (typeCount) {
            if (!actionShort) {
                newEntityMap[type] = entityCountMap[type] + 1;
                newEntityMap[id] = "" + entityCountMap[type];
            }
        }
        else {
            newEntityMap[type] = 1;
            newEntityMap[id] = "";
        }
        // console.log(actionMap, "map");
        return newEntityMap;
    }
};

var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var HtPlaceline = (function () {
    function HtPlaceline(userData) {
        this.userData = userData;
    }
    HtPlaceline.prototype.getPlacelineSegments = function () {
        var _this = this;
        var userData = this.userData;
        var _a = this.createActivitiesSegments(userData), lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;
        var actionsMarks = this.createActionsMarks(userData.actions);
        var eventsMarks = _.map(userData.events, function (event) {
            return _this.createEventMark(event);
        });
    };
    HtPlaceline.prototype.createActivitiesSegments = function (userData) {
        var _this = this;
        var segments = userData.segments;
        var _a = _.reduce(segments.concat([{}]), function (_a, segment) {
            var lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;
            var nextLastSegment = segment;
            if (lastSegment) {
                if (segment.id) {
                    var activitySegment = _this.createActivitySegment(lastSegment);
                    if (activitySegment)
                        activitySegments.push(activitySegment);
                }
                else {
                    //last segment
                    nextLastSegment = _this.getLastSegment(segment, userData.last_heartbeat_at);
                }
            }
            return { lastSegment: nextLastSegment, activitySegments: activitySegments };
        }, { activitySegments: [], lastSegment: null }), lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;
        return { lastSegment: lastSegment, activitySegments: activitySegments };
    };
    HtPlaceline.prototype.createActivitySegment = function (segment) {
        var placelineTime = segment.started_at;
        var activityText = this.getActivityText(segment);
        var activityAddress = this.getActivityPlaceAddress(segment);
        var end = segment.ended_at ? new Date(segment.ended_at).getTime() : null;
        return __assign$2({ placelineTime: placelineTime,
            activityText: activityText }, this.getActivityStyleClass(segment), { segmentId: segment.id, segment: segment, start: new Date(placelineTime).getTime(), end: end });
    };
    HtPlaceline.prototype.createEventSegment = function (eventMark, segment) {
        return __assign$2({}, segment, { placelineTime: eventMark.event.recorded_at }, eventMark);
    };
    HtPlaceline.prototype.createActionSegment = function (actionMark, segment) {
        return __assign$2({}, segment, { placelineTime: actionMark.actionTime }, actionMark);
    };
    HtPlaceline.prototype.createActionsMarks = function (actions) {
        var actionMarksObj = _.reduce(actions, function (acc, action) {
            // acc.actionCountMap = this.setActionCountMap(action, acc.actionCountMap);
            // let assign: IActionMark = this.getActionMark(
            //   action,
            //   acc.actionCountMap,
            //   false,
            //   false
            // );
            // if (assign.actionTime) acc.actionMarks.push(assign);
            // let end = this.getActionMark(
            //   action,
            //   acc.actionMarks,
            //   true,
            //   !!action.display.ended_at
            // );
            // acc.actionMarks.push(end);
            return acc;
        }, { actionMarks: [], actionCountMap: {} });
        return actionMarksObj.actionMarks;
    };
    HtPlaceline.prototype.createEventMark = function (event) {
        return { event: event, display: htEvent().getEventDisplay(event) };
    };
    HtPlaceline.prototype.getLastSegment = function (lastSeg, lastHearbeatAt) {
        // let last = {time: lastSeg['last_heartbeat_at']};
        var placelineTime;
        var isLive = false;
        if (lastSeg.ended_at) {
            placelineTime = lastSeg.ended_at;
        }
        else {
            isLive = true;
            placelineTime = lastHearbeatAt;
        }
        return __assign$2({ placelineTime: placelineTime,
            isLive: isLive, isLast: true, segmentId: lastSeg.id }, this.getActivityStyleClass(lastSeg));
    };
    HtPlaceline.prototype.isLive = function (placeline) {
        var old = placeline.display.seconds_elapsed_since_last_heartbeat;
        var date = placeline.timeline_date;
        var status = placeline.display.status_text;
        return status !== "Tracking stopped" && old < 15 * 60 && dateFns.isToday(new Date(date));
    };
    HtPlaceline.prototype.getSegmentTypes = function (userSegments) {
        return _.reduce(userSegments, function (segmentType, segment) {
            if (segment.type == "stop") {
                if (segment.location && segment.location.geojson)
                    segmentType.stopSegment.push(segment);
            }
            else {
                if (segment.encoded_polyline)
                    segmentType.tripSegment.push(segment);
            }
            return segmentType;
        }, { tripSegment: [], stopSegment: [] });
    };
    //helpers
    HtPlaceline.prototype.getActivityStyleClass = function (segment) {
        var activityClass = this.getActivityClass(segment);
        return this.getActivityStyle(activityClass);
    };
    HtPlaceline.prototype.getActivityStyle = function (activityClass) {
        if (activityClass === void 0) { activityClass = "no-info"; }
        return {
            activityBg: activityClass + "-bg",
            activityBorder: activityClass + "-border",
            activityClass: activityClass,
            activityColor: activityClass + "-color"
        };
    };
    HtPlaceline.prototype.getActivityClass = function (segment) {
        var type = segment.type;
        if (type == "location_void") {
            return "warning";
        }
        return type == "stop" ? "stop" : "trip";
    };
    HtPlaceline.prototype.setActionCountMap = function (action, actionCountMap) {
        return CommonFunctions.setEntityCountMap(action, actionCountMap, "type");
    };
    HtPlaceline.prototype.getActionMark = function (action, actionMap, isEnd, isDone) {
        return {
            actionText: htUtility.NameCase(action.type) + " scheduled",
            actionTime: action.eta || null,
            actionDot: htUtility.NameCase(action.type[0]) + actionMap[action.id],
            isEnd: isEnd,
            isDone: isDone,
            action: action
        };
    };
    HtPlaceline.prototype.getActivityText = function (segment) {
        if (segment.activity) {
            return segment.activity;
        }
        else if (segment.type == "stop") {
            return "Stop";
        }
        else if (segment.reason) {
            return this.getLocationVoidText(segment);
        }
        else {
            return htUtility.NameCase(segment.type);
        }
    };
    HtPlaceline.prototype.getActivityPlaceAddress = function (segment) {
        if (segment.type == "stop" && segment.place && segment.place.locality) {
            return segment.place.locality;
        }
        return "";
    };
    HtPlaceline.prototype.getLocationVoidText = function (segment) {
        switch (segment.reason) {
            case "disabled":
                return "Location disabled";
            case "no_permission":
                return "Location permission unavailable";
            case "unknown":
                return "Location unavailable";
            default:
                return "Location unavailable";
        }
    };
    HtPlaceline.prototype.getEventDisplay = function (event) {
        switch (event.type) {
            case "tracking.started":
                return {
                    text: "Tracking started",
                    subtext: ""
                };
            case "tracking.ended":
                return {
                    text: "Tracking ended",
                    subtext: ""
                };
            // case 'device.location.disabled':
            //   return {
            //     text: 'Location disabled',
            //     subtext: ''
            //   };
            // case 'device.location.enabled':
            //   return {
            //     text: 'Location enabled',
            //     subtext: ''
            //   };
            // case 'device.location_permission.disabled':
            //   return {
            //     text: 'Location permission disabled',
            //     subtext: ''
            //   };
            // case 'device.location_permission.enabled':
            //   return {
            //     text: 'Location permission enabled',
            //     subtext: ''
            //   };
            case "device.secondary.ignored":
                return {
                    text: "Secondary device ignored",
                    subtext: ""
                };
        }
    };
    HtPlaceline.prototype.getGapSegment = function (segment, lastSeg) {
        var gaps = [];
        if (!lastSeg)
            return [];
        if (segment.started_at && lastSeg.ended_at) {
            var endMin = htUtility.GetMinute(segment.started_at);
            var startMin = htUtility.GetMinute(lastSeg.ended_at);
            var duration = (new Date(segment.started_at).getTime() -
                new Date(lastSeg.ended_at).getTime()) /
                1000;
            if (endMin != startMin && startMin < endMin) {
                var gap = __assign$2({}, this.getActivityStyle("no-info"), { time: lastSeg.ended_at, activityText: "No information", events: [], duration: duration, id: "asd" });
                gaps.push(gap);
            }
        }
        return gaps;
    };
    return HtPlaceline;
}());
var htPlaceline = function (userData) { return new HtPlaceline(userData); };

var __assign$4 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
function UpdateSubAccountOfAccount(account, updatedSubAccount, tokenType) {
    var subAccounts = _.map(account.sub_accounts, function (subAccount) {
        if (subAccount.type == tokenType) {
            return __assign$4({}, subAccount, updatedSubAccount);
        }
        else {
            return subAccount;
        }
    });
    return __assign$4({}, account, { sub_accounts: subAccounts });
}
// export function UpdateAccountOfAccountUser(accountUser: IAccountUser, account: IAccount, config): IAccountUser {
//   let memberships = _.map(accountUser.memberships, (member: IMembership) => {
//     let isMember = IsCurrentMember(member, config.currentToken, config.tokenType);
//     return isMember ? {...member, account: account} : member;
//   });
//   let defaultAccount = account.id == accountUser.default_account.id ? account : accountUser.default_account;
//   return {...accountUser, memberships: memberships, default_account: defaultAccount};
// }
// export function GetAccountFromAccountUser (accountUser: IAccountUser, currentToken: string, tokenType: 'test' | 'production') {
//   if(!accountUser) return null;
//   if(isCurrentAccount(accountUser.default_account, currentToken, tokenType)) {
//     return accountUser.default_account;
//   }
//   let membership = _.find(accountUser.memberships, (member: IMembership) => {
//     return isCurrentAccount(member.account, currentToken, tokenType);
//   });
//   return membership ? membership.account : null
// }
function isCurrentAccount(account, token, tokenType) {
    return GetSecretToken(account, tokenType) == token;
}
function IsCurrentMember(member, token, tokenType) {
    return GetSecretToken(member.account, tokenType) == token;
}
function GetSecretToken(account, tokenType) {
    return getToken(getSubAccountToken(account, tokenType), "secret");
}
var getToken = function (subAccounts, type) {
    var tokenObject = _.find(subAccounts, function (token) {
        return token.scope == type;
    });
    return tokenObject ? tokenObject.key : null;
};
function getAccountFromAccountUserId(accountUser, accountId) {
    if (!accountUser)
        return null;
    if (accountUser.default_account.id == accountId) {
        return accountUser.default_account;
    }
    else {
        var membership = _.find(accountUser.memberships, function (member) {
            return (member.account.id = accountId);
        });
        return membership ? membership.account : null;
    }
}
function getSubAccountToken(account, type) {
    return _.find(account.sub_accounts, function (subAccount) {
        return subAccount.type == type;
    }).tokens;
}
var getAuthHeaders = function (token) {
    return { Authorization: "token " + token };
};

var itemAsPage$ = function () {
    return function (item$) {
        return item$.pipe(operators.map(function (item) {
            return item
                ? {
                    count: 1,
                    next: null,
                    previous: null,
                    results: [item]
                }
                : null;
        }));
    };
};

var __assign$5 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var dataWithSelectedId$ = function (data$, id$, keys, prop) {
    return combineLatest.combineLatest(data$, id$, function (data, id) {
        if (!data && keys.length)
            return data;
        var allItems = keys.reduce(function (items, key) {
            return items.concat(data[key]);
        }, []);
        var selected = allItems.find(function (item) {
            return item.id === id;
        });
        return __assign$5({}, data, (_a = {}, _a[prop] = selected, _a));
        var _a;
    });
};
var listwithSelectedId$ = function (list$, id$) {
    return combineLatest.combineLatest(list$, id$.pipe(operators.distinctUntilChanged()), function (list, id) {
        if (!list)
            return list;
        return !id
            ? list
            : {
                count: 1,
                next: null,
                page: null,
                results: list.results.filter(function (item) {
                    return item.id === id;
                })
            };
    });
};
var listWithItem$ = function (list$, item$) {
    return combineLatest.combineLatest(list$, item$.pipe(itemAsPage$()), function (list, itemPage) {
        return itemPage ? itemPage : list;
    });
};

var andCombine = function () {
    var source$ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source$[_i] = arguments[_i];
    }
    return combineLatest.combineLatest.apply(void 0, source$.filter(function (data) { return !!data; }).concat([function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.reduce(function (acc, arg) {
                return acc && !!arg;
            }, true);
        }])).pipe(operators.distinctUntilChanged());
};

var orCombine = function () {
    var source$ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source$[_i] = arguments[_i];
    }
    return combineLatest.combineLatest.apply(void 0, source$.concat([function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.reduce(function (acc, arg) {
                return acc || !!arg;
            }, false);
        }]));
};

var __assign$6 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var MergeQuery = function (defaultQuery) {
    return function (query$) {
        return query$.pipe(operators.map(function (query) {
            console.log(query);
            return query ? __assign$6({}, defaultQuery, query) : query;
        }));
    };
};

var __assign$7 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var CombineQueries = function (addQueries$) {
    return function (query$) {
        if (addQueries$ && addQueries$.length) {
            return combineLatest.combineLatest.apply(void 0, [query$].concat(addQueries$.filter(function (data) { return !!data; }), [function (query) {
                    var addQueries = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        addQueries[_i - 1] = arguments[_i];
                    }
                    if (!query)
                        return query;
                    return addQueries.reduce(function (acc, currentQ) {
                        return __assign$7({}, currentQ, acc);
                    }, query);
                }]));
        }
        else {
            return query$;
        }
    };
};

var DateRangeToQuery$ = function (dateRangeParam) {
    return function (dateRangeQuery$) {
        return dateRangeQuery$.pipe(operators.map(function (dateRange) {
            if (!dateRange || (typeof dateRange == 'object' && Object.keys(dateRange).length == 0))
                return {};
            var start = dateRange["start"];
            var end = dateRange["end"];
            var param = dateRangeParam;
            return _a = {}, _a["min_" + param] = start, _a["max_" + param] = end, _a;
            var _a;
        }));
    };
};

var PageResults$ = function (pageData$, defaultValue) {
    return pageData$.pipe(operators.map(function (pageDate) {
        return pageDate ? pageDate.results : defaultValue || pageDate;
    }));
};

var __assign$8 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var AllowedQueryKeys$ = function (allowedQueryKeys) {
    return function (queryStore$) {
        if (allowedQueryKeys && allowedQueryKeys.length) {
            var keys$ = allowedQueryKeys.map(function (key) {
                return queryStore$.pipe(operators.map(function (store) { return (store ? store[key] : null); }), operators.distinctUntilChanged(), operators.map(function (value) {
                    return value ? (_a = {}, _a[key] = value, _a) : null;
                    var _a;
                }));
            });
            return combineLatest.combineLatest.apply(void 0, keys$).pipe(operators.map(function (obsArray) {
                console.log(obsArray, "arr");
                return obsArray.reduce(function (acc, query) {
                    return query ? __assign$8({}, acc, query) : acc;
                }, {});
            }));
        }
        else if (allowedQueryKeys) {
            return of.of({});
        }
        else {
            return queryStore$;
        }
    };
};
var AllowedQueryMap = function (allowedQueryMaps) {
    return function (queryStore$) {
        if (allowedQueryMaps && allowedQueryMaps.length) {
            var keys$ = allowedQueryMaps.map(function (queryMap) {
                return queryStore$.pipe(operators.map(function (store) { return (store ? store[queryMap.key] : null); }), operators.scan(function (acc, value) {
                    return { value: value, oldValue: acc.value };
                }, { value: "_no_val", oldValue: "_" }), operators.filter(function (obj) {
                    if (obj.oldValue == "_no_val") {
                        return true;
                    }
                    else if (!obj.oldValue || !obj.value) {
                        return false;
                    }
                    else if (obj.oldValue == obj.value) {
                        return false; //distinct unntil changed
                    }
                    else if (queryMap.filter) {
                        return queryMap.filter(obj.value, obj.oldValue);
                    }
                    else {
                        return true;
                    }
                }), operators.map(function (obj) {
                    return obj.value ? (_a = {}, _a[queryMap.key] = obj.value, _a) : null;
                    var _a;
                }));
            });
            return combineLatest.combineLatest.apply(void 0, keys$).pipe(operators.map(function (obsArray) {
                // console.log(obsArray, "arr");
                return obsArray.reduce(function (acc, query) {
                    return query ? __assign$8({}, acc, query) : acc;
                }, {});
            }));
            // return queryStore$
        }
        else if (allowedQueryMaps) {
            return of.of({});
        }
        else {
            return queryStore$;
        }
    };
};

var CombineLoadings$ = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var loadings$ = args.map(function (loading$) {
        return loading$
            .pipe(operators.map(function (data) { return !!data; }), operators.distinctUntilChanged());
    });
    return combineLatest.combineLatest.apply(void 0, loadings$.concat([function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.reduce(function (acc, arg) {
                return acc || arg;
            }, false);
        }])).pipe(operators.distinctUntilChanged(), operators.share());
};

var __assign$9 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
function allPages(api$, req$, options) {
    if (options === void 0) { options = {}; }
    return api$.pipe(operators.expand(function (data) {
        return data["next"]
            ? req$(data["next"], options).pipe(operators.map(function (newData) {
                return __assign$9({}, newData, { results: data.results.concat(newData.results) });
            }))
            : empty.empty();
    }));
}

var DateMapService = (function () {
    var instance;
    return {
        getInstance: function () {
            if (!instance) {
                instance = {
                    today_end: dateFns.endOfToday().toISOString(),
                    today_start: dateFns.startOfToday().toISOString(),
                    yesterday_start: dateFns.startOfYesterday().toISOString(),
                    yesterday_end: dateFns.endOfYesterday().toISOString(),
                    day_7_start: dateFns.startOfDay(dateFns.addDays(new Date(), -6)).toISOString(),
                    month_start: dateFns.startOfMonth(new Date()).toISOString(),
                    day_30_start: dateFns.startOfDay(dateFns.addDays(new Date(), -29)).toISOString(),
                };
            }
            return instance;
        }
    };
})();
var DateRangeMap = {
    "today": {
        start: DateMapService.getInstance().today_start,
        end: DateMapService.getInstance().today_end
    },
    "yesterday": {
        start: DateMapService.getInstance().yesterday_start,
        end: DateMapService.getInstance().yesterday_end,
    },
    "last_7_days": {
        start: DateMapService.getInstance().day_7_start,
        end: DateMapService.getInstance().today_end
    },
    "this_month": {
        start: DateMapService.getInstance().month_start,
        end: DateMapService.getInstance().today_end
    },
    "last_30_days": {
        start: DateMapService.getInstance().day_30_start,
        end: DateMapService.getInstance().today_end
    }
};
var DateRangeLabelMap = [
    {
        label: "Today",
        range: DateRangeMap.today,
        isSingleDay: true,
        hasToday: true
    },
    {
        label: "Yesterday",
        range: DateRangeMap.yesterday,
        isSingleDay: true,
        hasToday: false
    },
    {
        label: "Last 7 days",
        range: DateRangeMap.last_7_days,
        isSingleDay: false,
        hasToday: true
    },
    {
        label: "This month",
        range: DateRangeMap.this_month,
        isSingleDay: false,
        hasToday: true
    },
    {
        label: "Last 30 days",
        range: DateRangeMap.last_30_days,
        isSingleDay: false,
        hasToday: true
    }
];
var dateRangeDisplay = function (range) {
    var rangeItem = DateRangeLabelMap.find(function (item) {
        return isSameDateRange(item.range, range);
    });
    if (rangeItem)
        return rangeItem.label;
    // const matchKey = Object.keys(DateRangeMap).find((key) => {
    //   return isSameDateRange(DateRangeMap[key], range)
    // });
    // return "";
    var customDate = DateRangeLabelMap.find(function (data) {
        var customRange = data.range;
        return htUtility.isSameRange(range, customRange);
    });
    if (customDate)
        return customDate.label;
    var isSingleDay = htUtility.IsRangeADay(range);
    if (isSingleDay) {
        var isToday$$1 = htUtility.IsRangeToday(range);
        var suffix = isToday$$1 ? "Today " : "";
        var string = suffix + htUtility.DateString(range.start);
        return string;
    }
    else {
        // console.log(DateString(range.start), range.start);
        return htUtility.DateString(range.start) + " - " + htUtility.DateString(range.end);
    }
};
var isSameDateRange = function (range1, range2) {
    function nearTime(t1, t2) {
        return dateFns.isSameDay(t1, t2);
    }
    return (nearTime(range1.start, range2.start) && nearTime(range1.end, range2.end));
};

var tableFormat = function (data, config) {
    var format = config.format;
    return Object.keys(data).reduce(function (acc, key) {
        var value = data[key];
        if (typeof value === 'number' || typeof value === 'string' && !!!config.excludes.includes(key)) {
            var formatKey = format[key];
            if (formatKey) {
                var label = formatKey.label || key;
                var formattedValue = formatKey.selector(data) || value;
                acc.push([label, formattedValue]);
            }
            else {
                var label = key;
                var formattedValue = value;
                acc.push([label, formattedValue]);
            }
            return acc;
        }
        else {
            return acc;
        }
    }, []);
};
var actionTableFormat = {
    "assigned_at": {
        label: "Assigned at",
        selector: function (action) {
            return dateTimeString(action.assigned_at);
        }
    },
    "expected_at": {
        label: "Expected at",
        selector: function (action) {
            return action.expected_at ? dateTimeString(action.expected_at) : "--";
        }
    },
    "completed_at": {
        label: "Completed at",
        selector: function (action) {
            return dateTimeString(action.completed_at);
        }
    },
    "distance": {
        label: "Distance",
        selector: function (action) {
            return action.distance || action.distance == 0 ? htUtility.DistanceLocale(action.distance) : "--";
        }
    },
    "duration": {
        label: "Duration",
        selector: function (action) {
            return action.duration || action.duration == 0 ? htUtility.HMString(action.duration, 60) : "--";
        }
    },
    "scheduled_at": {
        label: "Scheduled at",
        selector: function (action) {
            return dateTimeString(action['scheduled_at']);
        }
    },
    "distance&duration": {
        label: "Distance/Duration",
        selector: function (action) {
            return actionTableFormat.distance.selector(action) + "/" + actionTableFormat.duration.selector(action);
        }
    },
    "type": {
        label: "Type",
        selector: function (action) {
            return htUtility.NameCase(htUtility.DotString(action.type));
        }
    }
};
var userTableFormat = {
    "stop_duration": {
        label: "Stop Duration",
        selector: function (user) {
            return htUtility.HMString(user.stop_duration, 60);
        }
    },
    "last_heartbeat_at": {
        label: "Last updated at",
        selector: function (user) {
            return dateTimeString(user.last_heartbeat_at);
        }
    },
    "last_battery": {
        label: "Last battery",
        selector: function (user) {
            return user.display.battery + " %";
        }
    },
    "total_duration": {
        label: "Duration tracked",
        selector: function (user) {
            return htUtility.HMString(user.total_duration, 60);
        }
    },
    "num_places": {
        label: "Number of stops",
        selector: function (user) {
            return user.num_places;
        }
    },
    "location_disabled_duration": {
        label: "Location disabled duration",
        selector: function (user) {
            return htUtility.HMString(user.location_disabled_duration, 60);
        }
    },
    "total_distance": {
        label: "Total distance",
        selector: function (user) {
            return htUtility.DistanceLocale(user.total_distance);
        }
    },
    "num_trips": {
        label: "Number of trips",
        selector: function (user) {
            return user.num_trips;
        }
    },
    "network_offline_duration": {
        label: "Network offline duration",
        selector: function (user) {
            return htUtility.HMString(user.network_offline_duration, 60);
        }
    },
    "num_actions": {
        label: "Number of actions",
        selector: function (user) {
            return user.num_actions;
        }
    }
};
function dateTimeString(time) {
    return time ? htUtility.TimeString(time) + ", " + htUtility.DateString(time, 'short') : "--";
}

exports.HtAction = HtAction;
exports.htAction = htAction;
exports.HtUser = HtUser;
exports.htUser = htUser;
exports.HtEvent = HtEvent;
exports.htEvent = htEvent;
exports.HtPlaceline = HtPlaceline;
exports.htPlaceline = htPlaceline;
exports.UpdateSubAccountOfAccount = UpdateSubAccountOfAccount;
exports.isCurrentAccount = isCurrentAccount;
exports.IsCurrentMember = IsCurrentMember;
exports.GetSecretToken = GetSecretToken;
exports.getToken = getToken;
exports.getAccountFromAccountUserId = getAccountFromAccountUserId;
exports.getAuthHeaders = getAuthHeaders;
exports.dataWithSelectedId$ = dataWithSelectedId$;
exports.listwithSelectedId$ = listwithSelectedId$;
exports.listWithItem$ = listWithItem$;
exports.andCombine = andCombine;
exports.orCombine = orCombine;
exports.MergeQuery = MergeQuery;
exports.CombineQueries = CombineQueries;
exports.itemAsPage$ = itemAsPage$;
exports.DateRangeToQuery$ = DateRangeToQuery$;
exports.PageResults$ = PageResults$;
exports.AllowedQueryKeys$ = AllowedQueryKeys$;
exports.AllowedQueryMap = AllowedQueryMap;
exports.CombineLoadings$ = CombineLoadings$;
exports.allPages = allPages;
exports.DateMapService = DateMapService;
exports.DateRangeMap = DateRangeMap;
exports.DateRangeLabelMap = DateRangeLabelMap;
exports.dateRangeDisplay = dateRangeDisplay;
exports.isSameDateRange = isSameDateRange;
exports.tableFormat = tableFormat;
exports.actionTableFormat = actionTableFormat;
exports.userTableFormat = userTableFormat;

Object.defineProperty(exports, '__esModule', { value: true });

})));
