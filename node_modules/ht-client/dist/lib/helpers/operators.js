"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var combineLatest_1 = require("rxjs/observable/combineLatest");
var operators_1 = require("rxjs/operators");
var of_1 = require("rxjs/observable/of");
exports.MergeQuery = function (defaultQuery) {
    return function (query$) {
        return query$.pipe(operators_1.map(function (query) {
            return __assign({}, defaultQuery, query);
        }));
    };
};
// export const CombineQuery = (addQuery$) => {
//   return (query$) => {
//     if(addQuery$) {
//       return combineLatest(
//         addQuery$,
//         query$,
//         (addQuery, query) => {
//           return query ? {...addQuery, ...query} : query;
//         }
//       )
//     } else {
//       return query$
//     }
//
//   }
// };
// export const PageResults = (pageData$: Observable<Page<any> | null>): Observable<any[] | any> => {
//   return pageData$.pipe(map((pageDate: Page<any> | null) => {
//     return pageDate ? pageDate.results : pageDate;
//   }))
// };
// export const DateRangeToQuery = (dateRangeParam: string): (param: Observable<IDateRange>) => Observable<object> => {
//   return (dateRangeQuery$: Observable<IDateRange>) => {
//     return dateRangeQuery$.pipe(
//       map((dateRange) => {
//         if (!dateRange) return {};
//         let start =  dateRange['start'];
//         let end = dateRange['end'];
//         let param = dateRangeParam;
//         return {[`min_${param}`]: start, [`max_${param}`]: end}
//       })
//     )
//   }
// };
exports.AllowedQueryKeys = function (allowedQueryKeys) {
    return function (queryStore$) {
        if (allowedQueryKeys && allowedQueryKeys.length) {
            var keys$ = _.map(allowedQueryKeys, function (key) {
                return queryStore$.pipe(operators_1.map(function (store) { return (store ? store[key] : null); }), operators_1.distinctUntilChanged(), operators_1.map(function (value) {
                    return value ? (_a = {}, _a[key] = value, _a) : null;
                    var _a;
                }));
            });
            return combineLatest_1.combineLatest.apply(void 0, keys$).pipe(operators_1.map(function (obsArray) {
                return _.reduce(obsArray, function (acc, query) {
                    return query ? __assign({}, acc, query) : acc;
                }, {});
            }));
        }
        else if (allowedQueryKeys) {
            return of_1.of({});
        }
        else {
            return queryStore$;
        }
    };
};
// export const itemAsPage = <T>() => {
//   return (item$): Observable<Page<T>> => {
//     return item$.pipe(
//       map((item) => {
//         return item ?
//           {
//             count: 1,
//             next: null,
//             previous: null,
//             results: [item]
//           } : null
//       })
//     )
//   }
// };
//# sourceMappingURL=operators.js.map