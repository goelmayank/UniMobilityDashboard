var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import * as _ from "underscore";
import { combineLatest } from "rxjs/observable/combineLatest";
import { distinctUntilChanged, map } from "rxjs/operators";
import { of } from "rxjs/observable/of";
export var MergeQuery = function (defaultQuery) {
    return function (query$) {
        return query$.pipe(map(function (query) {
            return __assign({}, defaultQuery, query);
        }));
    };
};
// export const CombineQuery = (addQuery$) => {
//   return (query$) => {
//     if(addQuery$) {
//       return combineLatest(
//         addQuery$,
//         query$,
//         (addQuery, query) => {
//           return query ? {...addQuery, ...query} : query;
//         }
//       )
//     } else {
//       return query$
//     }
//
//   }
// };
// export const PageResults = (pageData$: Observable<Page<any> | null>): Observable<any[] | any> => {
//   return pageData$.pipe(map((pageDate: Page<any> | null) => {
//     return pageDate ? pageDate.results : pageDate;
//   }))
// };
// export const DateRangeToQuery = (dateRangeParam: string): (param: Observable<IDateRange>) => Observable<object> => {
//   return (dateRangeQuery$: Observable<IDateRange>) => {
//     return dateRangeQuery$.pipe(
//       map((dateRange) => {
//         if (!dateRange) return {};
//         let start =  dateRange['start'];
//         let end = dateRange['end'];
//         let param = dateRangeParam;
//         return {[`min_${param}`]: start, [`max_${param}`]: end}
//       })
//     )
//   }
// };
export var AllowedQueryKeys = function (allowedQueryKeys) {
    return function (queryStore$) {
        if (allowedQueryKeys && allowedQueryKeys.length) {
            var keys$ = _.map(allowedQueryKeys, function (key) {
                return queryStore$.pipe(map(function (store) { return (store ? store[key] : null); }), distinctUntilChanged(), map(function (value) {
                    return value ? (_a = {}, _a[key] = value, _a) : null;
                    var _a;
                }));
            });
            return combineLatest.apply(void 0, keys$).pipe(map(function (obsArray) {
                return _.reduce(obsArray, function (acc, query) {
                    return query ? __assign({}, acc, query) : acc;
                }, {});
            }));
        }
        else if (allowedQueryKeys) {
            return of({});
        }
        else {
            return queryStore$;
        }
    };
};
// export const itemAsPage = <T>() => {
//   return (item$): Observable<Page<T>> => {
//     return item$.pipe(
//       map((item) => {
//         return item ?
//           {
//             count: 1,
//             next: null,
//             previous: null,
//             results: [item]
//           } : null
//       })
//     )
//   }
// };
//# sourceMappingURL=operators.js.map