import { circleMarker, divIcon, heatLayer, latLng, latLngBounds, map, marker, markerClusterGroup, polyline, popup, tileLayer } from 'leaflet';
import 'leaflet.markercluster';
import 'leaflet.heat';
import { fromEventPattern as fromEventPattern$1 } from 'rxjs/observable/fromEventPattern';

var defaultOptions = function (options) {
    if (typeof options === 'number') {
        // Legacy
        options = {
            precision: options
        };
    }
    else {
        options = options || {};
    }
    options.precision = options.precision || 5;
    options.factor = options.factor || Math.pow(10, options.precision);
    options.dimension = options.dimension || 2;
    return options;
};
var PolylineUtil = {
    encode: function (points, options) {
        options = defaultOptions(options);
        var flatPoints = [];
        for (var i = 0, len = points.length; i < len; ++i) {
            var point = points[i];
            if (options.dimension === 2) {
                flatPoints.push(point.lat || point[0]);
                flatPoints.push(point.lng || point[1]);
            }
            else {
                for (var dim = 0; dim < options.dimension; ++dim) {
                    flatPoints.push(point[dim]);
                }
            }
        }
        return this.encodeDeltas(flatPoints, options);
    },
    decode: function (encoded, options) {
        options = defaultOptions(options);
        var flatPoints = this.decodeDeltas(encoded, options);
        var points = [];
        for (var i = 0, len = flatPoints.length; i + (options.dimension - 1) < len;) {
            var point = [];
            for (var dim = 0; dim < options.dimension; ++dim) {
                point.push(flatPoints[i++]);
            }
            points.push(point);
        }
        return points;
    },
    encodeDeltas: function (numbers, options) {
        options = defaultOptions(options);
        var lastNumbers = [];
        for (var i = 0, len = numbers.length; i < len;) {
            for (var d = 0; d < options.dimension; ++d, ++i) {
                var num = numbers[i];
                var delta = num - (lastNumbers[d] || 0);
                lastNumbers[d] = num;
                numbers[i] = delta;
            }
        }
        return this.encodeFloats(numbers, options);
    },
    decodeDeltas: function (encoded, options) {
        options = defaultOptions(options);
        var lastNumbers = [];
        var numbers = this.decodeFloats(encoded, options);
        for (var i = 0, len = numbers.length; i < len;) {
            for (var d = 0; d < options.dimension; ++d, ++i) {
                numbers[i] = Math.round((lastNumbers[d] = numbers[i] + (lastNumbers[d] || 0)) * options.factor) / options.factor;
            }
        }
        return numbers;
    },
    encodeFloats: function (numbers, options) {
        options = defaultOptions(options);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            numbers[i] = Math.round(numbers[i] * options.factor);
        }
        return this.encodeSignedIntegers(numbers);
    },
    decodeFloats: function (encoded, options) {
        options = defaultOptions(options);
        var numbers = this.decodeSignedIntegers(encoded);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            numbers[i] /= options.factor;
        }
        return numbers;
    },
    encodeSignedIntegers: function (numbers) {
        for (var i = 0, len = numbers.length; i < len; ++i) {
            var num = numbers[i];
            numbers[i] = (num < 0) ? ~(num << 1) : (num << 1);
        }
        return this.encodeUnsignedIntegers(numbers);
    },
    decodeSignedIntegers: function (encoded) {
        var numbers = this.decodeUnsignedIntegers(encoded);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            var num = numbers[i];
            numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);
        }
        return numbers;
    },
    encodeUnsignedIntegers: function (numbers) {
        var encoded = '';
        for (var i = 0, len = numbers.length; i < len; ++i) {
            encoded += this.encodeUnsignedInteger(numbers[i]);
        }
        return encoded;
    },
    decodeUnsignedIntegers: function (encoded) {
        var numbers = [];
        var current = 0;
        var shift = 0;
        for (var i = 0, len = encoded.length; i < len; ++i) {
            var b = encoded.charCodeAt(i) - 63;
            current |= (b & 0x1f) << shift;
            if (b < 0x20) {
                numbers.push(current);
                current = 0;
                shift = 0;
            }
            else {
                shift += 5;
            }
        }
        return numbers;
    },
    encodeSignedInteger: function (num) {
        num = (num < 0) ? ~(num << 1) : (num << 1);
        return this.encodeUnsignedInteger(num);
    },
    // This function is very similar to Google's, but I added
    // some stuff to deal with the double slash issue.
    encodeUnsignedInteger: function (num) {
        var value, encoded = '';
        while (num >= 0x20) {
            value = (0x20 | (num & 0x1f)) + 63;
            encoded += (String.fromCharCode(value));
            num >>= 5;
        }
        value = num + 63;
        encoded += (String.fromCharCode(value));
        return encoded;
    }
};

var markerCluster = function () {
    // console.log(L.MarkerClusterGroup);
    return markerClusterGroup();
};

var leafletHeat = function (latlng, options) {
    if (options === void 0) { options = {}; }
    // console.log(L.MarkerClusterGroup);
    return heatLayer(latlng, options);
};

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var LeafletMapUtilsClass = (function () {
    function LeafletMapUtilsClass() {
        this.type = 'leaflet';
        this.defaultMapOptions = {
            center: [3.505, 0],
            zoom: 2,
            tileLayerUrl: "http://{s}.tile.osm.org/{z}/{x}/{y}.png",
            tileLayerOptions: {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }
        };
    }
    LeafletMapUtilsClass.prototype.setDefaultMapOptions = function (options) {
        this.defaultMapOptions = __assign({}, this.defaultMapOptions, options);
    };
    LeafletMapUtilsClass.prototype.renderMap = function (elem, options) {
        options = __assign({}, options, this.defaultMapOptions);
        var newmap = map(elem, options);
        if (options.tileLayerUrl) {
            tileLayer(options.tileLayerUrl, options.tileLayerOptions || {}).addTo(newmap);
        }
        return newmap;
    };
    LeafletMapUtilsClass.prototype.setMap = function (item, map$$1) {
        if (((item && !item.getElement) || (item && !item.getElement())) && map$$1.getContainer().offsetWidth) {
            item.addTo(map$$1);
        }
    };
    
    LeafletMapUtilsClass.prototype.setKey = function (key) {
        return true;
    };
    LeafletMapUtilsClass.prototype.setStyle = function (item, style) {
        if (item.setStyle)
            item.setStyle(style);
    };
    
    LeafletMapUtilsClass.prototype.setCircleStyle = function (item, style) {
        this.setStyle(item, style);
    };
    
    LeafletMapUtilsClass.prototype.setPolylineStyle = function (polyline$$1, style) {
        polyline$$1.setStyle(style);
    };
    
    LeafletMapUtilsClass.prototype.clearItem = function (item) {
        item.remove();
        item.off();
    };
    
    LeafletMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {
        if (item === void 0) { item = null; }
        if (bounds === void 0) { bounds = latLngBounds([]); }
        if (force === void 0) { force = false; }
        if (force || (item && !item.getElement) || (item && item.getElement()))
            bounds.extend(item.getLatLng());
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBounds = function (position, bounds) {
        if (bounds === void 0) { bounds = latLngBounds([]); }
        var latlng = this.getLatlng(position);
        bounds.extend(latlng);
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline$$1, bounds) {
        if (polyline$$1 === void 0) { polyline$$1 = null; }
        if (bounds === void 0) { bounds = latLngBounds([]); }
        if (polyline$$1 && polyline$$1.getElement()) {
            bounds.extend(polyline$$1.getBounds());
        }
        return bounds;
    };
    
    LeafletMapUtilsClass.prototype.getLatlng = function (_a) {
        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;
        return latLng(lat, lng);
    };
    
    LeafletMapUtilsClass.prototype.updatePosition = function (marker$$1, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        var latLng$$1 = this.getLatlng(position);
        marker$$1.setLatLng(latLng$$1);
        if (infoContent)
            this.updateTooltip(marker$$1, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.updateTooltip = function (marker$$1, infoContent, defaultOption) {
        if (marker$$1.getTooltip()) {
            marker$$1.setTooltipContent(infoContent);
        }
        else {
            marker$$1.bindTooltip(infoContent, defaultOption);
        }
    };
    LeafletMapUtilsClass.prototype.openTooltip = function (item, content) {
        if (content)
            item.setTooltipContent(content);
        item.openTooltip();
    };
    LeafletMapUtilsClass.prototype.closeTooltip = function (item) {
        item.closeTooltip();
    };
    LeafletMapUtilsClass.prototype.openPopup = function (item, map$$1, content) {
        if (content)
            item.setPopupContent(content);
        item.openPopup();
    };
    LeafletMapUtilsClass.prototype.closePopup = function (item) {
        item.closePopup();
    };
    LeafletMapUtilsClass.prototype.bringToFront = function (item) {
        item.bringToFront();
    };
    LeafletMapUtilsClass.prototype.setFocus = function (item, map$$1, config) {
        if ((item && item.getElement()) || config.force) {
            var markerCenter = this.getItemLatlng(item);
            if (config.center)
                map$$1.panTo(markerCenter, { animate: true, duration: 1 });
            if (config.zoom && config.center)
                map$$1.setView(markerCenter, config.zoom);
        }
    };
    LeafletMapUtilsClass.prototype.getItemLatlng = function (item) {
        return item.getLatLng();
    };
    LeafletMapUtilsClass.prototype.updateCirclePosition = function (circle, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        this.updatePosition(circle, position, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.getCircleMarker = function () {
        return circleMarker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarker = function () {
        return marker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarkerCluster = function (map$$1) {
        var cluster = markerCluster();
        map$$1.addLayer(cluster);
        return cluster;
    };
    LeafletMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {
        cluster.clearLayers();
    };
    LeafletMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker$$1) {
        cluster.removeLayer(marker$$1);
    };
    LeafletMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers) {
        var marker$$1 = markers[0];
        cluster.addLayers(markers);
        cluster.refreshClusters(markers);
    };
    LeafletMapUtilsClass.prototype.getPolyline = function () {
        return polyline([]);
    };
    LeafletMapUtilsClass.prototype.setBounds = function (map$$1, bounds, options) {
        if (map$$1 && map$$1.getContainer() && map$$1.getContainer().offsetWidth) {
            if (options.toFly) {
                map$$1.flyToBounds(bounds, options);
            }
            else {
                map$$1.fitBounds(bounds, options);
            }
        }
    };
    LeafletMapUtilsClass.prototype.isValidBounds = function (bounds) {
        return bounds.isValid();
    };
    LeafletMapUtilsClass.prototype.invalidateSize = function (map$$1) {
        if (map$$1 && map$$1.getContainer().offsetWidth) {
            map$$1.invalidateSize();
        }
    };
    LeafletMapUtilsClass.prototype.getPopup = function (options) {
        return popup(options);
    };
    LeafletMapUtilsClass.prototype.onEvent$ = function (item, type) {
        return fromEventPattern$1(this.mapEventHandler(item, type), this.removeHandler(item, type));
    };
    LeafletMapUtilsClass.prototype.mapEventHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.onEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.removeHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.removeEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.onEvent = function (item, event, cb) {
        item.on(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.removeEvent = function (item, event, cb) {
        item.off(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.openPopupPosition = function (position, map$$1, content, popup$$1) {
        popup$$1
            .setLatLng(position)
            .setContent(content)
            .openOn(map$$1);
    };
    LeafletMapUtilsClass.prototype.setDivContent = function (marker$$1, content, options) {
        if (options === void 0) { options = {}; }
        var currentContent = marker$$1.options.icon ? marker$$1.options.icon.options.html : "";
        if (content != currentContent) {
            this.setDivMarkerStyle(marker$$1, __assign({ html: content }, options));
            options['zIndexOffset'] && marker$$1.setZIndexOffset(options['zIndexOffset']);
        }
        // console.error('set div content not implemented')
    };
    LeafletMapUtilsClass.prototype.getDivMarker = function () {
        return this.getMarker();
    };
    LeafletMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {
        if (options === void 0) { options = {}; }
        var icon = divIcon(options);
        this.setIcons(item, icon);
    };
    LeafletMapUtilsClass.prototype.setIcons = function (marker$$1, icon) {
        marker$$1.setIcon(icon);
    };
    LeafletMapUtilsClass.prototype.getHeatmap = function (options) {
        if (options === void 0) { options = {}; }
        return leafletHeat([], options);
    };
    LeafletMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {
        var latlngArray = latlngs.map(function (pos) { return ([pos.lat, pos.lng, pos.weight || 1]); });
        heatmap.setLatLngs(latlngArray);
    };
    LeafletMapUtilsClass.prototype.setEncodedPath = function (polyline$$1, encodedPolyline) {
        var path = PolylineUtil.decode(encodedPolyline);
        return polyline$$1.setLatLngs(path);
    };
    
    LeafletMapUtilsClass.prototype.setPath = function (polyline$$1, path) {
        var _this = this;
        path = path.map(function (pos) {
            return _this.getLatlng(pos);
        });
        polyline$$1.setLatLngs(path);
    };
    
    LeafletMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline$$1, positionTimeArray) {
        return polyline$$1.setLatLngs(positionTimeArray);
    };
    
    LeafletMapUtilsClass.prototype.getItemPosition = function (item) {
        var position = item.getLatLng();
        return position ? { lat: position.lat, lng: position.lng } : null;
    };
    LeafletMapUtilsClass.prototype.getElement = function (item) {
        return item ? item.getElement() : null;
    };
    return LeafletMapUtilsClass;
}());

export { defaultOptions, PolylineUtil, markerCluster, leafletHeat, LeafletMapUtilsClass };
