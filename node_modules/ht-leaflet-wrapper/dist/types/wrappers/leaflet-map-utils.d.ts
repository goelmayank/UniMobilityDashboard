import { HtBounds, HtMapType, MapUtils, SetFocusConfig } from "ht-map-wrapper";
import { HtPosition } from "ht-models";
import { Map, LatLng, LatLngBounds, Popup } from "leaflet";
import { LineString, MultiLineString } from "geojson";
import * as L from "leaflet";
import { Observable } from "rxjs/Observable";
export declare class LeafletMapUtilsClass implements MapUtils {
    type: HtMapType;
    defaultMapOptions: {
        center: number[];
        zoom: number;
        tileLayerUrl: string;
        tileLayerOptions: {
            attribution: string;
        };
    };
    setDefaultMapOptions(options: any): void;
    renderMap(elem: HTMLElement | string, options: any): Map;
    setMap(item: any, map: Map): void;
    setKey(key: any): boolean;
    setStyle(item: any, style: any): void;
    setCircleStyle(item: any, style: any): void;
    setPolylineStyle(polyline: any, style: any): void;
    clearItem(item: any): void;
    extendItemBounds(item?: any, bounds?: LatLngBounds, force?: boolean): LatLngBounds;
    extendBounds(position: HtPosition, bounds?: LatLngBounds): HtBounds;
    extendBoundsWithPolyline(polyline?: any, bounds?: LatLngBounds): LatLngBounds;
    getLatlng({lat, lng}?: HtPosition): LatLng;
    updatePosition(marker: any, position: HtPosition, infoContent?: string, defaultOption?: L.TooltipOptions): void;
    updateTooltip(marker: any, infoContent: any, defaultOption: any): void;
    openTooltip(item: L.Marker, content?: string): void;
    closeTooltip(item: any): void;
    openPopup(item: any, map: any, content?: string): void;
    closePopup(item: any): void;
    bringToFront(item: any): void;
    setFocus(item: any, map: L.Map, config: SetFocusConfig): void;
    getItemLatlng(item: any): any;
    updateCirclePosition(circle: any, position: any, infoContent?: string, defaultOption?: L.TooltipOptions): void;
    getCircleMarker(): L.CircleMarker<any>;
    getMarker(): L.Marker<any>;
    getMarkerCluster(map: any): L.MarkerClusterGroup;
    removeClusterMarkers(cluster: any): void;
    removeClusterMarker(cluster: any, marker: any): void;
    addMarkersToCluster(cluster: any, markers: any): void;
    getPolyline(): L.Polyline<LineString | MultiLineString, any>;
    setBounds(map: L.Map, bounds: L.LatLngBounds, options?: any): void;
    isValidBounds(bounds: L.LatLngBounds): boolean;
    invalidateSize(map: L.Map): void;
    getPopup(options: any): Popup;
    onEvent$(item: any, type: string): Observable<any>;
    private mapEventHandler(item, type);
    private removeHandler(item, type);
    onEvent(item: any, event: any, cb: any): void;
    removeEvent(item: any, event: any, cb?: any): void;
    openPopupPosition(position: any, map: any, content: any, popup: any): void;
    setDivContent(marker: any, content: any, options?: {}): void;
    getDivMarker(): L.Marker<any>;
    setDivMarkerStyle(item: any, options?: any): void;
    setIcons(marker: any, icon: any): void;
    getHeatmap(options?: {}): L.HeatLayer;
    updateHeatMapLatlng(latlngs: HtPosition[], heatmap: any): void;
    setEncodedPath(polyline: any, encodedPolyline: string): any;
    setPath(polyline: L.Polyline, path: HtPosition[]): void;
    setPathPositionTimeArray(polyline: any, positionTimeArray: any): any;
    getItemPosition(item: L.Marker): {
        lat: number;
        lng: number;
    };
    getElement(item: any): any;
}
