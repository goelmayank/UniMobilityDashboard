"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var encoded_polyline_1 = require("./encoded-polyline");
var leaflet_1 = require("leaflet");
var leaflet_markercluster_1 = require("./leaflet.markercluster");
var leaflet_heatmap_1 = require("./leaflet.heatmap");
var fromEventPattern_1 = require("rxjs/observable/fromEventPattern");
var LeafletMapUtilsClass = (function () {
    function LeafletMapUtilsClass() {
        this.type = 'leaflet';
        this.defaultMapOptions = {
            center: [3.505, 0],
            zoom: 2,
            tileLayerUrl: "http://{s}.tile.osm.org/{z}/{x}/{y}.png",
            tileLayerOptions: {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }
        };
    }
    LeafletMapUtilsClass.prototype.setDefaultMapOptions = function (options) {
        this.defaultMapOptions = __assign({}, this.defaultMapOptions, options);
    };
    LeafletMapUtilsClass.prototype.renderMap = function (elem, options) {
        options = __assign({}, options, this.defaultMapOptions);
        var newmap = leaflet_1.map(elem, options);
        if (options.tileLayerUrl) {
            leaflet_1.tileLayer(options.tileLayerUrl, options.tileLayerOptions || {}).addTo(newmap);
        }
        return newmap;
    };
    LeafletMapUtilsClass.prototype.setMap = function (item, map) {
        if (((item && !item.getElement) || (item && !item.getElement())) && map.getContainer().offsetWidth) {
            item.addTo(map);
        }
    };
    ;
    LeafletMapUtilsClass.prototype.setKey = function (key) {
        return true;
    };
    LeafletMapUtilsClass.prototype.setStyle = function (item, style) {
        if (item.setStyle)
            item.setStyle(style);
    };
    ;
    LeafletMapUtilsClass.prototype.setCircleStyle = function (item, style) {
        this.setStyle(item, style);
    };
    ;
    LeafletMapUtilsClass.prototype.setPolylineStyle = function (polyline, style) {
        polyline.setStyle(style);
    };
    ;
    LeafletMapUtilsClass.prototype.clearItem = function (item) {
        item.remove();
        item.off();
    };
    ;
    LeafletMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {
        if (item === void 0) { item = null; }
        if (bounds === void 0) { bounds = leaflet_1.latLngBounds([]); }
        if (force === void 0) { force = false; }
        if (force || (item && !item.getElement) || (item && item.getElement()))
            bounds.extend(item.getLatLng());
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBounds = function (position, bounds) {
        if (bounds === void 0) { bounds = leaflet_1.latLngBounds([]); }
        var latlng = this.getLatlng(position);
        bounds.extend(latlng);
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline, bounds) {
        if (polyline === void 0) { polyline = null; }
        if (bounds === void 0) { bounds = leaflet_1.latLngBounds([]); }
        if (polyline && polyline.getElement()) {
            bounds.extend(polyline.getBounds());
        }
        return bounds;
    };
    ;
    LeafletMapUtilsClass.prototype.getLatlng = function (_a) {
        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;
        return leaflet_1.latLng(lat, lng);
    };
    ;
    LeafletMapUtilsClass.prototype.updatePosition = function (marker, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        var latLng = this.getLatlng(position);
        marker.setLatLng(latLng);
        if (infoContent)
            this.updateTooltip(marker, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.updateTooltip = function (marker, infoContent, defaultOption) {
        if (marker.getTooltip()) {
            marker.setTooltipContent(infoContent);
        }
        else {
            marker.bindTooltip(infoContent, defaultOption);
        }
    };
    LeafletMapUtilsClass.prototype.openTooltip = function (item, content) {
        if (content)
            item.setTooltipContent(content);
        item.openTooltip();
    };
    LeafletMapUtilsClass.prototype.closeTooltip = function (item) {
        item.closeTooltip();
    };
    LeafletMapUtilsClass.prototype.openPopup = function (item, map, content) {
        if (content)
            item.setPopupContent(content);
        item.openPopup();
    };
    LeafletMapUtilsClass.prototype.closePopup = function (item) {
        item.closePopup();
    };
    LeafletMapUtilsClass.prototype.bringToFront = function (item) {
        item.bringToFront();
    };
    LeafletMapUtilsClass.prototype.setFocus = function (item, map, config) {
        if ((item && item.getElement()) || config.force) {
            var markerCenter = this.getItemLatlng(item);
            if (config.center)
                map.panTo(markerCenter, { animate: true, duration: 1 });
            if (config.zoom && config.center)
                map.setView(markerCenter, config.zoom);
        }
    };
    LeafletMapUtilsClass.prototype.getItemLatlng = function (item) {
        return item.getLatLng();
    };
    LeafletMapUtilsClass.prototype.updateCirclePosition = function (circle, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        this.updatePosition(circle, position, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.getCircleMarker = function () {
        return leaflet_1.circleMarker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarker = function () {
        return leaflet_1.marker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarkerCluster = function (map) {
        var cluster = leaflet_markercluster_1.markerCluster();
        map.addLayer(cluster);
        return cluster;
    };
    LeafletMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {
        cluster.clearLayers();
    };
    LeafletMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker) {
        cluster.removeLayer(marker);
    };
    LeafletMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers) {
        var marker = markers[0];
        cluster.addLayers(markers);
        cluster.refreshClusters(markers);
    };
    LeafletMapUtilsClass.prototype.getPolyline = function () {
        return leaflet_1.polyline([]);
    };
    LeafletMapUtilsClass.prototype.setBounds = function (map, bounds, options) {
        if (map && map.getContainer() && map.getContainer().offsetWidth) {
            if (options.toFly) {
                map.flyToBounds(bounds, options);
            }
            else {
                map.fitBounds(bounds, options);
            }
        }
    };
    LeafletMapUtilsClass.prototype.isValidBounds = function (bounds) {
        return bounds.isValid();
    };
    LeafletMapUtilsClass.prototype.invalidateSize = function (map) {
        if (map && map.getContainer().offsetWidth) {
            map.invalidateSize();
        }
    };
    LeafletMapUtilsClass.prototype.getPopup = function (options) {
        return leaflet_1.popup(options);
    };
    LeafletMapUtilsClass.prototype.onEvent$ = function (item, type) {
        return fromEventPattern_1.fromEventPattern(this.mapEventHandler(item, type), this.removeHandler(item, type));
    };
    LeafletMapUtilsClass.prototype.mapEventHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.onEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.removeHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.removeEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.onEvent = function (item, event, cb) {
        item.on(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.removeEvent = function (item, event, cb) {
        item.off(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.openPopupPosition = function (position, map, content, popup) {
        popup
            .setLatLng(position)
            .setContent(content)
            .openOn(map);
    };
    LeafletMapUtilsClass.prototype.setDivContent = function (marker, content, options) {
        if (options === void 0) { options = {}; }
        var currentContent = marker.options.icon ? marker.options.icon.options.html : "";
        if (content != currentContent) {
            this.setDivMarkerStyle(marker, __assign({ html: content }, options));
            options['zIndexOffset'] && marker.setZIndexOffset(options['zIndexOffset']);
        }
        // console.error('set div content not implemented')
    };
    LeafletMapUtilsClass.prototype.getDivMarker = function () {
        return this.getMarker();
    };
    LeafletMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {
        if (options === void 0) { options = {}; }
        var icon = leaflet_1.divIcon(options);
        this.setIcons(item, icon);
    };
    LeafletMapUtilsClass.prototype.setIcons = function (marker, icon) {
        marker.setIcon(icon);
    };
    LeafletMapUtilsClass.prototype.getHeatmap = function (options) {
        if (options === void 0) { options = {}; }
        return leaflet_heatmap_1.leafletHeat([], options);
    };
    LeafletMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {
        var latlngArray = latlngs.map(function (pos) { return ([pos.lat, pos.lng, pos.weight || 1]); });
        heatmap.setLatLngs(latlngArray);
    };
    LeafletMapUtilsClass.prototype.setEncodedPath = function (polyline, encodedPolyline) {
        var path = encoded_polyline_1.PolylineUtil.decode(encodedPolyline);
        return polyline.setLatLngs(path);
    };
    ;
    LeafletMapUtilsClass.prototype.setPath = function (polyline, path) {
        var _this = this;
        path = path.map(function (pos) {
            return _this.getLatlng(pos);
        });
        polyline.setLatLngs(path);
    };
    ;
    LeafletMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline, positionTimeArray) {
        return polyline.setLatLngs(positionTimeArray);
    };
    ;
    LeafletMapUtilsClass.prototype.getItemPosition = function (item) {
        var position = item.getLatLng();
        return position ? { lat: position.lat, lng: position.lng } : null;
    };
    LeafletMapUtilsClass.prototype.getElement = function (item) {
        return item ? item.getElement() : null;
    };
    return LeafletMapUtilsClass;
}());
exports.LeafletMapUtilsClass = LeafletMapUtilsClass;
//# sourceMappingURL=leaflet-map-utils.js.map