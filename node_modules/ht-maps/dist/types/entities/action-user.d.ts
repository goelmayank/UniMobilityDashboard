import { HtPosition, IAction } from "ht-models";
import { Entities, Entity, StyleFunct } from "../interfaces";
import { MapInstance } from "../map-utils/map-instance";
import { TimeAwareAnimation } from "time-aware-polyline";
import { IPathBearingTime } from "ht-models";
import { IMarkersArray, SetDataConfig } from "../mixins/data-observable";
import { Observable } from "rxjs/Observable";
import { Subscription } from "rxjs/Subscription";
import { AnimationsEntities } from "../mixins/animations-entities";
import { HtCustomEvent, IEventSub } from "ht-utility";
export declare class ActionUser {
    mapInstance: MapInstance;
    name: string;
    animation?: TimeAwareAnimation;
    entities: Entities<IAction>;
    styleFunct: StyleFunct;
    setTimeAwareAnimationEntity: (animationEntity?: AnimationsEntities) => void;
    setData$: (data$: Observable<any[]>) => void;
    constructor(mapInstance: MapInstance);
    getPosition(data: any): HtPosition;
    trackBy(action: IAction): string;
    trackAnimationBy(action: IAction): string;
    getDivContent(data: any): string;
}
export declare const ActionUserTrace: {
    new (...args: any[]): {
        dataSub: Subscription;
        dataPageSource$: Observable<{
            count: number;
            next: string;
            previous: string;
            results: any[];
        }>;
        dataArraySource$: Observable<any[]>;
        data$: Observable<IMarkersArray>;
        _procData$(): (source$: Observable<{
            count: number;
            next: string;
            previous: string;
            results: any[];
        }>) => Observable<any>;
        getMarkersArray(array: any[], isNew?: boolean): any;
        setPageData$(data$: Observable<{
            count: number;
            next: string;
            previous: string;
            results: any[];
        }>, config?: SetDataConfig): void;
        setData$(data$: Observable<any[]>, config?: SetDataConfig): void;
        _initDataObserver(): void;
        clear(): void;
        trace: (data: any, map?: any) => any;
        isValidMapItems?: (data: any) => boolean;
        getPosition: (data: any) => HtPosition;
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        entities: Entities<any>;
        toIncludeInBounds: boolean;
        extendBounds(bounds: any): any;
        getBounds: (item: any, bounds: any) => any;
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        isAnimated: boolean;
        animationEntities: AnimationsEntities;
        toNotTraceItem: boolean;
        subs: {
            [id: string]: any;
        };
        setTimeAwareAnimationEntity(animationEntity?: AnimationsEntities): void;
        clearItem(entity: any): void;
        update(entity: any, pathBearing: any): void;
        initSub(id: any, animId?: string): void;
        clearSub(id: any): void;
        getEntity(id?: any): Entity<any>;
        getTimeAwarePolyline?(data: any): string;
        trackBy(datum: any): string;
        trackAnimationBy(datum: any): string;
    };
} & {
    new (...args: any[]): {
        getItem(data: any): any;
        update({item, data}: {
            item: any;
            data: any;
        }, pathBearing?: IPathBearingTime): void;
        setContent({item, content}: {
            item: any;
            content: any;
        }): void;
        setStyle(entity: any): void;
        getDivContent: (data: any, bearing?: number) => string;
        getStyle: (type?: any) => object;
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        trace(data: any[], map?: any): boolean;
        traceItem(datum: any): void;
        addEvents(item: any, id: any): void;
        bustOldItem(): void;
        getItem: (data: any) => any;
        onMouseLeave?: (trace: any) => void;
        onClick?: (trace: any) => void;
        onMouseEnter?: (trace: any) => void;
        setStyle: (entity: Entity<any>) => void;
        update: (entity: any) => void;
        traceEffect?: () => void;
        removeAll: (entities: any) => void;
        getBounds: (item: any, bounds?: any) => any;
        removeItem: (item: any) => void;
        removeData: (data: any) => void;
        clearItem: (entity: Entity<any>) => void;
        toNotSetMap?: boolean;
        toNotTraceItem?: boolean;
        trackBy(datum: any): string;
        entities: Entities<any>;
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        entities: Entities<any>;
        event: HtCustomEvent;
        htShow(item: any): string;
        getItem(data: any): any;
        getBounds(item: any, bounds?: any): any;
        update({item, data}: {
            item: any;
            data: any;
        }, positionBearing?: IPathBearingTime): void;
        onEntityUpdate(id: any): {
            subscribe: (cb: any) => IEventSub;
        };
        removeItem(item: any): void;
        removeAll(entities: any): void;
        clear(): void;
        clearItem({item, data}: {
            item: any;
            data: any;
        }): void;
        removeData(data: any): void;
        getStyle: (styleType?: any) => object;
        getPosition: (data: any) => HtPosition;
        forceExtendBounds?: boolean;
        mapInstance: MapInstance;
        toNotSetMap?: boolean;
        trackBy(datum: any): string;
    };
} & {
    new (...args: any[]): {
        defaultstyleFunct: StyleFunct;
        styleType: string;
        highlightedId: string;
        styleObj: object;
        getStyle(selectedStyleType?: string, fallbackStyle?: any): any;
        setStyleType(styleType?: string): void;
        setStyle({item, data}: {
            item: any;
            data: any;
        }): void;
        getStyleType(datum: any): string;
        setItemStyle(item: any, style: any): void;
        styleFunct: StyleFunct;
        name?: string;
        mapInstance: MapInstance;
        trackBy(datum: any): string;
        isAnimated?: boolean;
    };
} & {
    new (...args: any[]): {
        entities: Entities<any>;
        getEntity(id?: string): Entity<any>;
        trackBy(datum: any): any;
        trackAnimationBy(datum: any): any;
        mapInstance: MapInstance;
    };
} & typeof ActionUser;
