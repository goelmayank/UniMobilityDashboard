import { MapInstance } from "../map-utils/map-instance";
import { SegmentPolylines } from "./segment-polylines";
import { Entity, StyleFunct } from "../interfaces";
import { HtPosition, IPlacelineMod } from "ht-models";
import { TimeAwareAnimation } from "time-aware-polyline";
import { IPathBearingTime } from "ht-models";
import { Constructor } from "../interfaces";
import { HtCustomEvent, IEventSub } from "ht-utility";
export declare class ActionsPolyline extends SegmentPolylines {
    lineSymbol: {
        path: string;
        strokeOpacity: number;
        scale: number;
    };
    styleFunct: {
        get(type: any): {
            default: {
                strokeColor: string;
                strokeOpacity: number;
                strokeWeight: number;
                icons: {
                    icon: {
                        path: string;
                        strokeOpacity: number;
                        scale: number;
                    };
                    offset: string;
                    repeat: string;
                }[];
            };
            highlight: {
                strokeColor: string;
                strokeOpacity: number;
                strokeWeight: number;
            };
            fade: {
                strokeColor: string;
                strokeOpacity: number;
                strokeWeight: number;
            };
        } | {
            default: {
                weight: number;
                color: string;
                opacity: number;
                dashArray: string;
            };
            highlight: {
                weight: number;
                color: string;
                opacity: number;
            };
            fade: {
                weight: number;
                color: string;
                opacity: number;
            };
        };
    };
    mapInstance: MapInstance;
    animation: TimeAwareAnimation;
    name: string;
    getPathFromData(data: IPlacelineMod): any[];
}
export declare const ActionsPolylineTrace: {
    new (...args: any[]): {
        positionTimeArray: any[];
        connector: any;
        setConnector(entity: any): void;
        getConnectorPosition(): HtPosition;
        update({item, data}: {
            item: any;
            data: any;
        }, pathBearing: IPathBearingTime): void;
        mapInstance: MapInstance;
        getPathFromData(data: any): HtPosition[];
        toNotSetMap?: boolean;
        clear(): void;
    };
} & {
    new (...args: any[]): {
        isAnimated: boolean;
        setTimeAwareAnimation(animation: TimeAwareAnimation): void;
        animation?: TimeAwareAnimation;
        getEntity(): Entity<any>;
        update(entity: any, pathBearing: IPathBearingTime): void;
    };
} & {
    new (...args: any[]): {
        trace(user: any, map?: any): void;
        entities: {
            [id: string]: Entity<any>;
        };
    };
} & {
    new (...args: any[]): {
        trace(data: any[], map?: any): boolean;
        traceItem(datum: any): void;
        addEvents(item: any, id: any): void;
        bustOldItem(): void;
        getItem: (data: any) => any;
        onMouseLeave?: (trace: any) => void;
        onClick?: (trace: any) => void;
        onMouseEnter?: (trace: any) => void;
        setStyle: (entity: Entity<any>) => void;
        update: (entity: any) => void;
        traceEffect?: () => void;
        removeAll: (entities: any) => void;
        getBounds: (item: any, bounds?: any) => any;
        removeItem: (item: any) => void;
        removeData: (data: any) => void;
        clearItem: (entity: Entity<any>) => void;
        toNotSetMap?: boolean;
        toNotTraceItem?: boolean;
        trackBy(datum: any): string;
        entities: {
            [id: string]: Entity<any>;
        };
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        entities: {
            [id: string]: Entity<any>;
        };
        toIncludeInBounds: boolean;
        extendBounds(bounds: any): any;
        getBounds: (item: any, bounds: any) => any;
        mapInstance: MapInstance;
    };
} & {
    new (...args: any[]): {
        positionTimeArray: any[];
        getItem(data: any): any;
        getBounds(item: any, bounds?: any): any;
        update({item, data}: {
            item: any;
            data: any;
        }, pathBearing: IPathBearingTime): void;
        setItemStyle(item: any, style: any): void;
        getPath?(path: (string | number)[][]): HtPosition[];
        getEncodedPositionTime: any;
        getEncodedPath(data: any): any;
        getStyle: (string?: any) => object;
        mapInstance: MapInstance;
        toNotSetMap?: boolean;
    };
} & {
    new (...args: any[]): {
        entities: {
            [id: string]: Entity<any>;
        };
        event: HtCustomEvent;
        htShow(item: any): string;
        getItem(data: any): any;
        getBounds(item: any, bounds?: any): any;
        update({item, data}: {
            item: any;
            data: any;
        }, positionBearing?: IPathBearingTime): void;
        onEntityUpdate(id: any): {
            subscribe: (cb: any) => IEventSub;
        };
        removeItem(item: any): void;
        removeAll(entities: any): void;
        clear(): void;
        clearItem({item, data}: {
            item: any;
            data: any;
        }): void;
        removeData(data: any): void;
        getStyle: (styleType?: any) => object;
        getPosition: (data: any) => HtPosition;
        forceExtendBounds?: boolean;
        mapInstance: MapInstance;
        toNotSetMap?: boolean;
        trackBy(datum: any): string;
    };
} & {
    new (...args: any[]): {
        defaultstyleFunct: StyleFunct;
        styleType: string;
        highlightedId: string;
        styleObj: object;
        getStyle(selectedStyleType?: string, fallbackStyle?: any): any;
        setStyleType(styleType?: string): void;
        setStyle({item, data}: {
            item: any;
            data: any;
        }): void;
        getStyleType(datum: any): string;
        setItemStyle(item: any, style: any): void;
        styleFunct: StyleFunct;
        name?: string;
        mapInstance: MapInstance;
        trackBy(datum: any): string;
        isAnimated?: boolean;
    };
} & {
    new (...args: any[]): {
        entities: {
            [id: string]: Entity<any>;
        };
        getEntity(id?: string): Entity<any>;
        trackBy(datum: any): any;
        trackAnimationBy(datum: any): any;
        mapInstance: MapInstance;
    };
} & typeof ActionsPolyline;
export interface IConnectorBase {
    mapInstance: MapInstance;
    getPathFromData(data: any): HtPosition[] | null;
    toNotSetMap?: boolean;
    clear(): void;
}
export declare function ConnectorMixin<TBase extends Constructor<IConnectorBase>>(Base: TBase): {
    new (...args: any[]): {
        positionTimeArray: any[];
        connector: any;
        setConnector(entity: any): void;
        getConnectorPosition(): HtPosition;
        update({item, data}: {
            item: any;
            data: any;
        }, pathBearing: IPathBearingTime): void;
        mapInstance: MapInstance;
        getPathFromData(data: any): HtPosition[];
        toNotSetMap?: boolean;
        clear(): void;
    };
} & TBase;
