import { filter, map, take } from 'rxjs/operators';
import { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';
import { each, filter as filter$1, map as map$1, reduce, values } from 'underscore';
import { fromEventPattern as fromEventPattern$1 } from 'rxjs/observable/fromEventPattern';
import { circleMarker, divIcon, heatLayer, latLng, latLngBounds, map as map$2, marker, markerClusterGroup, polyline, popup, tileLayer } from 'leaflet';
import 'leaflet.markercluster';
import 'leaflet.heat';
import { Color, DateString, HMString, HtCustomEvent, NameCase, TimeString } from 'ht-utility';
import { TimeAwareAnimation, TimeAwareEncoder } from 'time-aware-polyline';
import { combineLatest as combineLatest$1 } from 'rxjs/observable/combineLatest';
import { dataWithSelectedId$, htAction, htUser, orCombine } from 'ht-data';

var LightColorMapStyle = [
    {
        "featureType": "all",
        "elementType": "labels.text.fill",
        "stylers": [
            {
                "saturation": 36
            },
            {
                "color": "#333333"
            },
            {
                "lightness": 40
            }
        ]
    },
    {
        "featureType": "all",
        "elementType": "labels.text.stroke",
        "stylers": [
            {
                "visibility": "on"
            },
            {
                "color": "#ffffff"
            },
            {
                "lightness": 16
            }
        ]
    },
    {
        "featureType": "all",
        "elementType": "labels.icon",
        "stylers": [
            {
                "visibility": "off"
            }
        ]
    },
    {
        "featureType": "administrative",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#fefefe"
            },
            {
                "lightness": 20
            }
        ]
    },
    {
        "featureType": "administrative",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#fefefe"
            },
            {
                "lightness": 17
            },
            {
                "weight": 1.2
            }
        ]
    },
    {
        "featureType": "administrative.country",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#dadada"
            }
        ]
    },
    {
        "featureType": "administrative.province",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#cfcfcf"
            }
        ]
    },
    {
        "featureType": "landscape",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f5f5f5"
            },
            {
                "lightness": 20
            }
        ]
    },
    {
        "featureType": "landscape.man_made",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#ecedee"
            }
        ]
    },
    {
        "featureType": "landscape.natural.landcover",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "saturation": "-14"
            }
        ]
    },
    {
        "featureType": "landscape.natural.landcover",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "saturation": "-12"
            },
            {
                "lightness": "60"
            }
        ]
    },
    {
        "featureType": "landscape.natural.terrain",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#dbe5da"
            }
        ]
    },
    {
        "featureType": "poi",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f5f5f5"
            },
            {
                "lightness": 21
            }
        ]
    },
    {
        "featureType": "poi.park",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#dedede"
            },
            {
                "lightness": 21
            }
        ]
    },
    {
        "featureType": "poi.park",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#e2f0e0"
            }
        ]
    },
    {
        "featureType": "road.highway",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 17
            }
        ]
    },
    {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 29
            },
            {
                "weight": 0.2
            }
        ]
    },
    {
        "featureType": "road.arterial",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 18
            }
        ]
    },
    {
        "featureType": "road.local",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 16
            }
        ]
    },
    {
        "featureType": "transit",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f2f2f2"
            },
            {
                "lightness": 19
            }
        ]
    },
    {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#e9e9e9"
            },
            {
                "lightness": 17
            }
        ]
    },
    {
        "featureType": "water",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "saturation": "6"
            },
            {
                "gamma": "4.20"
            },
            {
                "lightness": "72"
            },
            {
                "color": "#d9e5eb"
            }
        ]
    }
];

var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var GoogleMapUtilsClass = (function () {
    function GoogleMapUtilsClass() {
        this.type = 'google';
        this.defaultMapOptions = {
            center: { lat: 0, lng: 0 },
            zoom: 2,
            fullscreenControl: false,
            streetViewControl: false,
            styles: LightColorMapStyle
        };
        this.setStyle = function (item, style) {
            item.setOptions(style);
        };
    }
    GoogleMapUtilsClass.prototype.setDefaultMapOptions = function (options) {
        this.defaultMapOptions = __assign$1({}, this.defaultMapOptions, options);
    };
    GoogleMapUtilsClass.prototype.renderMap = function (elem, options) {
        options = __assign$1({}, options, this.defaultMapOptions);
        return new google.maps.Map(elem, options);
    };
    GoogleMapUtilsClass.prototype.setKey = function (key) {
        if (document) {
            this.loadGoogleMaps(key, function () {
                // this.loadMarkerCluster();
                // this.loadRichMarker();
            });
            return true;
        }
        return false;
    };
    GoogleMapUtilsClass.prototype.loadGoogleMaps = function (key, cb) {
        var url = "https://maps.googleapis.com/maps/api/js?key=" + key + "&libraries=geometry,visualization";
        this.loadScript(url, cb);
    };
    GoogleMapUtilsClass.prototype.loadMarkerCluster = function () {
        // const url = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js";
        // this.loadScript(url)
        // import("./markerclusterer")
    };
    GoogleMapUtilsClass.prototype.loadRichMarker = function () {
        // const url = "http://googlemaps.github.io/js-rich-marker/src/richmarker-compiled.js";
        // this.loadScript(url)
        // import("./richmarker")
    };
    GoogleMapUtilsClass.prototype.loadScript = function (url, cb) {
        var script = document.createElement("script");
        script.src = url;
        if (cb)
            script.onload = cb();
        document.head.appendChild(script);
    };
    GoogleMapUtilsClass.prototype.updatePositionPopup = function (marker$$1, position, infoContent, defaultOption) {
        if (defaultOption === void 0) { defaultOption = {}; }
        marker$$1.setPosition(position);
        this.updatePopup(marker$$1, infoContent, defaultOption);
    };
    GoogleMapUtilsClass.prototype.updatePopup = function (marker$$1, infoContent, defaultOption) {
        // if(marker.getPopup()) {
        //   marker.setPopupContent(infoContent)
        // } else {
        //   marker.bindPopup(infoContent, defaultOption);
        // }
    };
    GoogleMapUtilsClass.prototype.setMap = function (item, map$$1) {
        if (!map$$1) {
            item.setMap(null);
        }
        else if ((item && !item.getMap) || (item && !item.getMap())) {
            item.setMap(map$$1);
        }
    };
    
    GoogleMapUtilsClass.prototype.clearItem = function (item) {
        item.setMap(null);
    };
    
    GoogleMapUtilsClass.prototype.updatePosition = function (marker$$1, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        position = this.getLatlng(position);
        marker$$1.setPosition(position);
        // if(infoContent) HtUpdateTooltip(marker, infoContent, defaultOption)
    };
    GoogleMapUtilsClass.prototype.updateTooltip = function (marker$$1, infoContent, defaultOption) {
        // if(marker.getTooltip()) {
        //   marker.setTooltipContent(infoContent)
        // } else {
        //   marker.bindTooltip(infoContent, defaultOption);
        // }
    };
    GoogleMapUtilsClass.prototype.setCircleStyle = function (item, style) {
        var circleStyle = __assign$1({}, style, { icon: __assign$1({}, style.icon, { path: google.maps.SymbolPath.CIRCLE }) });
        this.setStyle(item, circleStyle);
    };
    GoogleMapUtilsClass.prototype.setPolylineStyle = function (polyline$$1, style) {
        this.setStyle(polyline$$1, style);
    };
    
    GoogleMapUtilsClass.prototype.openTooltip = function (item, content) {
        // if(content) item.setTooltipContent(content);
        // item.openTooltip()
    };
    GoogleMapUtilsClass.prototype.closeTooltip = function (item) {
        // item.closeTooltip()
    };
    GoogleMapUtilsClass.prototype.openPopup = function (item, map$$1, content, popup$$1) {
        if (popup$$1) {
            popup$$1.setContent(content);
            // console.log(item.getPosition().lat());
            popup$$1.open(map$$1, item);
        }
        // if(content) item.setPopupContent(content);
        // item.openPopup()
    };
    GoogleMapUtilsClass.prototype.closePopup = function (item) {
        // item.closePopup()
    };
    GoogleMapUtilsClass.prototype.bringToFront = function (item) {
        // item.bringToFront()
    };
    GoogleMapUtilsClass.prototype.setFocus = function (item, map$$1, _a) {
        var zoom = _a.zoom, _b = _a.force, force = _b === void 0 ? false : _b, center = _a.center;
        if ((item && item.getMap()) || force) {
            var markerCenter = this.getItemLatlng(item);
            if (center)
                map$$1.setCenter(markerCenter);
            if (zoom && center)
                map$$1.setZoom(zoom);
            // item.setAnimation(google.maps.Animation.DROP);
            // setTimeout(() => {
            //   item.setAnimation(null);
            //
            // }, 1000)
        }
    };
    GoogleMapUtilsClass.prototype.getItemLatlng = function (item) {
        return item.getPosition();
    };
    GoogleMapUtilsClass.prototype.updateCirclePosition = function (circle, position) {
        circle.setCenter(position);
    };
    GoogleMapUtilsClass.prototype.extendBounds = function (position, bounds) {
        if (bounds === void 0) { bounds = new google.maps.LatLngBounds(); }
        var latlng = this.getLatlng(position);
        bounds.extend(latlng);
        return bounds;
    };
    GoogleMapUtilsClass.prototype.getCircleMarker = function () {
        return new google.maps.Marker();
    };
    GoogleMapUtilsClass.prototype.getMarker = function () {
        return new google.maps.Marker();
    };
    GoogleMapUtilsClass.prototype.getMarkerCluster = function (map$$1) {
        // console.log("get", map);
        return new MarkerClusterer(map$$1, [], {
            imagePath: "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m"
        });
    };
    GoogleMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {
        cluster.clearMarkers();
    };
    GoogleMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker$$1) {
        cluster.removeMarker(marker$$1);
    };
    GoogleMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers, map$$1) {
        // if(listAll.length) console.log(map, "map", listAll[0]);
        // cluster.setMap(map);
        var clusterMarkers = cluster.getMarkers();
        markers.forEach(function (marker$$1) {
            // if(markerEntity[marker['id']]) {
            //
            // } else {
            //   cluster.addMarker(marker)
            // }
            //alternate aproach
            if (clusterMarkers.indexOf && clusterMarkers.indexOf(marker$$1) > -1) {
            }
            else {
                cluster.addMarker(marker$$1);
            }
        });
        // var hasId = clusterMarkers && clusterMarkers.length && clusterMarkers[0]['id'];
        // if(hasId) {
        //   let markerEntity = _.indexBy(clusterMarkers, 'id');
        //   listAll.forEach((marker) => {
        //     if(markerEntity[marker['id']]) {
        //
        //     } else {
        //       cluster.addMarker(marker)
        //     }
        //   })
        // } else {
        //   _.each(listAll, (marker) => {
        //     // console.log(marker.getPosition().lng());
        //     cluster.removeMarker(marker);
        //     cluster.addMarker(marker)
        //     // if(marker.getPosition()) {
        //     //   console.log("hit", marker);
        //     //   cluster.addMarker(marker)
        //     // }
        //   })
        // }
        // cluster.addMarkers(listAll)
        // this.markerCluster.addLayers(listAll);
        // this.markerCluster.refreshClusters(listAll);
    };
    GoogleMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {
        if (item === void 0) { item = null; }
        if (force === void 0) { force = false; }
        bounds = bounds || new google.maps.LatLngBounds();
        if (force || (item && item.getMap() && item.getPosition)) {
            var p = item.getPosition();
            var l = { lat: p.lat(), lng: p.lng() };
            bounds.extend(l);
        }
        if (item && item.getMap() && item.getCenter) {
            bounds.extend(item.getCenter());
        }
        return bounds;
    };
    GoogleMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline$$1, bounds) {
        if (polyline$$1 === void 0) { polyline$$1 = null; }
        if (bounds === void 0) { bounds = new google.maps.LatLngBounds(); }
        if (polyline$$1 && polyline$$1.getMap()) {
            each(polyline$$1.getPath().getArray(), function (p) {
                var l = { lat: p.lat(), lng: p.lng() };
                bounds.extend(l);
            });
        }
        return bounds;
    };
    
    GoogleMapUtilsClass.prototype.setEncodedPath = function (polyline$$1, encodedPolyline) {
        var path = google.maps.geometry.encoding.decodePath(encodedPolyline);
        return polyline$$1.setPath(path);
    };
    
    GoogleMapUtilsClass.prototype.getPopup = function (options) {
        var defaultOption = {
            disableAutoPan: true,
            pixelOffset: new google.maps.Size(0, -37)
        };
        options = __assign$1({}, defaultOption, options);
        return new google.maps.InfoWindow(options);
    };
    GoogleMapUtilsClass.prototype.getPolyline = function () {
        return new google.maps.Polyline();
    };
    GoogleMapUtilsClass.prototype.setBounds = function (map$$1, bounds, padding) {
        if (padding === void 0) { padding = 0; }
        var newBounds = new google.maps.LatLngBounds(bounds.getSouthWest(), bounds.getNorthEast());
        map$$1.fitBounds(newBounds);
    };
    GoogleMapUtilsClass.prototype.isValidBounds = function (bounds) {
        // console.log(bounds);
        // return !bounds.isEmpty()
        return !this.getBoundsFix(bounds).isEmpty();
    };
    GoogleMapUtilsClass.prototype.getBoundsFix = function (bounds) {
        return new google.maps.LatLngBounds(bounds.getSouthWest(), bounds.getNorthEast());
    };
    GoogleMapUtilsClass.prototype.invalidateSize = function (map$$1) {
        google.maps.event.trigger(map$$1, "resize");
    };
    GoogleMapUtilsClass.prototype.onEvent$ = function (item, type) {
        return fromEventPattern$1(this.mapEventHandler(item, type), this.removeHandler(item, type));
    };
    GoogleMapUtilsClass.prototype.mapEventHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.onEvent(item, type, handler); };
    };
    GoogleMapUtilsClass.prototype.removeHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.removeEvent(item, type, handler); };
    };
    GoogleMapUtilsClass.prototype.onEvent = function (item, event, cb) {
        if (event == 'move')
            event = 'bounds_changed';
        item.addListener(event, function (e) {
            cb(e);
        });
    };
    GoogleMapUtilsClass.prototype.removeEvent = function (item, event, cb) {
        if (event == 'move')
            event = 'bounds_changed';
        item.removeListener(event, function (e) {
            cb(e);
        });
    };
    GoogleMapUtilsClass.prototype.openPopupPosition = function (position, map$$1, content, popup$$1) {
        popup$$1.setContent(content);
        popup$$1.setPosition(this.getLatlng(position));
        popup$$1.setMap(map$$1);
    };
    GoogleMapUtilsClass.prototype.setDivContent = function (marker$$1, content, options) {
        var currentContent = marker$$1.getContent ? marker$$1.getContent() : null;
        if (currentContent != content) {
            marker$$1.setContent(content);
            this.setDivMarkerStyle(marker$$1, options);
        }
    };
    GoogleMapUtilsClass.prototype.getDivMarker = function () {
        return new RichMarker({});
    };
    GoogleMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {
        if (options === void 0) { options = {}; }
        var zIndex = options.zIndex, flat = options.flat, anchor = options.anchor;
        if (zIndex)
            item.setZIndex(zIndex);
        if (flat)
            item.setFlat(flat);
        if (anchor)
            item.setAnchor(anchor);
    };
    GoogleMapUtilsClass.prototype.getHeatmap = function (options) {
        if (options === void 0) { options = {}; }
        var heatmap = new google.maps.visualization.HeatmapLayer(__assign$1({ data: [] }, options));
        return heatmap;
    };
    GoogleMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {
        var _this = this;
        var latlngsPos = latlngs.map(function (pos) { return _this.getLatlng(pos); });
        heatmap.setData(latlngsPos);
    };
    GoogleMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline$$1, positionTimeArray) {
        var _this = this;
        var path = map$1(positionTimeArray, function (point) {
            return _this.getLatlng({ lat: +point[0], lng: +point[1] });
        });
        return polyline$$1.setPath(path);
    };
    
    GoogleMapUtilsClass.prototype.setPath = function (polyline$$1, path) {
        var _this = this;
        var newPath = path.map(function (pos) {
            return _this.getLatlng(pos);
        });
        polyline$$1.setPath(newPath);
    };
    
    GoogleMapUtilsClass.prototype.getLatlng = function (_a) {
        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;
        return new google.maps.LatLng(lat, lng);
    };
    
    GoogleMapUtilsClass.prototype.getItemPosition = function (item) {
        var position = item.getPosition();
        return position ? { lat: position.lat(), lng: position.lng() } : null;
    };
    GoogleMapUtilsClass.prototype.getElement = function (item) {
        return item ? item.markerWrapper_ : null;
    };
    return GoogleMapUtilsClass;
}());

var defaultOptions = function (options) {
    if (typeof options === 'number') {
        // Legacy
        options = {
            precision: options
        };
    }
    else {
        options = options || {};
    }
    options.precision = options.precision || 5;
    options.factor = options.factor || Math.pow(10, options.precision);
    options.dimension = options.dimension || 2;
    return options;
};
var PolylineUtil = {
    encode: function (points, options) {
        options = defaultOptions(options);
        var flatPoints = [];
        for (var i = 0, len = points.length; i < len; ++i) {
            var point = points[i];
            if (options.dimension === 2) {
                flatPoints.push(point.lat || point[0]);
                flatPoints.push(point.lng || point[1]);
            }
            else {
                for (var dim = 0; dim < options.dimension; ++dim) {
                    flatPoints.push(point[dim]);
                }
            }
        }
        return this.encodeDeltas(flatPoints, options);
    },
    decode: function (encoded, options) {
        options = defaultOptions(options);
        var flatPoints = this.decodeDeltas(encoded, options);
        var points = [];
        for (var i = 0, len = flatPoints.length; i + (options.dimension - 1) < len;) {
            var point = [];
            for (var dim = 0; dim < options.dimension; ++dim) {
                point.push(flatPoints[i++]);
            }
            points.push(point);
        }
        return points;
    },
    encodeDeltas: function (numbers, options) {
        options = defaultOptions(options);
        var lastNumbers = [];
        for (var i = 0, len = numbers.length; i < len;) {
            for (var d = 0; d < options.dimension; ++d, ++i) {
                var num = numbers[i];
                var delta = num - (lastNumbers[d] || 0);
                lastNumbers[d] = num;
                numbers[i] = delta;
            }
        }
        return this.encodeFloats(numbers, options);
    },
    decodeDeltas: function (encoded, options) {
        options = defaultOptions(options);
        var lastNumbers = [];
        var numbers = this.decodeFloats(encoded, options);
        for (var i = 0, len = numbers.length; i < len;) {
            for (var d = 0; d < options.dimension; ++d, ++i) {
                numbers[i] = Math.round((lastNumbers[d] = numbers[i] + (lastNumbers[d] || 0)) * options.factor) / options.factor;
            }
        }
        return numbers;
    },
    encodeFloats: function (numbers, options) {
        options = defaultOptions(options);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            numbers[i] = Math.round(numbers[i] * options.factor);
        }
        return this.encodeSignedIntegers(numbers);
    },
    decodeFloats: function (encoded, options) {
        options = defaultOptions(options);
        var numbers = this.decodeSignedIntegers(encoded);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            numbers[i] /= options.factor;
        }
        return numbers;
    },
    encodeSignedIntegers: function (numbers) {
        for (var i = 0, len = numbers.length; i < len; ++i) {
            var num = numbers[i];
            numbers[i] = (num < 0) ? ~(num << 1) : (num << 1);
        }
        return this.encodeUnsignedIntegers(numbers);
    },
    decodeSignedIntegers: function (encoded) {
        var numbers = this.decodeUnsignedIntegers(encoded);
        for (var i = 0, len = numbers.length; i < len; ++i) {
            var num = numbers[i];
            numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);
        }
        return numbers;
    },
    encodeUnsignedIntegers: function (numbers) {
        var encoded = '';
        for (var i = 0, len = numbers.length; i < len; ++i) {
            encoded += this.encodeUnsignedInteger(numbers[i]);
        }
        return encoded;
    },
    decodeUnsignedIntegers: function (encoded) {
        var numbers = [];
        var current = 0;
        var shift = 0;
        for (var i = 0, len = encoded.length; i < len; ++i) {
            var b = encoded.charCodeAt(i) - 63;
            current |= (b & 0x1f) << shift;
            if (b < 0x20) {
                numbers.push(current);
                current = 0;
                shift = 0;
            }
            else {
                shift += 5;
            }
        }
        return numbers;
    },
    encodeSignedInteger: function (num) {
        num = (num < 0) ? ~(num << 1) : (num << 1);
        return this.encodeUnsignedInteger(num);
    },
    // This function is very similar to Google's, but I added
    // some stuff to deal with the double slash issue.
    encodeUnsignedInteger: function (num) {
        var value, encoded = '';
        while (num >= 0x20) {
            value = (0x20 | (num & 0x1f)) + 63;
            encoded += (String.fromCharCode(value));
            num >>= 5;
        }
        value = num + 63;
        encoded += (String.fromCharCode(value));
        return encoded;
    }
};

var markerCluster = function () {
    // console.log(L.MarkerClusterGroup);
    return markerClusterGroup();
};

var leafletHeat = function (latlng, options) {
    if (options === void 0) { options = {}; }
    // console.log(L.MarkerClusterGroup);
    return heatLayer(latlng, options);
};

var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var LeafletMapUtilsClass = (function () {
    function LeafletMapUtilsClass() {
        this.type = 'leaflet';
        this.defaultMapOptions = {
            center: [3.505, 0],
            zoom: 2,
            tileLayerUrl: "http://{s}.tile.osm.org/{z}/{x}/{y}.png",
            tileLayerOptions: {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }
        };
    }
    LeafletMapUtilsClass.prototype.setDefaultMapOptions = function (options) {
        this.defaultMapOptions = __assign$2({}, this.defaultMapOptions, options);
    };
    LeafletMapUtilsClass.prototype.renderMap = function (elem, options) {
        options = __assign$2({}, options, this.defaultMapOptions);
        var newmap = map$2(elem, options);
        if (options.tileLayerUrl) {
            tileLayer(options.tileLayerUrl, options.tileLayerOptions || {}).addTo(newmap);
        }
        return newmap;
    };
    LeafletMapUtilsClass.prototype.setMap = function (item, map$$1) {
        if (((item && !item.getElement) || (item && !item.getElement())) && map$$1.getContainer().offsetWidth) {
            item.addTo(map$$1);
        }
    };
    
    LeafletMapUtilsClass.prototype.setKey = function (key) {
        return true;
    };
    LeafletMapUtilsClass.prototype.setStyle = function (item, style) {
        if (item.setStyle)
            item.setStyle(style);
    };
    
    LeafletMapUtilsClass.prototype.setCircleStyle = function (item, style) {
        this.setStyle(item, style);
    };
    
    LeafletMapUtilsClass.prototype.setPolylineStyle = function (polyline$$1, style) {
        polyline$$1.setStyle(style);
    };
    
    LeafletMapUtilsClass.prototype.clearItem = function (item) {
        item.remove();
        item.off();
    };
    
    LeafletMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {
        if (item === void 0) { item = null; }
        if (bounds === void 0) { bounds = latLngBounds([]); }
        if (force === void 0) { force = false; }
        if (force || (item && !item.getElement) || (item && item.getElement()))
            bounds.extend(item.getLatLng());
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBounds = function (position, bounds) {
        if (bounds === void 0) { bounds = latLngBounds([]); }
        var latlng = this.getLatlng(position);
        bounds.extend(latlng);
        return bounds;
    };
    LeafletMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline$$1, bounds) {
        if (polyline$$1 === void 0) { polyline$$1 = null; }
        if (bounds === void 0) { bounds = latLngBounds([]); }
        if (polyline$$1 && polyline$$1.getElement()) {
            bounds.extend(polyline$$1.getBounds());
        }
        return bounds;
    };
    
    LeafletMapUtilsClass.prototype.getLatlng = function (_a) {
        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;
        return latLng(lat, lng);
    };
    
    LeafletMapUtilsClass.prototype.updatePosition = function (marker$$1, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        var latLng$$1 = this.getLatlng(position);
        marker$$1.setLatLng(latLng$$1);
        if (infoContent)
            this.updateTooltip(marker$$1, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.updateTooltip = function (marker$$1, infoContent, defaultOption) {
        if (marker$$1.getTooltip()) {
            marker$$1.setTooltipContent(infoContent);
        }
        else {
            marker$$1.bindTooltip(infoContent, defaultOption);
        }
    };
    LeafletMapUtilsClass.prototype.openTooltip = function (item, content) {
        if (content)
            item.setTooltipContent(content);
        item.openTooltip();
    };
    LeafletMapUtilsClass.prototype.closeTooltip = function (item) {
        item.closeTooltip();
    };
    LeafletMapUtilsClass.prototype.openPopup = function (item, map$$1, content) {
        if (content)
            item.setPopupContent(content);
        item.openPopup();
    };
    LeafletMapUtilsClass.prototype.closePopup = function (item) {
        item.closePopup();
    };
    LeafletMapUtilsClass.prototype.bringToFront = function (item) {
        item.bringToFront();
    };
    LeafletMapUtilsClass.prototype.setFocus = function (item, map$$1, config) {
        if ((item && item.getElement()) || config.force) {
            var markerCenter = this.getItemLatlng(item);
            if (config.center)
                map$$1.panTo(markerCenter, { animate: true, duration: 1 });
            if (config.zoom && config.center)
                map$$1.setView(markerCenter, config.zoom);
        }
    };
    LeafletMapUtilsClass.prototype.getItemLatlng = function (item) {
        return item.getLatLng();
    };
    LeafletMapUtilsClass.prototype.updateCirclePosition = function (circle, position, infoContent, defaultOption) {
        if (infoContent === void 0) { infoContent = ""; }
        if (defaultOption === void 0) { defaultOption = {}; }
        this.updatePosition(circle, position, infoContent, defaultOption);
    };
    LeafletMapUtilsClass.prototype.getCircleMarker = function () {
        return circleMarker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarker = function () {
        return marker([0, 0]);
    };
    LeafletMapUtilsClass.prototype.getMarkerCluster = function (map$$1) {
        var cluster = markerCluster();
        map$$1.addLayer(cluster);
        return cluster;
    };
    LeafletMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {
        cluster.clearLayers();
    };
    LeafletMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker$$1) {
        cluster.removeLayer(marker$$1);
    };
    LeafletMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers) {
        var marker$$1 = markers[0];
        cluster.addLayers(markers);
        cluster.refreshClusters(markers);
    };
    LeafletMapUtilsClass.prototype.getPolyline = function () {
        return polyline([]);
    };
    LeafletMapUtilsClass.prototype.setBounds = function (map$$1, bounds, options) {
        if (map$$1 && map$$1.getContainer() && map$$1.getContainer().offsetWidth) {
            if (options.toFly) {
                map$$1.flyToBounds(bounds, options);
            }
            else {
                map$$1.fitBounds(bounds, options);
            }
        }
    };
    LeafletMapUtilsClass.prototype.isValidBounds = function (bounds) {
        return bounds.isValid();
    };
    LeafletMapUtilsClass.prototype.invalidateSize = function (map$$1) {
        if (map$$1 && map$$1.getContainer().offsetWidth) {
            map$$1.invalidateSize();
        }
    };
    LeafletMapUtilsClass.prototype.getPopup = function (options) {
        return popup(options);
    };
    LeafletMapUtilsClass.prototype.onEvent$ = function (item, type) {
        return fromEventPattern$1(this.mapEventHandler(item, type), this.removeHandler(item, type));
    };
    LeafletMapUtilsClass.prototype.mapEventHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.onEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.removeHandler = function (item, type) {
        var _this = this;
        return function (handler) { return _this.removeEvent(item, type, handler); };
    };
    LeafletMapUtilsClass.prototype.onEvent = function (item, event, cb) {
        item.on(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.removeEvent = function (item, event, cb) {
        item.off(event, function (e) {
            cb(e);
        });
    };
    LeafletMapUtilsClass.prototype.openPopupPosition = function (position, map$$1, content, popup$$1) {
        popup$$1
            .setLatLng(position)
            .setContent(content)
            .openOn(map$$1);
    };
    LeafletMapUtilsClass.prototype.setDivContent = function (marker$$1, content, options) {
        if (options === void 0) { options = {}; }
        var currentContent = marker$$1.options.icon ? marker$$1.options.icon.options.html : "";
        if (content != currentContent) {
            this.setDivMarkerStyle(marker$$1, __assign$2({ html: content }, options));
            options['zIndexOffset'] && marker$$1.setZIndexOffset(options['zIndexOffset']);
        }
        // console.error('set div content not implemented')
    };
    LeafletMapUtilsClass.prototype.getDivMarker = function () {
        return this.getMarker();
    };
    LeafletMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {
        if (options === void 0) { options = {}; }
        var icon = divIcon(options);
        this.setIcons(item, icon);
    };
    LeafletMapUtilsClass.prototype.setIcons = function (marker$$1, icon) {
        marker$$1.setIcon(icon);
    };
    LeafletMapUtilsClass.prototype.getHeatmap = function (options) {
        if (options === void 0) { options = {}; }
        return leafletHeat([], options);
    };
    LeafletMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {
        var latlngArray = latlngs.map(function (pos) { return ([pos.lat, pos.lng, pos.weight || 1]); });
        heatmap.setLatLngs(latlngArray);
    };
    LeafletMapUtilsClass.prototype.setEncodedPath = function (polyline$$1, encodedPolyline) {
        var path = PolylineUtil.decode(encodedPolyline);
        return polyline$$1.setLatLngs(path);
    };
    
    LeafletMapUtilsClass.prototype.setPath = function (polyline$$1, path) {
        var _this = this;
        path = path.map(function (pos) {
            return _this.getLatlng(pos);
        });
        polyline$$1.setLatLngs(path);
    };
    
    LeafletMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline$$1, positionTimeArray) {
        return polyline$$1.setLatLngs(positionTimeArray);
    };
    
    LeafletMapUtilsClass.prototype.getItemPosition = function (item) {
        var position = item.getLatLng();
        return position ? { lat: position.lat, lng: position.lng } : null;
    };
    LeafletMapUtilsClass.prototype.getElement = function (item) {
        return item ? item.getElement() : null;
    };
    return LeafletMapUtilsClass;
}());

var mapTypeService = (function () {
    var instance;
    var currentmapType;
    function getMapType(mapType) {
        switch (mapType) {
            case 'leaflet': {
                return new LeafletMapUtilsClass();
            }
            case 'google': {
                return new GoogleMapUtilsClass();
            }
            default: {
                return new GoogleMapUtilsClass();
            }
        }
    }
    return {
        getInstance: function (mapType) {
            if (!instance || !currentmapType) {
                currentmapType = mapType;
                instance = getMapType(mapType);
            }
            return instance;
        }
    };
})();

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var MapInstance = (function () {
    function MapInstance() {
        var _this = this;
        // mapUtils: MapUtils = null;
        this.map = null;
        this.map$ = new ReplaySubject$1();
        this.clusters = [];
        this.poppers = [];
        this.itemsSet = [];
        // mapType: HtMapType;
        this.leafletSetBoundsOptions = {
            animate: true,
            duration: 0.3
        };
        this.googleSetBoundsOptions = {};
        this.map$.subscribe(function (map$$1) {
            _this.map = map$$1;
        });
    }
    Object.defineProperty(MapInstance.prototype, "mapUtils", {
        get: function () {
            return mapTypeService.getInstance();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapInstance.prototype, "mapType", {
        get: function () {
            return mapTypeService.getInstance().mapType;
        },
        enumerable: true,
        configurable: true
    });
    MapInstance.prototype.addToItemsSet = function (item) {
        var i = this.itemsSet.indexOf(item);
        if (i == -1)
            this.itemsSet.push(item);
    };
    MapInstance.prototype.renderMap = function (elem, options) {
        if (options === void 0) { options = {}; }
        var map$$1 = this.mapUtils.renderMap(elem, options);
        this.setMap(map$$1);
        return map$$1;
    };
    MapInstance.prototype.setMap = function (map$$1) {
        this.map$.next(map$$1);
    };
    MapInstance.prototype.inValidateSize = function () {
        this.mapUtils.invalidateSize(this.map);
    };
    // getMap() {
    //   this.map$.take(1).subscribe(map => {
    //     return map;
    //   });
    // }
    MapInstance.prototype.setMapType = function (mapType, key) {
        mapTypeService.getInstance(mapType);
        if (key)
            this.mapUtils.setKey(key);
    };
    
    MapInstance.prototype.addCluster = function (cluster) {
        var _this = this;
        if (!this.clusters.includes(cluster)) {
            this.clusters.push(cluster);
            this.map$.pipe(filter(function (data) { return !!data; }))
                .subscribe(function (map$$1) {
                cluster.cluster = _this.mapUtils.getMarkerCluster(map$$1);
            });
        }
    };
    MapInstance.prototype.addPopper = function (popper) {
        if (!this.poppers.includes(popper)) {
            this.poppers.push(popper);
        }
        
        if (!this.moveEvent) {
            this.listenMove();
        }
    };
    
    MapInstance.prototype.removePopper = function (popper) {
        var i = this.poppers.indexOf(popper);
        if (i > -1) {
            this.poppers.splice(i, 1);
        }
    };
    MapInstance.prototype.listenMove = function () {
        var _this = this;
        this.map$.pipe(filter(function (data) { return !!data; }), take(1)).subscribe(function (map$$1) {
            _this.moveEvent = _this.mapUtils.onEvent(map$$1, 'move', function (e) {
                _this.poppers.forEach(function (p) {
                    p.scheduleUpdate();
                });
            });
        });
    };
    MapInstance.prototype.getBounds = function (bounds, item) {
        return item.extendBounds ? item.extendBounds(bounds) : null;
    };
    MapInstance.prototype.getItemsSetBounds = function (items) {
        var _this = this;
        var bounds = this.mapUtils.extendItemBounds();
        return items.reduce(function (bounds, item) {
            return _this.getBounds(bounds, item) || bounds;
        }, bounds);
    };
    MapInstance.prototype.resetBounds = function (options) {
        var _this = this;
        if (this.resetBoundsTimeout)
            clearTimeout(this.resetBoundsTimeout);
        this.resetBoundsTimeout = setTimeout(function () {
            var items = _this.itemsSet;
            var bounds = _this.getItemsSetBounds(items);
            if (bounds && _this.mapUtils.isValidBounds(bounds))
                _this.setBounds(bounds, options);
        }, 40);
    };
    MapInstance.prototype.setBounds = function (bounds, options) {
        var map$$1 = this.map;
        if (!map$$1)
            return false;
        var mapOptions = (this.mapType == "leaflet"
            ? this.leafletSetBoundsOptions
            : this.googleSetBoundsOptions);
        options =
            options || this.setBoundsOptions || mapOptions;
        this.mapUtils.setBounds(map$$1 || this.map, bounds, __assign({}, mapOptions, options));
    };
    MapInstance.prototype.onEvent$ = function (type) {
        return this.mapUtils.onEvent$(this.map, type);
    };
    MapInstance.prototype.mapEventHandler = function (type) {
        var _this = this;
        return function (handler) { return _this.mapUtils.onEvent(_this.map, type, handler); };
    };
    MapInstance.prototype.removeHandler = function (type) {
        var _this = this;
        return function (handler) { return _this.mapUtils.removeEvent(_this.map, type, handler); };
    };
    return MapInstance;
}());

var segmentPolylineStyles = {
    get: function (type) {
        switch (type) {
            case "google":
                {
                    return {
                        default: {
                            strokeColor: Color.blue,
                            strokeOpacity: 1,
                            strokeWeight: 5
                        },
                        highlight: {
                            strokeColor: Color.blue,
                            strokeOpacity: 1,
                            strokeWeight: 5
                        },
                        fade: {
                            strokeColor: Color.grey5,
                            strokeOpacity: 0.2,
                            strokeWeight: 2
                        }
                    };
                }
                ;
            case "leaflet": {
                return {
                    default: {
                        weight: 5,
                        color: Color.blue,
                        opacity: 1
                    },
                    highlight: {
                        weight: 5,
                        color: Color.blue,
                        opacity: 1
                    },
                    fade: {
                        weight: 2,
                        color: Color.grey2,
                        opacity: 0.2
                    }
                };
            }
        }
    },
};

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function ExtendBoundsMixin(Base) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.entities = {};
            _this.toIncludeInBounds = true;
            return _this;
        }
        class_1.prototype.extendBounds = function (bounds) {
            var _this = this;
            if (!this.toIncludeInBounds)
                return bounds;
            var mapUtils = this.mapInstance.mapUtils;
            bounds = bounds || mapUtils.extendItemBounds();
            var newBounds = reduce(this.entities, function (bounds, entity) {
                return _this.getBounds(entity.item, bounds);
            }, bounds);
            return newBounds;
        };
        return class_1;
    }(Base));
}

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function MarkersMixin(Base) {
    return (function (_super) {
        __extends$1(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.entities = {};
            _this.event = new HtCustomEvent();
            return _this;
        }
        class_1.prototype.htShow = function (item) {
            return "display: " + (item ? "flex" : "none");
        };
        class_1.prototype.getItem = function (data) {
            return this.mapInstance.mapUtils.getMarker();
        };
        class_1.prototype.getBounds = function (item, bounds) {
            return this.mapInstance.mapUtils.extendItemBounds(item, bounds, this.forceExtendBounds);
        };
        class_1.prototype.update = function (_a, positionBearing) {
            var item = _a.item, data = _a.data;
            var pathPosition = positionBearing && positionBearing.path.length ?
                positionBearing.path[positionBearing.path.length - 1] : null;
            var position = pathPosition || this.getPosition(data);
            if (position)
                this.mapInstance.mapUtils.updatePosition(item, position);
            if (!this.toNotSetMap)
                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);
            var id = this.trackBy(data);
            this.event.next('update-' + id, { item: item, data: data });
        };
        /**
         *
         * @param id string return trackBy
         * @returns {{subscribe: (cb) => IEventSub}}
         */
        class_1.prototype.onEntityUpdate = function (id) {
            var _this = this;
            var eventName = "update-" + id;
            return {
                subscribe: function (cb) {
                    return _this.event.subscribe(eventName, cb);
                }
            };
        };
        class_1.prototype.removeItem = function (item) {
            this.mapInstance.mapUtils.clearItem(item);
        };
        class_1.prototype.removeAll = function (entities) {
            var _this = this;
            each(entities, function (entity) {
                _this.removeItem(entity.item);
            });
            this.entities = {};
        };
        class_1.prototype.clear = function () {
            var entities = this.entities;
            this.removeAll(entities);
        };
        class_1.prototype.clearItem = function (_a) {
            var item = _a.item, data = _a.data;
            this.removeData(data);
            this.removeItem(item);
        };
        class_1.prototype.removeData = function (data) {
            var id = this.trackBy(data);
            if (this.entities[id])
                delete this.entities[id];
        };
        return class_1;
    }(Base));
}

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$3 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
function StyleMixin(Base) {
    return (function (_super) {
        __extends$2(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.defaultstyleFunct = {
                get: function (type) {
                    return {
                        default: {}
                    };
                }
            };
            _this.highlightedId = null;
            return _this;
        }
        class_1.prototype.getStyle = function (selectedStyleType, fallbackStyle) {
            if (selectedStyleType === void 0) { selectedStyleType = "default"; }
            var mapType = this.mapInstance.mapUtils.type;
            var styleFunct = this.styleFunct || this.defaultstyleFunct;
            var mapTypetype = this.styleObj || styleFunct.get(mapType);
            // console.log(this.name, "style", selectedStyleType, styleFunct, this.styleFunct);
            // const styleType = mapTypetype[selectedStyleType] ? selectedStyleType : this.styleType;
            var style = mapTypetype[selectedStyleType] || fallbackStyle;
            if (!style)
                console.error("style type does not exist ", this.name, selectedStyleType);
            if (this.isAnimated && style)
                style = __assign$3({}, style, { className: style['className'] ? style['className'] + " animated-marker" : 'animated-marker' });
            return style;
        };
        class_1.prototype.setStyleType = function (styleType) {
            if (styleType === void 0) { styleType = 'default'; }
            this.styleType = styleType;
        };
        class_1.prototype.setStyle = function (_a) {
            var item = _a.item, data = _a.data;
            var styleType = this.getStyleType(data);
            var style = this.getStyle(styleType);
            this.setItemStyle(item, style);
        };
        class_1.prototype.getStyleType = function (datum) {
            if (this.highlightedId && datum) {
                return this.highlightedId == this.trackBy(datum) ? 'highlight' : 'fade';
            }
            else {
                return this.styleType;
            }
        };
        class_1.prototype.setItemStyle = function (item, style) {
            this.mapInstance.mapUtils.setStyle(item, style);
        };
        return class_1;
    }(Base));
}
// export class Styles {
//   styleFunct: StyleFunct = {
//     google: {
//       default: {
//
//       }
//     },
//     leaflet: {
//       default: {
//
//       }
//     }
//   };
//
//   styleType = 'default';
//
//   getStyle(selectedStyleType: string = 'default', fallbackStyle?) {
//     const mapType = GlobalMap.mapUtils.type;
//     const mapTypetype = this.styleFunct[mapType];
//     const styleType = selectedStyleType && mapTypetype[selectedStyleType] ? selectedStyleType : this.styleType;
//     const style = mapTypetype[styleType] || fallbackStyle;
//     if(!style) console.error("style type does not exist");
//     return this.styleFunct[mapType][styleType]
//   }
// }

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

function TraceMixin(Base) {
    return (function (_super) {
        __extends$3(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // setMap: (item, map) => void;
        class_1.prototype.trace = function (data, map$$1) {
            var _this = this;
            map$$1 = map$$1 || this.mapInstance.map;
            var mapUtils = this.mapInstance.mapUtils;
            if (!map$$1) {
                console.warn("Map is not initialized");
                return false;
            }
            if (data && data.length) {
                // if(this.cluster) this.clearAllClusters(data);
                data.forEach(function (datum) {
                    var id = _this.trackBy(datum);
                    var entity = _this.entities[id];
                    var hasEntity = !!entity;
                    var item = !hasEntity ? _this.getItem(datum) : entity.item;
                    entity = { data: datum, item: item, isOld: false };
                    _this.entities[id] = entity;
                    if (!hasEntity) {
                        _this.addEvents(item, id);
                    }
                    if (item)
                        _this.setStyle(entity);
                    if (!_this.toNotTraceItem)
                        _this.traceItem(datum);
                    // if (!this.toNotSetMap) mapUtils.setMap(item, map);
                });
                if (this.traceEffect)
                    this.traceEffect();
            }
            else {
                // console.log("remove all", this);
                this.removeAll(this.entities);
            }
            this.bustOldItem();
        };
        
        class_1.prototype.traceItem = function (datum) {
            var id = this.trackBy(datum);
            var entity = this.entities[id];
            if (entity) {
                this.update(entity);
            }
        };
        
        class_1.prototype.addEvents = function (item, id) {
            var _this = this;
            var mapUtils = this.mapInstance.mapUtils;
            mapUtils.onEvent(item, "click", function () {
                var entity = _this.entities[id];
                if (_this.onMouseLeave)
                    _this.onMouseLeave(entity);
                if (_this.onClick)
                    _this.onClick(entity);
            });
            mapUtils.onEvent(item, "mouseover", function () {
                var entity = _this.entities[id];
                if (_this.onMouseEnter)
                    _this.onMouseEnter(entity);
            });
            mapUtils.onEvent(item, "mouseout", function () {
                var entity = _this.entities[id];
                if (_this.onMouseLeave)
                    _this.onMouseLeave(entity);
            });
        };
        class_1.prototype.bustOldItem = function () {
            var _this = this;
            var keys = Object.keys(this.entities);
            keys.forEach(function (key) {
                var entity = _this.entities[key];
                if (entity.isOld) {
                    _this.clearItem(entity);
                    delete _this.entities[key];
                }
                else {
                    _this.entities[key].isOld = true;
                }
            });
        };
        return class_1;
    }(Base));
}

var positionTime = {
    positionTimePoints: [],
    decode: function (encodedPolyline) {
        this.positionTimePoints = new TimeAwareEncoder().decodeTimeAwarePolyline(encodedPolyline);
        return this.positionTimePoints;
    }
};

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function PolylinesMixin(Base) {
    return (function (_super) {
        __extends$4(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.positionTimeArray = [];
            return _this;
        }
        class_1.prototype.getItem = function (data) {
            return this.mapInstance.mapUtils.getPolyline();
        };
        class_1.prototype.getBounds = function (item, bounds) {
            return this.mapInstance.mapUtils.extendBoundsWithPolyline(item, bounds);
        };
        class_1.prototype.update = function (_a, pathBearing) {
            var item = _a.item, data = _a.data;
            if (this.getPath || pathBearing) {
                var path = pathBearing ? pathBearing.path : this.getPath(data);
                this.mapInstance.mapUtils.setPath(item, path);
            }
            else if (this.getEncodedPositionTime) {
                this.positionTimeArray = positionTime.decode(this.getEncodedPositionTime(data));
                this.mapInstance.mapUtils.setPathPositionTimeArray(item, this.positionTimeArray);
            }
            else {
                this.mapInstance.mapUtils.setEncodedPath(item, this.getEncodedPath(data));
            }
            if (!this.toNotSetMap)
                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);
        };
        class_1.prototype.setItemStyle = function (item, style) {
            this.mapInstance.mapUtils.setPolylineStyle(item, style);
        };
        return class_1;
    }(Base));
}

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function MapItemsMixin(Base) {
    return (function (_super) {
        __extends$5(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.entities = {};
            return _this;
        }
        class_1.prototype.getEntity = function (id) {
            if (!this.entities)
                return null;
            if (id)
                return this.entities[id];
            var keys = Object.keys(this.entities);
            if (keys.length == 0)
                return null;
            var key = keys[0];
            return this.entities[key];
        };
        
        class_1.prototype.trackBy = function (datum) {
            return _super.prototype.trackBy ? _super.prototype.trackBy.call(this, datum) : datum.id;
        };
        class_1.prototype.trackAnimationBy = function (datum) {
            return _super.prototype.trackAnimationBy ? _super.prototype.trackAnimationBy.call(this, datum) : this.trackBy(datum);
        };
        return class_1;
    }(Base));
}

var SegmentPolylines = (function () {
    function SegmentPolylines(mapInstance) {
        this.mapInstance = mapInstance;
        this.styleFunct = segmentPolylineStyles;
        this.name = "segment polyline";
    }
    SegmentPolylines.prototype.getEncodedPath = function (data) {
        return data.encoded_polyline;
    };
    
    SegmentPolylines.prototype.getEncodedPositionTime = function (data) {
        return data.time_aware_polyline;
    };
    SegmentPolylines.prototype.getPosition = function () {
        return { lat: 0, lng: 0 };
    };
    return SegmentPolylines;
}());
var SegmentPolylinesTrace = TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(SegmentPolylines))))));
// export class SegmentPolylines {
//   styleFunct = segmentPolylineStyles;
//
//   getEncodedPath(data) {
//     return data.encoded_polyline;
//   };
//
//   getEncodedPositionTime(data: ISegment) {
//     return data.time_aware_polyline
//   }
// }
//
// export const SegmentPolylinesTrace = mapItemsFactory(SegmentPolylines, {
//   isPolyline: true,
//   hasDataObservable: false
// });
// export const SegmentPolylinesTrace = _.compose(
//   PolylinesMixin,
//   MarkersMixin,
//   StyleMixin,
//   TraceMixin,
// )(SegmentPolylines);

var stopStyles = {
    get: function (type) {
        switch (type) {
            case 'google':
                {
                    return {
                        default: {
                            icon: {
                                fillColor: Color.stop,
                                fillOpacity: 1,
                                strokeColor: Color.stopDark,
                                strokeOpacity: 1,
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                strokeWeight: 2
                            }
                        },
                        popup: {
                            disableAutoPan: true,
                            pixelOffset: new google.maps.Size(0, -10)
                        },
                        highlight: {
                            icon: {
                                fillColor: Color.stop,
                                fillOpacity: 1,
                                strokeColor: Color.stopDark,
                                strokeOpacity: 1,
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                strokeWeight: 2
                            }
                        },
                        fade: {
                            icon: {
                                fillColor: Color.stop,
                                fillOpacity: 0.1,
                                strokeColor: Color.stopDark,
                                strokeOpacity: 0.2,
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                strokeWeight: 2
                            }
                        },
                    };
                }
                ;
            case "leaflet": {
                return {
                    default: {
                        radius: 10,
                        fillColor: Color.stop,
                        fillOpacity: 1,
                        weight: 2,
                        color: Color.stopDark,
                        pane: "markerPane"
                    },
                    popup: {
                        offset: [0, -5],
                        // offset: point(0, -5),
                        closeButton: false
                    },
                    highlight: {
                        radius: 10,
                        fillColor: Color.stop,
                        fillOpacity: 1,
                        weight: 4,
                        color: Color.stopDark,
                        pane: "markerPane"
                    },
                    fade: {
                        radius: 10,
                        fillColor: Color.stop,
                        fillOpacity: 0.1,
                        weight: 2,
                        color: Color.stopDark,
                        pane: "markerPane"
                    }
                };
            }
        }
    }
};

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function SingleItemMixin(Base) {
    return (function (_super) {
        __extends$6(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.trace = function (user, map$$1) {
            var data = user ? [user] : [];
            _super.prototype.trace.call(this, data, map$$1);
        };
        return class_1;
    }(Base));
}

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function PopupMixin(Base) {
    return (function (_super) {
        __extends$7(class_1, _super);
        function class_1() {
            var arg = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arg[_i] = arguments[_i];
            }
            var _this = _super.apply(this, arg) || this;
            _this.defaultPopupStyle = {
                disableAutoPan: true,
            };
            _this.addPopup();
            return _this;
        }
        class_1.prototype.addPopup = function () {
            this.popup = this.mapInstance.mapUtils.getPopup(this.getStyle("popup", this.defaultPopupStyle));
        };
        class_1.prototype.setPopup = function (id) {
            if (id && this.entities[id]) {
                var data = this.entities[id].data;
                var popup$$1 = this.popup;
                var map$$1 = this.mapInstance.map;
                this.mapInstance.mapUtils.openPopupPosition(this.getPosition(data), map$$1, this.getInfoContent(data), popup$$1);
            }
            else {
                this.mapInstance.mapUtils.clearItem(this.popup);
            }
        };
        class_1.prototype.onMouseEnter = function (entity) {
            var id = this.trackBy(entity.data);
            this.setPopup(id);
        };
        class_1.prototype.onMouseLeave = function (entity) {
            this.popup && this.mapInstance.mapUtils.clearItem(this.popup);
        };
        return class_1;
    }(Base));
}
// export class PopupRenderer {
//   popup;
//   getStyle: (styleType?) => object;
//   entities: Entities<any>;
//   getPosition: (data) => HtPosition;
//   getInfoContent: (data) => string;
//   // setMap: (item, map) => void;
//   defaultPopupStyle =  {
//     disableAutoPan: true,
//     pixelOffset: new google.maps.Size(0, -35)
//   };
//
//   addPopup() {
//     this.popup = GlobalMap.mapUtils.getPopup(this.getStyle('popup'))
//   }
//
//   setPopup(id: string | null) {
//     if (id && this.entities[id]) {
//       let {data} = this.entities[id];
//       let popup = this.popup;
//       let map = GlobalMap.map;
//       GlobalMap.mapUtils.openPopupPosition(this.getPosition(data), map, this.getInfoContent(data), popup);
//     } else {
//       GlobalMap.mapUtils.setMap(this.popup, null)
//     }
//   };
//
//   onMouseEnter(entity: Entity<any>) {
//     let id = entity.data.id;
//     this.setPopup(id);
//
//   };
//
//   onMouseLeave(entity: Entity<any>) {
//     this.popup && GlobalMap.mapUtils.setMap(this.popup, null)
//   }
// }

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function DivMarkersMixin(Base) {
    return (function (_super) {
        __extends$8(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getItem = function (data) {
            return this.mapInstance.mapUtils.getDivMarker();
        };
        class_1.prototype.update = function (_a, pathBearing) {
            var item = _a.item, data = _a.data;
            var bearing = pathBearing ? pathBearing.bearing : null;
            var content = this.getDivContent(data, bearing);
            this.setContent({ item: item, content: content });
            _super.prototype.update.call(this, { item: item, data: data }, pathBearing);
        };
        class_1.prototype.setContent = function (_a) {
            var item = _a.item, content = _a.content;
            this.mapInstance.mapUtils.setDivContent(item, content, this.getStyle());
        };
        class_1.prototype.setStyle = function (entity) {
            // let style = this.getStyle();
            // GlobalMap.mapUtils.setDivMarkerStyle(item, style)
        };
        return class_1;
    }(Base));
}

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function CircleMixin(Base) {
    return (function (_super) {
        __extends$9(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getItem = function (data) {
            return this.mapInstance.mapUtils.getCircleMarker();
        };
        return class_1;
    }(Base));
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function isFunction(x) {
    return typeof x === 'function';
}
var isFunction_2 = isFunction;


var isFunction_1 = {
	isFunction: isFunction_2
};

var isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


var isArray = {
	isArray: isArray_1
};

function isObject(x) {
    return x != null && typeof x === 'object';
}
var isObject_2 = isObject;


var isObject_1 = {
	isObject: isObject_2
};

// typeof any so that it we don't have to cast when comparing a result to the error object
var errorObject_1 = { e: {} };


var errorObject = {
	errorObject: errorObject_1
};

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.errorObject.e = e;
        return errorObject.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
var tryCatch_2 = tryCatch;



var tryCatch_1 = {
	tryCatch: tryCatch_2
};

var __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends$13(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
var UnsubscriptionError_2 = UnsubscriptionError;


var UnsubscriptionError_1 = {
	UnsubscriptionError: UnsubscriptionError_2
};

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);
            }
        }
        if (isArray.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
var Subscription_2 = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}


var Subscription_1 = {
	Subscription: Subscription_2
};

var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};


var Observer = {
	empty: empty
};

// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
var _root = __window || __global || __self;
var root_1 = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();


var root = {
	root: root_1
};

var rxSubscriber = createCommonjsModule(function (module, exports) {
var Symbol = root.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

});

var rxSubscriber_1 = rxSubscriber.rxSubscriber;
var rxSubscriber_2 = rxSubscriber.$$rxSubscriber;

var __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends$12(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
var Subscriber_2 = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends$12(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));


var Subscriber_1 = {
	Subscriber: Subscriber_2
};

var __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var distinctUntilChanged_2 = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends$11(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject.errorObject) {
                return this.destination.error(errorObject.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

var __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter$2(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var filter_2 = filter$2;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends$14(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

var __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map$3(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var map_2 = map$3;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends$15(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

var __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var scan_2 = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends$16(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

var __extends$10 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// import { GlobalMap } from "../global/map-service";
function DataObservableMixin(Base) {
    return (function (_super) {
        __extends$10(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.mapInstance.addToItemsSet(_this);
            return _this;
        }
        class_1.prototype._procData$ = function () {
            var _this = this;
            return function (source$) {
                return source$.pipe(filter_2(function (data) { return !!data; }), map_2(function (pageData) {
                    var isNew = pageData && pageData.count && !pageData.previous;
                    var results = pageData ? pageData.results : [];
                    return _this.getMarkersArray(results, isNew);
                }));
            };
        };
        class_1.prototype.getMarkersArray = function (array, isNew) {
            var _this = this;
            if (isNew === void 0) { isNew = false; }
            return reduce(array, function (acc, item) {
                var isValid = _this.isValidMapItems
                    ? _this.isValidMapItems(item)
                    : !!_this.getPosition(item);
                if (isValid) {
                    acc.valid.push(item);
                }
                else {
                    acc.invalid.push(item);
                }
                return acc;
            }, { valid: [], invalid: [], isNew: isNew });
        };
        class_1.prototype.setPageData$ = function (data$, config) {
            if (config === void 0) { config = {}; }
            //todo take page data, add diff apis
            if (this.dataSub) {
                this.dataSub.unsubscribe();
            }
            var hide$ = config.hide$;
            this.dataPageSource$ = hide$
                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) {
                    return !!hide ? { results: [], count: 0, next: "", previous: "" } : data;
                })
                : data$;
            this.data$ = this.dataPageSource$.pipe(this._procData$());
            this._initDataObserver();
        };
        class_1.prototype.setData$ = function (data$, config) {
            var _this = this;
            if (config === void 0) { config = {}; }
            if (this.dataSub) {
                this.dataSub.unsubscribe();
            }
            
            var hide$ = config.hide$;
            this.dataArraySource$ = hide$
                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) { return (!!hide ? [] : data); })
                : data$;
            this.data$ = this.dataArraySource$.pipe(scan_2(function (acc, data) {
                return { new: data, old: acc.new };
            }, { old: null, new: null }), map_2(function (dataArray) {
                return _this.getMarkersArray(dataArray.new, !dataArray.old);
            }));
            this._initDataObserver();
        };
        // _initData$() {
        //   let userData$ = this.dataPageSource$.pipe(
        //     filter(data => !!GlobalMap.map),
        //     pluck('valid'),
        //     scan((acc: {user: any, oldUser: any}, data: object) => {
        //       const oldUser = acc.user;
        //       return {user: data, oldUser }
        //     }, {user: null, oldUser: null})
        //   );
        //   return userData$;
        // };
        class_1.prototype._initDataObserver = function () {
            var _this = this;
            var mapData$ = this.data$.pipe(filter_2(function (data) { return !!_this.mapInstance.map; }));
            var render$ = combineLatest$1(mapData$, this.mapInstance.map$.pipe(filter_2(function (data) { return !!data; })), function (mapData, map$$1) { return mapData; });
            // function isNewId (newItem, old) {
            //   if(!old && newItem) return true;
            //   if(newItem && old) return  newItem.id !== old.id
            // }
            // function isNewList(newList, old) {
            //   if(!old && newList) return true;
            //   if(newList && old) return !newList.next && newList.count
            // }
            var sub = render$.subscribe(function (_a) {
                var valid = _a.valid, invalid = _a.invalid, isNew = _a.isNew;
                _this.trace(valid);
                if (isNew)
                    _this.mapInstance.resetBounds();
            });
            this.dataSub = sub;
        };
        class_1.prototype.clear = function () {
            this.dataSub.unsubscribe();
        };
        return class_1;
    }(Base));
}

var __extends$17 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// import { GlobalMap } from "../global/map-service";
function ClusterMixin(Base) {
    return (function (_super) {
        __extends$17(class_1, _super);
        function class_1() {
            var arg = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arg[_i] = arguments[_i];
            }
            var _this = _super.apply(this, arg) || this;
            _this.forceExtendBounds = true;
            _this.toNotSetMap = true;
            _this.addCluster();
            return _this;
        }
        class_1.prototype.trace = function (items, map$$1) {
            if (items && items.length) {
                this.clearAllClusters(items);
            }
            _super.prototype.trace.call(this, items, map$$1);
        };
        class_1.prototype.addCluster = function () {
            this.mapInstance.addCluster(this);
        };
        class_1.prototype.traceEffect = function () {
            if (this.cluster) {
                var userMarkerArray = values(this.entities).map(function (userMarker) {
                    return userMarker.item;
                });
                this.mapInstance.mapUtils.addMarkersToCluster(this.cluster, userMarkerArray, this.mapInstance.map);
            }
        };
        class_1.prototype.getBounds = function (item, bounds) {
            return this.mapInstance.mapUtils.extendItemBounds(item, bounds, true);
        };
        class_1.prototype.removeItem = function (item) {
            this.mapInstance.mapUtils.removeClusterMarker(this.cluster, item);
            _super.prototype.removeItem.call(this, item);
        };
        class_1.prototype.removeAll = function (entities) {
            this.cluster && this.mapInstance.mapUtils.removeClusterMarkers(this.cluster);
            this.entities = {};
            // super.removeAll(entities);
        };
        
        class_1.prototype.clearAllClusters = function (data) {
            var entitiesCount = Object.keys(this.entities).length;
            if (entitiesCount > 400 && entitiesCount - data.length > 100) {
                this.removeAll(this.entities);
            }
        };
        return class_1;
    }(Base));
}

var MarkersBase = (function () {
    function MarkersBase(renderConfig, styleFunct, name) {
        this.renderConfig = renderConfig;
        this.styleFunct = styleFunct;
        this.name = name;
        this.mapInstance = renderConfig.mapInstance || new MapInstance();
    }
    MarkersBase.prototype.getPosition = function (data) {
        return this.renderConfig.getPosition(data);
    };
    MarkersBase.prototype.getInfoContent = function (data) {
        return this.renderConfig.getInfoContent(data);
    };
    return MarkersBase;
}());

var PolylinesBase = (function () {
    function PolylinesBase(renderConfig, styleFunct) {
        this.renderConfig = renderConfig;
        this.styleFunct = styleFunct;
        this.mapInstance = renderConfig.mapInstance || new MapInstance();
    }
    PolylinesBase.prototype.getEncodedPath = function (data) {
        return this.renderConfig.getEncodedPath(data);
    };
    PolylinesBase.prototype.getEncodedPositionTime = function (data) {
        return this.renderConfig.getEncodedPositionTime(data);
    };
    return PolylinesBase;
}());

var DivMarkersBase = (function () {
    function DivMarkersBase(renderConfig, styleFunct) {
        this.renderConfig = renderConfig;
        this.styleFunct = styleFunct;
        this.mapInstance = renderConfig.mapInstance || new MapInstance();
    }
    DivMarkersBase.prototype.getPosition = function (data) {
        return this.renderConfig.getPosition(data);
    };
    DivMarkersBase.prototype.getInfoContent = function (data) {
        return this.renderConfig.getInfoContent(data);
    };
    DivMarkersBase.prototype.getDivContent = function (data) {
        return this.renderConfig.getDivContent(data);
    };
    return DivMarkersBase;
}());

var __assign$4 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var mapItemsFactory = function (baseClass, config) {
    var defaultConfig = {
        isCluster: false,
        hasPopup: false,
        isPolyline: false,
        isDiv: false,
        isSingleItem: false,
        isCircle: false,
        hasDataObservable: false
    };
    var finalConfig = __assign$4({}, defaultConfig, config);
    var itemClass = baseClass;
    itemClass = MarkersMixin(itemClass);
    itemClass = StyleMixin(itemClass);
    itemClass = TraceMixin(itemClass);
    itemClass = ExtendBoundsMixin(itemClass);
    if (finalConfig.isSingleItem)
        itemClass = SingleItemMixin(itemClass);
    if (finalConfig.hasPopup)
        itemClass = PopupMixin(itemClass);
    if (finalConfig.isCluster)
        itemClass = ClusterMixin(itemClass);
    if (finalConfig.isDiv)
        itemClass = DivMarkersMixin(itemClass);
    if (finalConfig.isCircle)
        itemClass = CircleMixin(itemClass);
    if (finalConfig.isPolyline)
        itemClass = PolylinesMixin(itemClass);
    if (finalConfig.hasDataObservable)
        itemClass = DataObservableMixin(itemClass);
    return itemClass;
};
var itemsBaseFactory = function (_a) {
    var renderConfig = _a.renderConfig, typeConfig = _a.typeConfig, styleFunct = _a.styleFunct;
    var mapTypesBase = {
        polylines: PolylinesBase,
        markers: MarkersBase,
        divMarkers: DivMarkersBase
    };
    typeConfig = typeConfig || {};
    var MapItemBase = mapTypesBase.markers;
    if (typeConfig.isDiv)
        MapItemBase = mapTypesBase.divMarkers;
    if (typeConfig.isPolyline)
        MapItemBase = mapTypesBase.polylines;
    var base = mapItemsFactory(MapItemBase, typeConfig);
    return base;
};
var itemsFactory = function (_a) {
    var renderConfig = _a.renderConfig, typeConfig = _a.typeConfig, styleFunct = _a.styleFunct, styleObj = _a.styleObj;
    var base = itemsBaseFactory({ renderConfig: renderConfig, typeConfig: typeConfig, styleFunct: styleFunct });
    function getStyleFunct(styleObj) {
        return {
            get: function (type) {
                return styleObj[type];
            }
        };
    }
    return new base(renderConfig, styleFunct || getStyleFunct(styleObj));
};

var stopMarkersConfig = {
    renderConfig: {
        getPosition: function (data) {
            if (data.location && data.location.geojson) {
                var lat = data.location.geojson.coordinates[1];
                var lng = data.location.geojson.coordinates[0];
                return { lat: lat, lng: lng };
            }
            else {
                return null;
            }
        },
        getInfoContent: function (data) {
            var durationString = null;
            if (data.started_at && data.ended_at) {
                var durationMin = new Date(new Date(data.ended_at).getTime() -
                    new Date(data.started_at).getTime()).getTime() /
                    (1000 * 60);
                durationString = HMString(durationMin);
            }
            var start = TimeString(data.started_at);
            var end = TimeString(data.ended_at);
            var startDate = DateString(data.started_at);
            var startDateShort = DateString(data.started_at, "short");
            var endDate = DateString(data.ended_at);
            var sameDate = startDate == endDate;
            function htShow(item) {
                return "display: " + (item ? "flex" : "none");
            }
            return "<div class=\"flex-column\">\n<strong class=\"text-muted text-center\" style=\"padding-bottom: 0; color: " + Color.stop + "\">Stop</strong>\n<div style=\"display: " + (start ? "display" : "none") + "\" class=\"flex-row space-between\">\n    <div>" + (start ||
                "--:--") + "</div><div>&nbsp; to &nbsp;</div><div class=\"text-right\">" + (end ||
                "--:--") + "</div>\n</div>\n<div style=\"" + htShow(startDate || endDate) + "\" class=\"" + (sameDate || !endDate ? "space-around" : "space-between") + " text-2 text-muted flex-row\">\n    <div>" + startDateShort + "</div><div style=\"display: " + (sameDate || !endDate ? "none" : "block") + "\">" + endDate + "</div>\n</div>\n<div style=\"display: " + (durationString ? "block" : "none") + "\" class=\"text-3 text-center\">" + durationString + "</div>\n</div>";
        }
    },
    styleFunct: stopStyles,
    typeConfig: {
        hasPopup: true,
        isCircle: true,
        hasDataObservable: false
    },
    name: "stop"
};
var stopMarkersTrace = function () {
    return itemsFactory(stopMarkersConfig);
};
var StopMarkers = (function () {
    function StopMarkers(mapInstance) {
        this.mapInstance = mapInstance;
        this.styleFunct = stopStyles;
    }
    StopMarkers.prototype.getPosition = function (data) {
        if (data.location && data.location.geojson) {
            var lat = data.location.geojson.coordinates[1];
            var lng = data.location.geojson.coordinates[0];
            return { lat: lat, lng: lng };
        }
        else {
            return null;
        }
    };
    
    StopMarkers.prototype.getInfoContent = function (data) {
        var durationString = null;
        if (data.started_at && data.ended_at) {
            var durationMin = new Date(new Date(data.ended_at).getTime() -
                new Date(data.started_at).getTime()).getTime() /
                (1000 * 60);
            durationString = HMString(durationMin);
        }
        var start = TimeString(data.started_at);
        var end = TimeString(data.ended_at);
        var startDate = DateString(data.started_at);
        var startDateShort = DateString(data.started_at, "short");
        var endDate = DateString(data.ended_at);
        var sameDate = startDate == endDate;
        function htShow(item) {
            return "display: " + (item ? "flex" : "none");
        }
        return "<div class=\"flex-column\">\n<strong class=\"text-muted text-center\" style=\"padding-bottom: 0; color: " + Color.stop + "\">Stop</strong>\n<div style=\"display: " + (start ? "display" : "none") + "\" class=\"flex-row space-between\">\n    <div>" + (start ||
            "--:--") + "</div><div>&nbsp; to &nbsp;</div><div class=\"text-right\">" + (end ||
            "--:--") + "</div>\n</div>\n<div style=\"" + htShow(startDate || endDate) + "\" class=\"" + (sameDate || !endDate ? "space-around" : "space-between") + " text-2 text-muted flex-row\">\n    <div>" + startDateShort + "</div><div style=\"display: " + (sameDate || !endDate ? "none" : "block") + "\">" + endDate + "</div>\n</div>\n<div style=\"display: " + (durationString ? "block" : "none") + "\" class=\"text-3 text-center\">" + durationString + "</div>\n</div>";
    };
    return StopMarkers;
}());
var StopMarkersTrace = PopupMixin(TraceMixin(ExtendBoundsMixin(CircleMixin(MarkersMixin(StyleMixin(MapItemsMixin(StopMarkers)))))));
// export abstract class StopMarkers {
//   name = "Stop";
//   styleFunct = stopStyles;
//
//   htShow(item) {
//     return `display: ${item ? 'flex' : 'none'}`
//   };
//
//   getPosition(data) {
//     if(data.location && data.location.geojson) {
//       let lat = data.location.geojson.coordinates[1];
//       let lng = data.location.geojson.coordinates[0];
//       return {lat, lng}
//     } else {
//       return null;
//     }
//
//   };
//
//   getInfoContent(data: ISegment) {
//     function htShow(item) {
//       return `display: ${item ? 'flex' : 'none'}`
//     };
//     console.log(this.htShow, "htShow");
//     let durationString = null;
//     if(data.started_at && data.ended_at) {
//       let durationMin = (new Date(new Date(data.ended_at).getTime() - new Date(data.started_at).getTime()).getTime()) / (1000 * 60);
//       durationString = HMString(durationMin)
//     }
//
//     let start = TimeString(data.started_at);
//     let end = TimeString(data.ended_at);
//     let startDate = DateString(data.started_at);
//     let startDateShort = DateString(data.started_at, 'short');
//     let endDate = DateString(data.ended_at);
//     let sameDate = startDate == endDate;
//     return `<div class="flex-column">
// <strong class="text-muted text-center" style="padding-bottom: 0; color: ${Color.stop}">Stop</strong>
// <div style="display: ${start ? 'display' : 'none'}" class="flex-row space-between">
//     <div>${start || '--:--'}</div><div>&nbsp; to &nbsp;</div><div class="text-right">${end || '--:--'}</div>
// </div>
// <div style="${htShow(startDate || endDate)}" class="${sameDate || !endDate ? 'space-around' : 'space-between'} text-2 text-muted flex-row">
//     <div>${startDateShort}</div><div style="display: ${sameDate || !endDate ? 'none' : 'block'}">${endDate}</div>
// </div>
// <div style="display: ${durationString ? 'block' : 'none'}" class="text-3 text-center">${durationString}</div>
// </div>`
//   }
// }
//
// export const StopMarkersTrace = mapItemsFactory(StopMarkers, {
//   hasPopup: true,
//   isCircle: true,
//   hasDataObservable: false
// });

var ActionMarkers = (function () {
    function ActionMarkers(mapInstance) {
        this.mapInstance = mapInstance;
        this.name = "Action";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {
                                flat: true,
                                anchor: RichMarkerPosition.MIDDLE,
                                zIndex: 1
                            },
                            popup: {
                                pixelOffset: new google.maps.Size(0, -5),
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                iconAnchor: [12, 12]
                                // iconSize: [35, 35],
                                // className: 'current-action-marker',
                                // iconAnchor: point(15, 43)
                                // iconAnchor: [15, 43]
                            },
                            popup: {
                                // offset: point(0, -35),
                                offset: [0, -5],
                                closeButton: false
                            }
                        };
                    }
                }
            }
        };
    }
    ActionMarkers.prototype.getPosition = function (data) {
        var posObj = htAction(data).getPositionsObject();
        return posObj ? posObj.position : null;
    };
    ActionMarkers.prototype.getDivContent = function (action) {
        var icon = "<div class=\"action-marker flex-row\">\n<span style=\"margin: auto\">" + NameCase(action.type[0]) + "</span>\n</div>";
        return icon;
    };
    return ActionMarkers;
}());
var ActionMarkersTrace = ExtendBoundsMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionMarkers))))));

var userDivFactory = function (user) {
    return "<div class=\"m-marker\">\n        <div class=\"m-box\" style=\"background-image: url('" + user.photo + "')\"></div>\n          <i class=\"fa fa-neuter\"></i>\n      </div>";
};

var __extends$18 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function AnimationMixin(Base) {
    return (function (_super) {
        __extends$18(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // bearing: number = 0;
            // item;
            _this.isAnimated = true;
            return _this;
        }
        class_1.prototype.setTimeAwareAnimation = function (animation) {
            var _this = this;
            this.animation = animation || new TimeAwareAnimation();
            this.animation.updateEvent.subscribe('update', function (_a) {
                var path = _a.path, bearing = _a.bearing;
                var entity = _this.getEntity();
                if (entity)
                    _this.update(entity, { path: path, bearing: bearing });
            });
        };
        return class_1;
    }(Base));
}

var currentUserConfig = {
    renderConfig: {
        getPosition: function (data) {
            return htUser(data).getPosition();
        },
        getDivContent: function (data) {
            return userDivFactory(data);
        }
    },
    styleFunct: {
        get: function (type) {
            switch (type) {
                case "google":
                    {
                        return {
                            default: {
                                flat: true,
                                anchor: RichMarkerPosition.BOTTOM_CENTER
                            }
                        };
                    }
                    ;
                case "leaflet": {
                    return {
                        default: {
                            // iconAnchor: point(15, 43)
                            iconAnchor: [15, 43]
                        }
                    };
                }
            }
        }
    },
    typeConfig: {
        isSingleItem: true,
        isDiv: true,
        hasDataObservable: false
    },
    name: "Current user"
};
var currentUserTrace = function () {
    return itemsFactory(currentUserConfig);
};
var CurrentUser = (function () {
    function CurrentUser(mapInstance) {
        this.mapInstance = mapInstance;
        this.name = "Current user";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case "google":
                        {
                            return {
                                default: {
                                    flat: true,
                                    anchor: RichMarkerPosition.BOTTOM_CENTER
                                }
                            };
                        }
                        ;
                    case "leaflet": {
                        return {
                            default: {
                                // iconAnchor: point(15, 43)
                                iconAnchor: [15, 43]
                            }
                        };
                    }
                }
            }
        };
    }
    CurrentUser.prototype.getPosition = function (data) {
        return htUser(data).getPosition();
    };
    
    CurrentUser.prototype.getDivContent = function (data) {
        return userDivFactory(data);
    };
    return CurrentUser;
}());
var CurrentUserTrace = AnimationMixin(SingleItemMixin(DivMarkersMixin(TraceMixin(MarkersMixin(StyleMixin(MapItemsMixin(CurrentUser)))))));
// export class CurrentUser {
//   name = "Current user";
//   styleFunct: StyleFunct = {
//     google: {
//       default: {
//         flat: true,
//         anchor: RichMarkerPosition.BOTTOM_CENTER,
//       }
//     },
//     leaflet: {
//       default: {
//
//       }
//     }
//   };
//
//   getPosition(data): HtPosition {
//     return htUser(data).getPosition()
//   };
//
//   getDivContent(data) {
//     return userDivFactory(data)
//
//   }
// };
//
// export const CurrentUserTrace = mapItemsFactory(CurrentUser, {
//   isSingleItem: true,
//   isDiv: true,
//   hasDataObservable: false
// });

var __extends$19 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// import { GlobalMap } from "../global/map-service";
function CompoundDataObservableMixin(Base) {
    return (function (_super) {
        __extends$19(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.mapInstance.addToItemsSet(_this);
            return _this;
        }
        class_1.prototype._procData$ = function () {
            return function (source$) {
                return source$.pipe(map_2(function (markers) {
                    return reduce(markers, function (acc, item) {
                        var isValid = true;
                        if (isValid) {
                            acc.valid.push(item);
                        }
                        else {
                            acc.invalid.push(item);
                        }
                        return acc;
                    }, { valid: [], invalid: [] });
                    // return markers
                }));
            };
        };
        class_1.prototype.setCompoundData$ = function (data$, config) {
            if (config === void 0) { config = {}; }
            this.compoundSetDataConfig = config;
            if (this.dataSub) {
                this.dataSub.unsubscribe();
            }
            var hide$ = config.hide$;
            var filter$ = config.filter$;
            var dataSource$ = hide$
                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) { return (!!hide ? null : data); })
                : data$;
            if (config.roots && config.highlighted$) {
                dataSource$ = dataWithSelectedId$(dataSource$, config.highlighted$, config.roots, 'highlightedSegment');
            }
            if (config.roots && filter$)
                dataSource$ = dataWithSelectedId$(dataSource$, filter$, config.roots, 'selectedSegment');
            this.dataSource$ = dataSource$;
            this.data$ = this.dataSource$;
            this._initDataObserver();
        };
        class_1.prototype._initData$ = function () {
            var _this = this;
            var userData$ = this.data$.pipe(filter_2(function (data) { return !!_this.mapInstance.map; }), scan_2(function (acc, data) {
                var oldUser = acc.user;
                return { user: data, oldUser: oldUser };
            }, { user: null, oldUser: null }));
            return userData$;
        };
        class_1.prototype._initDataObserver = function () {
            var _this = this;
            var userData$ = this._initData$();
            function isNewItem(newItem, old) {
                if (!old && newItem)
                    return true;
                if (newItem && old)
                    return !old && !!newItem;
            }
            var newPlaceline$ = userData$.pipe(map_2(function (acc) {
                var userData = acc.user;
                _this.trace(userData);
                var isNew = isNewItem(acc.user, acc.oldUser);
                return isNew;
                // if(isNew) GlobalMap.resetBounds()
            }));
            var sub = orCombine(newPlaceline$.pipe(filter_2(function (data) { return !!data; })), this.compoundSetDataConfig.resetMap$.pipe(map_2(function (data) { return true; }))).subscribe(function (toReset) {
                if (toReset)
                    _this.mapInstance.resetBounds();
            });
            this.dataSub = sub;
        };
        return class_1;
    }(Base));
}

var __extends$20 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AnimPolyline = (function (_super) {
    __extends$20(AnimPolyline, _super);
    function AnimPolyline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = "anim polyline";
        return _this;
    }
    return AnimPolyline;
}(SegmentPolylines));
var AnimPolylineTrace = AnimationMixin(SingleItemMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(AnimPolyline))))))));

var __extends$21 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ActionsPolyline = (function (_super) {
    __extends$21(ActionsPolyline, _super);
    function ActionsPolyline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lineSymbol = {
            path: 'M 0,-1 0,1',
            strokeOpacity: 1,
            scale: 4
        };
        _this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case "google":
                        {
                            return {
                                default: {
                                    strokeColor: Color.grey3,
                                    strokeOpacity: 0,
                                    strokeWeight: 5,
                                    icons: [{
                                            icon: {
                                                path: 'M 0,-1 0,0',
                                                strokeOpacity: 1,
                                                scale: 4
                                            },
                                            offset: '0',
                                            repeat: '13px'
                                        }],
                                },
                                highlight: {
                                    strokeColor: Color.grey2,
                                    strokeOpacity: 1,
                                    strokeWeight: 5
                                },
                                fade: {
                                    strokeColor: Color.grey2,
                                    strokeOpacity: 0.2,
                                    strokeWeight: 2
                                }
                            };
                        }
                        ;
                    case "leaflet": {
                        return {
                            default: {
                                weight: 5,
                                color: Color.grey4,
                                opacity: 1,
                                dashArray: "7 10"
                            },
                            highlight: {
                                weight: 5,
                                color: Color.grey2,
                                opacity: 1
                            },
                            fade: {
                                weight: 2,
                                color: Color.grey2,
                                opacity: 0.2
                            }
                        };
                    }
                }
            },
        };
        _this.name = "action polyline";
        return _this;
    }
    ActionsPolyline.prototype.getPathFromData = function (data) {
        return data ? data.actions.reduce(function (path, action) {
            return htAction(action).getExpectedPosition() && !action.completed_at ? path.concat([htAction(action).getPosition()]) : path;
        }, []) : null;
    };
    return ActionsPolyline;
}(SegmentPolylines));
var ActionsPolylineTrace = ConnectorMixin(AnimationMixin(SingleItemMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsPolyline)))))))));
function ConnectorMixin(Base) {
    return (function (_super) {
        __extends$21(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.positionTimeArray = [];
            return _this;
        }
        /*
        Need to ensure connector is traced before this class is traced
         */
        class_1.prototype.setConnector = function (entity) {
            this.connector = entity ? entity.item : null;
        };
        class_1.prototype.getConnectorPosition = function () {
            return this.connector ? this.mapInstance.mapUtils.getItemPosition(this.connector) : null;
        };
        class_1.prototype.update = function (_a, pathBearing) {
            var item = _a.item, data = _a.data;
            var startPosition;
            if (pathBearing) {
                var path = pathBearing.path;
                startPosition = path[path.length - 1];
            }
            else {
                startPosition = this.getConnectorPosition();
            }
            
            var dataPath = this.getPathFromData(data);
            if (dataPath && startPosition) {
                var finalPath = [startPosition].concat(dataPath);
                this.mapInstance.mapUtils.setPath(item, finalPath);
                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);
            }
            else {
                this.clear();
            }
        };
        return class_1;
    }(Base));
}

var Placeline = (function () {
    function Placeline(options) {
        this.options = options;
        this.allowedEvents = {};
        this.anim = new TimeAwareAnimation();
        this.mapInstance = this.options.mapInstance;
        this.stopMarkers = new StopMarkersTrace(this.mapInstance);
        this.userMarker = new CurrentUserTrace(this.mapInstance);
        this.userMarker.setTimeAwareAnimation(this.anim);
        this.segmentsPolylines = new SegmentPolylinesTrace(this.mapInstance);
        this.actionMarkers = new ActionMarkersTrace(this.mapInstance);
        this.animPolyline = new AnimPolylineTrace(this.mapInstance);
        this.animPolyline.setTimeAwareAnimation(this.anim);
        this.actionsPolyline = new ActionsPolylineTrace(this.mapInstance);
        this.actionsPolyline.setTimeAwareAnimation(this.anim);
    }
    Object.defineProperty(Placeline.prototype, "map", {
        get: function () {
            return this.mapInstance.map;
        },
        enumerable: true,
        configurable: true
    });
    Placeline.prototype.trace = function (user, map$$1) {
        var selectedSegment = user ? user.selectedSegment : null;
        this.setHighlightId(user);
        var userSegments = user && user.segments ? user.segments : [];
        var segType = this.getSegmentTypes(userSegments);
        var lastSegment = segType.lastSegment;
        var restTrips = segType.tripSegment.pop();
        this.traceStops(segType.stopSegment, selectedSegment, lastSegment);
        if (lastSegment) {
            var string = this.getTimeAwarePolyline(lastSegment);
            if (string) {
                //todo infer toNotTraceItem from animMixin trace
                this.userMarker.toNotTraceItem = true;
                this.animPolyline.toNotTraceItem = true;
                this.actionsPolyline.toNotTraceItem = true;
                // this.animPolyline.trace(restTrips);
                this.anim.updatePolylineString(string);
            }
            else {
                this.animPolyline.toNotTraceItem = false;
                this.userMarker.toNotTraceItem = false;
                this.actionsPolyline.toNotTraceItem = false;
                // if (!selectedSegment) this.animPolyline.trace(restTrips);
                this.anim.clear();
            }
            this.userMarker.trace(user);
            this.traceAnimPolyline(restTrips, selectedSegment);
            this.actionsPolyline.setConnector(this.userMarker.getEntity());
            this.actionsPolyline.trace(user);
        }
        else {
            this.anim.clear();
            this.userMarker.clear();
            this.animPolyline.clear();
            this.actionsPolyline.clear();
        }
        this.traceSegments(segType.tripSegment, selectedSegment);
        this.traceAction(user, selectedSegment);
        // this.actionsPolyline.setConnector(this.userMarker.getEntity());
        // this.actionsPolyline.trace(user)
    };
    
    Placeline.prototype.traceAnimPolyline = function (restTrip, selectedSegment) {
        if (!restTrip) {
            this.animPolyline.clear();
        }
        else if (!selectedSegment || selectedSegment.id === restTrip.id) {
            this.animPolyline.trace(restTrip);
        }
        else {
            this.animPolyline.clear();
        }
    };
    Placeline.prototype.traceStops = function (stops, selectedSegment, lastSegment) {
        if (selectedSegment) {
            stops = selectedSegment.type == 'stop' ? [selectedSegment] : [];
        }
        this.stopMarkers.trace(stops);
    };
    Placeline.prototype.traceSegments = function (trips, selectedSegment) {
        if (trips === void 0) { trips = []; }
        if (selectedSegment) {
            var matchedTrip = trips.find(function (trip) { return trip.id === selectedSegment.id; });
            trips = matchedTrip ? [matchedTrip] : [];
        }
        this.segmentsPolylines.trace(trips);
    };
    Placeline.prototype.traceAction = function (user, selectedSegment) {
        var actions = user && user.actions && !selectedSegment ? user.actions : [];
        var filteredActions = filter$1(actions, function (action) {
            return htAction(action).isValidMarker();
        });
        if (this.actionMarkers)
            this.actionMarkers.trace(filteredActions);
    };
    Placeline.prototype.setHighlightId = function (user) {
        var data = user && !user.selectedSegment ? user.highlightedSegment : null;
        var id = data ? data.id : null;
        this.stopMarkers.highlightedId = id;
        this.segmentsPolylines.highlightedId = id;
        this.animPolyline.highlightedId = id;
    };
    Placeline.prototype.getTimeAwarePolyline = function (segment) {
        return segment ? segment.time_aware_polyline : null;
    };
    Placeline.prototype.extendBounds = function (bounds) {
        bounds = this.stopMarkers.extendBounds(bounds);
        bounds = this.segmentsPolylines.extendBounds(bounds);
        bounds = this.animPolyline.extendBounds(bounds);
        bounds = this.actionMarkers.extendBounds(bounds);
        // bounds = this.userMarker.extendBounds(bounds);
        // console.log(bounds, "final");
        return bounds;
    };
    Placeline.prototype.getSegmentTypes = function (userSegments) {
        return reduce(userSegments, function (segmentType, segment) {
            segmentType.lastSegment = segment;
            if (segment.type == "stop") {
                if (segment.location && segment.location.geojson)
                    segmentType.stopSegment.push(segment);
            }
            else {
                if (segment.encoded_polyline)
                    segmentType.tripSegment.push(segment);
            }
            return segmentType;
        }, { tripSegment: [], stopSegment: [], lastSegment: null });
    };
    return Placeline;
}());
var PlacelineTrace = CompoundDataObservableMixin(Placeline);

var UsersCluster = (function () {
    function UsersCluster(mapInstance) {
        this.mapInstance = mapInstance;
        this.name = "users cluster";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {
                                flat: true,
                                anchor: RichMarkerPosition.BOTTOM_CENTER,
                                zIndex: 1
                            },
                            popup: {
                                disableAutoPan: true,
                                pixelOffset: new google.maps.Size(0, -35)
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                // iconAnchor: point(15, 43)
                                iconAnchor: [15, 43]
                            },
                            popup: {
                                // offset: point(0, -35),
                                offset: [0, -35],
                                closeButton: false
                            }
                        };
                    }
                }
            }
        };
    }
    UsersCluster.prototype.getPosition = function (data) {
        return htUser(data).getPosition();
    };
    
    UsersCluster.prototype.getDivContent = function (data) {
        return userDivFactory(data);
    };
    
    UsersCluster.prototype.getInfoContent = function (data) {
        var string = "<div>\n<strong>" + data.name + "</strong>\n<div>" + data.display.status_text + "</div>\n<div>" + data.display.sub_status_text + "</div>\n</div>";
        return string;
    };
    UsersCluster.prototype.traceEffect = function () {
    };
    return UsersCluster;
}());
var UsersClusterTrace = DataObservableMixin(PopupMixin(ClusterMixin(TraceMixin(ExtendBoundsMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(UsersCluster)))))))));
// export class UsersClusters {
//   name = "Cluster user";
//   styleFunct: StyleFunct = {
//     google: {
//       default: {
//         flat: true,
//         anchor: RichMarkerPosition.BOTTOM_CENTER,
//         zIndex: 1
//       },
//       popup: {
//         disableAutoPan: true,
//         pixelOffset: new google.maps.Size(0, -35)
//       }
//     },
//     leaflet: {
//       default: {
//
//       }
//     }
//   };
//
//   getPosition(data): HtPosition {
//     return htUser(data).getPosition()
//   };
//
//   getDivContent(data) {
//     return userDivFactory(data)
//   };
//
//   getInfoContent(data) {
//     let string = `<div>
// <strong>${data.name}</strong>
// <div>${data.display.status_text}</div>
// <div>${data.display.sub_status_text}</div>
// </div>`;
//     return string
//   }
// }
//
// export const UsersClustersTrace = mapItemsFactory(UsersClusters, {
//   hasPopup: true,
//   isCluster: true,
//   isDiv: true,
//   hasDataObservable: true
// });

var __extends$22 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function HeatmapMixin(Base) {
    return (function (_super) {
        __extends$22(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.forceExtendBounds = true;
            var style = _this.getStyle();
            _this.heatmap = _this.mapInstance.mapUtils.getHeatmap(style);
            return _this;
        }
        class_1.prototype.trace = function (items, map$$1) {
            var _this = this;
            this.entities = items.map(function (item) { return ({ item: item }); });
            this.map = map$$1 || this.mapInstance.map;
            if (this.map) {
                if (items) {
                    var latLngs = items.reduce(function (acc, item) {
                        var position = _this.getPosition(item);
                        return position ? acc.concat([position]) : acc;
                    }, []);
                    this.mapInstance.mapUtils.updateHeatMapLatlng(latLngs, this.heatmap);
                    this.mapInstance.mapUtils.setMap(this.heatmap, this.map);
                }
                else {
                    this.clear();
                }
            }
            else {
                console.warn("Map is not initialized");
                return false;
            }
        };
        class_1.prototype.getBounds = function (item, bounds) {
            var position = this.getPosition(item);
            return this.mapInstance.mapUtils.extendBounds(position, bounds);
        };
        class_1.prototype.clear = function () {
            this.trace([]);
        };
        return class_1;
    }(Base));
}

var StopsHeatmap = (function () {
    function StopsHeatmap(mapInstance) {
        this.name = "stop heatmap";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case "google": {
                        return {
                            default: {}
                        };
                    }
                    case "leaflet": {
                        return {
                            default: {
                                radius: 7,
                                minOpacity: 0.6
                            }
                        };
                    }
                }
            }
        };
        this.mapInstance = mapInstance;
    }
    StopsHeatmap.prototype.getPosition = function (item) {
        return {
            lat: item.place__location[1],
            lng: item.place__location[0],
            weight: item.intensity
        };
    };
    return StopsHeatmap;
}());

var StopsHeatmapTrace = ExtendBoundsMixin(DataObservableMixin(HeatmapMixin(StyleMixin(MapItemsMixin(StopsHeatmap)))));

var ActionsCluster = (function () {
    function ActionsCluster(mapInstance) {
        this.mapInstance = mapInstance;
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {
                                flat: true,
                                anchor: RichMarkerPosition.MIDDLE,
                                zIndex: 1
                            },
                            popup: {
                                pixelOffset: new google.maps.Size(0, -5),
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                iconAnchor: [12, 12]
                                // iconSize: [35, 35],
                                // className: 'current-action-marker',
                                // iconAnchor: point(15, 43)
                                // iconAnchor: [15, 43]
                            },
                            popup: {
                                // offset: point(0, -35),
                                offset: [0, -5],
                                closeButton: false
                            }
                        };
                    }
                }
            }
        };
    }
    ActionsCluster.prototype.getPosition = function (data) {
        return htAction(data).getPosition();
    };
    ActionsCluster.prototype.getDivContent = function (action) {
        var icon = "<div class=\"action-marker flex-row\">\n<span style=\"margin: auto\">" + NameCase(action.type[0]) + "</span>\n</div>";
        return icon;
    };
    ActionsCluster.prototype.getInfoContent = function (item) {
        function htShow(item, style) {
            if (style === void 0) { style = "flex"; }
            return "display: " + (item ? style : "none");
        }
        var userName = item.user ? item.user.name : '';
        return "<div class=\"flex-column flex-center\" style=\"min-width: 180px\">\n<div class=\"\">\n    <div class=\"text-center\">" + NameCase(item.type) + "\n    <span style=\"" + htShow(item.display.duration_remaining && !item.display.show_summary) + "\"> in " + HMString(item.display.duration_remaining / 60) + "</span>\n    <span style=\"" + htShow(!!item.completed_at) + "\"> completed at " + TimeString(item.completed_at) + "</span>\n   \n    </div>\n</div>\n    <div class=\"text-muted text-center\" style=\"" + htShow(!!item.completed_at) + "\"> " + DateString(item.completed_at) + "</div>\n<div class=\"text-center\">" + NameCase(userName) + "<span style=\"" + htShow(!!item.lookup_id, 'block') + "\"> | #" + item.lookup_id + "</span></div>\n</div>";
    };
    ActionsCluster.prototype.traceEffect = function () {
    };
    return ActionsCluster;
}());

var ActionsClusterTrace = DataObservableMixin(PopupMixin(ClusterMixin(TraceMixin(ExtendBoundsMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsCluster)))))))));

var ActionsHeatmap = (function () {
    function ActionsHeatmap(mapInstance) {
        this.mapInstance = mapInstance;
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case "google": {
                        return {
                            default: {}
                        };
                    }
                    case "leaflet": {
                        return {
                            default: {
                                radius: 7,
                                minOpacity: 0.6
                            }
                        };
                    }
                }
            }
        };
    }
    ActionsHeatmap.prototype.getPosition = function (item) {
        return {
            lat: item.completed_place__location[1],
            lng: item.completed_place__location[0],
        };
    };
    
    return ActionsHeatmap;
}());

var ActionsHeatmapTrace = ExtendBoundsMixin(DataObservableMixin(ExtendBoundsMixin(HeatmapMixin(StyleMixin(MapItemsMixin(ActionsHeatmap))))));

var __assign$5 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var HtMapClass = (function () {
    // clusters = [];
    // map$ = new ReplaySubject();
    function HtMapClass(mapType, options) {
        if (mapType === void 0) { mapType = "leaflet"; }
        if (options === void 0) { options = {}; }
        this.mapType = mapType;
        // map: HtMap;
        // mapUtils: MapUtils;
        // userData$: Observable<IUserData | null>;
        this.mapInstance = new MapInstance();
        this.leafletSetBoundsOptions = {
            animate: true,
            duration: 0.3
        };
        this.googleSetBoundsOptions = {};
        this.googleMapOptions = {
            center: { lat: 0, lng: 0 },
            zoom: 2,
            fullscreenControl: false,
            streetViewControl: false,
            styles: LightColorMapStyle
        };
        this.leafletMapOptions = { center: [3.505, 0], zoom: 2 };
        this.mapItemsSet = [];
        mapTypeService.getInstance(mapType);
        if (options.mapKey) {
            // mapTypeService.getInstance().setKey(options.mapKey);
        }
        this.usersCluster = new UsersClusterTrace(this.mapInstance);
        this.actionsCluster = new ActionsClusterTrace(this.mapInstance);
        this.usersHeatmap = new StopsHeatmapTrace(this.mapInstance);
        this.actionsHeatmap = new ActionsHeatmapTrace(this.mapInstance);
        this.placeline = new PlacelineTrace({ mapInstance: this.mapInstance });
    }
    Object.defineProperty(HtMapClass.prototype, "segmentTrace", {
        get: function () {
            return this.placeline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HtMapClass.prototype, "map$", {
        get: function () {
            return this.mapInstance.map$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HtMapClass.prototype, "map", {
        get: function () {
            return this.mapInstance.map;
        },
        enumerable: true,
        configurable: true
    });
    HtMapClass.prototype.initMap = function (elem, options) {
        if (options === void 0) { options = {}; }
        var mapOptions = this.mapType == "leaflet"
            ? this.leafletMapOptions
            : this.googleMapOptions;
        var map$$1 = this.mapInstance.mapUtils.renderMap(elem, __assign$5({}, mapOptions, options));
        this.mapInstance.setMap(map$$1);
        return map$$1;
    };
    // setPlacelineData$(data$: Observable<IUserData | null>) {
    //   if (this.userDataSub) {
    //     this.userDataSub.unsubscribe();
    //   }
    //   this.initUserDataObserver(data$)
    // }
    //
    // private initUserDataObserver(data$: Observable<IUserData | null>) {
    //   let userData$ = data$.scan((acc, data) => {
    //     const oldId = acc.user ? acc.user.id : null;
    //     const currentId = data ? data.id : null;
    //     const isNew = currentId && oldId ? currentId !== oldId : true;
    //     return {user: data, isNew, oldId }
    //   }, {user: null, oldId: null, isNew: true});
    //
    //   let sub = userData$.subscribe((acc) => {
    //     const userData = acc.user;
    //     const isNew = acc.isNew;
    //     this.tracePlaceline(userData);
    //     if(isNew) this.resetBounds()
    //   });
    //   this.userDataSub = sub;
    // }
    HtMapClass.prototype.tracePlaceline = function (user) {
        this.placeline.trace(user);
    };
    HtMapClass.prototype.resetBounds = function (options) {
        this.mapInstance.resetBounds(options);
    };
    HtMapClass.prototype.getBoundsItem = function (items) {
        var _this = this;
        var bounds = this.mapInstance.mapUtils.extendItemBounds();
        return reduce(items, function (bounds, item) {
            return _this.getBounds(bounds, item);
        }, bounds);
    };
    HtMapClass.prototype.getBounds = function (bounds, item) {
        return item.extendBounds(bounds);
    };
    HtMapClass.prototype.setBounds = function (bounds, options) {
        options =
            options || this.mapType == "leaflet"
                ? this.leafletSetBoundsOptions
                : this.googleSetBoundsOptions;
        this.mapInstance.mapUtils.setBounds(this.map, bounds, options);
    };
    HtMapClass.prototype.inValidateSize = function () {
        this.mapInstance.mapUtils.invalidateSize(this.map);
    };
    HtMapClass.prototype.addEntities = function (entities) {
        this.mapInstance.addToItemsSet(entities);
    };
    HtMapClass.prototype.clear = function () {
        this.mapInstance.setMap(null);
    };
    return HtMapClass;
}());

var DestinationMap = (function () {
    function DestinationMap(mapInstance) {
        this.name = "Destination";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {},
                            popup: {
                                pixelOffset: new google.maps.Size(0, -5),
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                zIndexOffset: 10,
                                iconSize: [30, 30],
                                className: "destination-marker"
                            }
                        };
                    }
                }
            }
        };
        this.mapInstance = mapInstance;
    }
    DestinationMap.prototype.getPosition = function (data) {
        var place = data.completed_place || data.expected_place;
        if (place && place.location) {
            return { lat: place.location.coordinates[1], lng: place.location.coordinates[0] };
        }
        else {
            return null;
        }
    };
    DestinationMap.prototype.getDivContent = function () {
        return "<div style=\"width: 30px; height: 30px; background: #00C94B; border-radius: 50%\"></div>";
    };
    return DestinationMap;
}());

var DestinationMarker = DataObservableMixin(ExtendBoundsMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(DestinationMap)))))));

var __extends$23 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
function AnimationsEntitiesMixin(Base) {
    return (function (_super) {
        __extends$23(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // bearing: number = 0;
            // item;
            _this.isAnimated = true;
            _this.toNotTraceItem = false;
            _this.subs = {};
            return _this;
        }
        class_1.prototype.setTimeAwareAnimationEntity = function (animationEntity) {
            this.animationEntities = animationEntity || new AnimationsEntities();
        };
        
        class_1.prototype.clearItem = function (entity) {
            var id = this.trackBy(entity.data);
            var animId = entity.data.id;
            this.animationEntities.clearItem(animId);
            this.clearSub(id);
            _super.prototype.clearItem.call(this, entity);
        };
        class_1.prototype.update = function (entity, pathBearing) {
            var id = this.trackBy(entity.data);
            var animId = entity.data.id;
            this.initSub(id, animId);
            var encodedString = this.getTimeAwarePolyline ? this.getTimeAwarePolyline(entity.data) : null;
            if (encodedString) {
                this.animationEntities.update(id, encodedString);
            }
            else {
                // super.update(entity, {path, bearing})
            }
        };
        
        class_1.prototype.initSub = function (id, animId) {
            var _this = this;
            animId = animId || id;
            var sub = this.subs[id];
            if (sub) {
            }
            else {
                if (this['name'] == "action user")
                    console.log("id sub craete sub");
                var newsub = this.animationEntities
                    .getEntity(animId)
                    .updateEvent
                    .subscribe('update', function (_a) {
                    var path = _a.path, bearing = _a.bearing;
                    var entity = _this.getEntity(id);
                    if (entity) {
                        _super.prototype.update.call(_this, entity, { path: path, bearing: bearing });
                    }
                });
                this.subs[id] = newsub;
            }
        };
        class_1.prototype.clearSub = function (id) {
            var sub = this.subs[id];
            sub.unsubscribe();
            delete this.subs[id];
        };
        return class_1;
    }(Base));
}
var AnimationsEntities = (function () {
    function AnimationsEntities() {
        this.enitites = {};
    }
    AnimationsEntities.prototype.clearItem = function (id) {
        var entity = this.enitites[id];
        entity.clear();
        delete this.enitites[id];
    };
    AnimationsEntities.prototype.update = function (id, polyline$$1) {
        var entity = this.getEntity(id);
        entity.updatePolylineString(polyline$$1);
    };
    
    AnimationsEntities.prototype.getEntity = function (id) {
        var entity = this.enitites[id];
        if (entity) {
            return entity;
        }
        else {
            var newEntity = new TimeAwareAnimation();
            this.enitites[id] = newEntity;
            return newEntity;
        }
    };
    return AnimationsEntities;
}());

var ActionsDataPolyline = (function () {
    function ActionsDataPolyline(mapInstance) {
        this.name = "Actions data polyline";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {},
                            popup: {
                                pixelOffset: new google.maps.Size(0, -5),
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                fillColor: '#9155f4',
                                color: '#9155f4',
                                weight: 5
                                // iconAnchor: [12, 12]
                                // iconSize: [35, 35],
                                // className: 'current-action-marker',
                                // iconAnchor: point(15, 43)
                                // iconAnchor: [15, 43]
                            },
                            popup: {
                                // offset: point(0, -35),
                                offset: [0, -5],
                                closeButton: false
                            }
                        };
                    }
                }
            }
        };
        this.mapInstance = mapInstance;
    }
    ActionsDataPolyline.prototype.getEncodedPositionTime = function (data) {
        return data.time_aware_polyline;
    };
    //todo remove this, use getTimeAwarePolyline
    ActionsDataPolyline.prototype.getEncodedPath = function (data) {
        return data.encoded_polyline;
    };
    ActionsDataPolyline.prototype.getPosition = function (action) {
        var position = action.user ?
            action.user.last_location ? action.user.last_location.geojson.coordinates : null
            : null;
        return position ? { lat: position[1], lng: position[0] } : null;
    };
    ActionsDataPolyline.prototype.getTimeAwarePolyline = function (data) {
        return data.time_aware_polyline;
    };
    return ActionsDataPolyline;
}());
// export interface IActionsPolylineBase {
//   mapInstance: MapInstance
//   // getStyle: (styleType?) => object;
// }
//
// export function ActionsPolylineMixin<TBase extends Constructor<IActionsPolylineBase>>(Base: TBase) {
//   return class extends Base {
//     start;
//
//
//
//
//
//   };
// }
var ActionsPolylineTrace$1 = DataObservableMixin(AnimationsEntitiesMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsDataPolyline))))))));
// export const ActionsPolylineTrace = DataObservableMixin(AnimationMixin(TraceMixin(PolylinesMixin(StyleMixin(ActionsDataPolyline)))))

var StartMarker = (function () {
    function StartMarker(mapInstance) {
        this.name = "Start marker";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case 'google': {
                        return {
                            default: {},
                            popup: {
                                pixelOffset: new google.maps.Size(0, -5),
                            }
                        };
                    }
                    case 'leaflet': {
                        return {
                            default: {
                                zIndexOffset: 10,
                                iconSize: [20, 20],
                                className: "destination-marker"
                            }
                        };
                    }
                }
            }
        };
        this.mapInstance = mapInstance;
    }
    StartMarker.prototype.trace = function (mapItem) {
    };
    StartMarker.prototype.getPosition = function (data) {
        var place = data.started_place;
        if (place && place.location) {
            return { lat: place.location.coordinates[1], lng: place.location.coordinates[0] };
        }
        else {
            return null;
        }
    };
    StartMarker.prototype.getDivContent = function () {
        return "<div style=\"width: 20px; height: 20px; background: #9013FE; border-radius: 50%\"></div>";
    };
    return StartMarker;
}());

var StartMarkerTrace = ExtendBoundsMixin(DataObservableMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(StartMarker)))))));

var ActionUser = (function () {
    function ActionUser(mapInstance) {
        this.mapInstance = mapInstance;
        this.name = "action user";
        this.styleFunct = {
            get: function (type) {
                switch (type) {
                    case "google":
                        {
                            return {
                                default: {
                                    flat: true,
                                    anchor: RichMarkerPosition.BOTTOM_CENTER
                                }
                            };
                        }
                        ;
                    case "leaflet": {
                        return {
                            default: {
                                zIndexOffset: 10,
                                iconSize: [60, 60],
                                className: "action-marker"
                                // iconAnchor: point(15, 43)
                                // iconAnchor: [0, 0]
                            }
                        };
                    }
                }
            }
        };
    }
    ActionUser.prototype.getPosition = function (data) {
        return htUser(data.user).getPosition();
    };
    
    ActionUser.prototype.trackBy = function (action) {
        return action.user.id;
    };
    ActionUser.prototype.trackAnimationBy = function (action) {
        return action.id;
    };
    ActionUser.prototype.getDivContent = function (data) {
        var content = "\n    <div style=\"border-radius: 50%; height: 60px; width: 60px; background: rgba(95,143,213,0.67) \">\n  <div style=\"height: 30px; width: 30px; background-image: url('" + data.user.photo + "'); background-repeat: no-repeat;\n  background-size: cover;     top: 15px;\n    position: relative;\n    left: 15px;\n    border-radius: 50%;\"></div>\n</div> \n    ";
        return content;
    };
    
    return ActionUser;
}());
var ActionUserTrace = DataObservableMixin(ExtendBoundsMixin(AnimationsEntitiesMixin(DivMarkersMixin(TraceMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionUser))))))));

var ActionMap = (function () {
    function ActionMap(mapInstance, options) {
        if (options === void 0) { options = {}; }
        this.anim = new AnimationsEntities();
        this.mapInstance = mapInstance;
        this.destination = new DestinationMarker(mapInstance);
        this.polyline = new ActionsPolylineTrace$1(mapInstance);
        this.polyline.setTimeAwareAnimationEntity(this.anim);
        this.user = new ActionUserTrace(mapInstance);
        this.user.setTimeAwareAnimationEntity(this.anim);
        if (options.hasPulse) {
            this.pulse = new ActionUserTrace(mapInstance);
            this.pulse.setTimeAwareAnimationEntity(this.anim);
        }
        // this.user.setTimeAwareAnimation(this.anim);
        // this.user.toNotTraceItem = true;
        this.start = new StartMarkerTrace(mapInstance);
    }
    ActionMap.prototype.setData$ = function (data$) {
        this.destination.setData$(data$);
        this.polyline.setData$(data$);
        this.start.setData$(data$);
        if (this.pulse)
            this.pulse.setData$(data$.pipe(map(function (actions) {
                return actions.reduce(function (acc, action) {
                    return action.display.show_summary ? acc : acc.concat([action]);
                }, []);
            })));
        this.user.setData$(data$.pipe(map(function (actions) {
            return actions.reduce(function (acc, action) {
                return action.display.show_summary ? acc : acc.concat([action]);
            }, []);
        })));
    };
    
    return ActionMap;
}());
var ActionTrace = ActionMap;

export { MapInstance, Placeline, PlacelineTrace, HtMapClass, mapTypeService, mapItemsFactory, itemsBaseFactory, itemsFactory, MarkersBase, UsersCluster, UsersClusterTrace, ActionMarkers, ActionMarkersTrace, SegmentPolylines, SegmentPolylinesTrace, stopMarkersConfig, stopMarkersTrace, StopMarkers, StopMarkersTrace, currentUserConfig, currentUserTrace, CurrentUser, CurrentUserTrace, ActionsHeatmap, ActionsHeatmapTrace, StopsHeatmap, StopsHeatmapTrace, ActionsCluster, ActionsClusterTrace, DestinationMap, DestinationMarker, CompoundDataObservableMixin, AnimationMixin, CircleMixin, ClusterMixin, DataObservableMixin, DivMarkersMixin, ExtendBoundsMixin, HeatmapMixin, MarkersMixin, PolylinesMixin, PopupMixin, SingleItemMixin, StyleMixin, TraceMixin, ActionMap, ActionTrace };
