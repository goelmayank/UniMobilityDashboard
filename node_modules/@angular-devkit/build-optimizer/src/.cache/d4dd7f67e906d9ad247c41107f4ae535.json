{"remainingRequest":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Github/UniDashboard/node_modules/time-aware-polyline/dist/time-aware-polyline.es5.js","dependencies":[{"path":"/Github/UniDashboard/node_modules/time-aware-polyline/dist/time-aware-polyline.es5.js","mtime":1519922767000},{"path":"/Github/UniDashboard/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var TimeAwareEncoder = /*@__PURE__*/ (function () {\n    function TimeAwareEncoder() {\n    }\n    TimeAwareEncoder.prototype.encodeTimeAwarePolyline = function (points) {\n        return this.extendTimeAwarePolyline(\"\", points, null);\n    };\n    TimeAwareEncoder.prototype.decodeTimeAwarePolyline = function (polyline) {\n        // Method to decode a time aware encoder and return gpx logs\n        var gpxLogs = [];\n        var index = 0;\n        var lat = 0;\n        var lng = 0;\n        var timeStamp = 0;\n        var polylineLine = polyline.length;\n        while (index < polylineLine) {\n            // Decoding dimensions one by one\n            var latResult = this.getDecodedDimensionFromPolyline(polyline, index);\n            index = latResult[0];\n            var lngResult = this.getDecodedDimensionFromPolyline(polyline, index);\n            index = lngResult[0];\n            var timeResult = this.getDecodedDimensionFromPolyline(polyline, index);\n            index = timeResult[0];\n            // Resultant variables\n            lat += latResult[1];\n            lng += lngResult[1];\n            timeStamp += timeResult[1];\n            gpxLogs.push(this.getGpxLog(lat, lng, timeStamp));\n        }\n        return gpxLogs;\n    };\n    TimeAwareEncoder.prototype.getLocationsAtTimestamps = function (decodedTimeAwarePolyline, timeStamps) {\n        var index = 0, locations = [];\n        for (index = 0; index < timeStamps.length; index++) {\n            var locationsAndBearing = this.getLocationsTillTimeStamp(decodedTimeAwarePolyline, timeStamps[index]);\n            var locationsFound = locationsAndBearing.locations;\n            if (locationsFound.length > 0) {\n                locations.push(locationsFound[locationsFound.length - 1]);\n            }\n            else {\n                locations.push([]);\n            }\n        }\n        return locations;\n    };\n    TimeAwareEncoder.prototype.getLocationsElapsedByTimestamp = function (decodedTimeAwarePolyline, timeStamp) {\n        var locationsAndBearing = this.getLocationsTillTimeStamp(decodedTimeAwarePolyline, timeStamp);\n        return { 'path': locationsAndBearing.locations, 'bearing': locationsAndBearing.bearing };\n    };\n    TimeAwareEncoder.prototype.getPolylineSegmentsPublic = function (decodedTimeAwarePolyline) {\n        var lastTimeStamp = decodedTimeAwarePolyline[decodedTimeAwarePolyline.length - 1][2];\n        var polylineSegments = this.getPolylineSegments(decodedTimeAwarePolyline, lastTimeStamp);\n        var result = [];\n        for (var i = 0; i < polylineSegments.length; i++) {\n            result.push({ 'path': this.removeTimeStamps(polylineSegments[i].segment), 'style': polylineSegments[i].style });\n        }\n        return result;\n    };\n    TimeAwareEncoder.prototype.getPolylineSegmentsForLocationsElapsed = function (decodedTimeAwarePolyline, timeStamp) {\n        var polylineSegments = this.getPolylineSegments(decodedTimeAwarePolyline, timeStamp);\n        var result = [];\n        for (var i = 0; i < polylineSegments.length; i++) {\n            var elapsed = this.getLocationsElapsedByTimestamp(polylineSegments[i].segment, timeStamp);\n            if (elapsed.path.length > 0) {\n                result.push({\n                    'path': elapsed.path, 'bearing': elapsed.bearing, 'style': polylineSegments[i].style\n                });\n            }\n        }\n        return result;\n    };\n    /*\n    Other\n     */\n    TimeAwareEncoder.prototype.getLocationsTillTimeStamp = function (decodedPolyline, timeStamp) {\n        var decoded = decodedPolyline;\n        // decoded and timeStamps are both in order of times\n        var index = 0;\n        var currentPair = [];\n        var locationsElapsed = [];\n        var bearing = 0;\n        if (decoded.length == 0) {\n            return { 'locations': [], 'bearing': bearing };\n        }\n        // remove times before first time\n        var timeStampToFind = timeStamp, startTime = decoded[0][2];\n        while (timeStampToFind <= startTime) {\n            return { 'locations': [[decoded[0][0], decoded[0][1]]], 'bearing': bearing };\n        }\n        for (index = 0; index < decoded.length; index++) {\n            currentPair.push(decoded[index]);\n            if (currentPair.length == 2) {\n                var timeStampToFind = timeStamp;\n                bearing = this.updateBearing(bearing, currentPair);\n                var currentstartTime = currentPair[0][2], endTime = currentPair[1][2];\n                if (timeStampToFind > currentstartTime && timeStampToFind <= endTime) {\n                    // location is in the current pair\n                    var midLocation = this.getLocationInPair(currentPair, timeStampToFind);\n                    locationsElapsed.push(midLocation);\n                    return { 'locations': locationsElapsed, 'bearing': bearing };\n                    // it is possible that the next timestamp is also in the\n                    // same pair, hence redo-ing same iteration\n                    // currentPair.pop();\n                    // index --;\n                }\n                else {\n                    currentPair.shift();\n                }\n            }\n            locationsElapsed.push([currentPair[0][0], currentPair[0][1]]);\n        }\n        return { 'locations': locationsElapsed, 'bearing': bearing };\n    };\n    TimeAwareEncoder.prototype.isDifferentSegment = function (end, start) {\n        // function to determine whether a encoder\n        // segment split should happen\n        var distance = this.getDistance(start, end);\n        return distance > 500;\n    };\n    TimeAwareEncoder.prototype.getPolylineSegments = function (decoded, timeLimit) {\n        // this method breaks encoder till timeStamp when\n        // consecutive time difference is greater than 10 minutes\n        var segments = [], currentSegment = [];\n        var index = 0;\n        if (decoded.length == 0) {\n            return [];\n        }\n        var start = decoded[0];\n        for (index = 0; index < decoded.length; index++) {\n            if (decoded[index][2] <= timeLimit) {\n                if (this.isDifferentSegment(decoded[index], start) && currentSegment.length > 0) {\n                    // time difference is more than 10 mins, so flush\n                    segments.push({\n                        'segment': currentSegment, 'style': 'solid'\n                    });\n                    var lastElement = currentSegment[currentSegment.length - 1];\n                    currentSegment = [lastElement, decoded[index]];\n                    segments.push({\n                        'segment': currentSegment, 'style': 'dotted'\n                    });\n                    currentSegment = [decoded[index]];\n                }\n                else {\n                    currentSegment.push(decoded[index]);\n                }\n                start = decoded[index];\n            }\n            else {\n                // add one more location so that the locations elapsed\n                // method can find an interpolated midpoint\n                if (!this.isDifferentSegment(decoded[index], start)) {\n                    currentSegment.push(decoded[index]);\n                }\n                break;\n            }\n        }\n        segments.push({\n            'segment': currentSegment, 'style': 'solid'\n        });\n        return segments;\n    };\n    TimeAwareEncoder.prototype.updateBearing = function (oldBearing, gpxPair) {\n        var start = [gpxPair[0][0], gpxPair[0][1]];\n        var end = [gpxPair[1][0], gpxPair[1][1]];\n        var newBearing = this.computeHeading(start, end);\n        if (newBearing != 0) {\n            return Math.round(newBearing * 100) / 100.0;\n        }\n        else {\n            return oldBearing;\n        }\n    };\n    TimeAwareEncoder.prototype.getLocationInPair = function (gpxPair, timeStamp) {\n        // timeStamp lies between the timeStamps in the gpx logs\n        var startLat = gpxPair[0][0], startLng = gpxPair[0][1], endLat = gpxPair[1][0], endLng = gpxPair[1][1], startTime = new Date(gpxPair[0][2]), endTime = new Date(gpxPair[1][2]), currentTime = new Date(timeStamp);\n        var ratio = (+startTime - +currentTime) / (+startTime - +endTime);\n        return [startLat * (1 - ratio) + endLat * ratio, startLng * (1 - ratio) + endLng * ratio];\n    };\n    TimeAwareEncoder.prototype.getNextLatLng = function (decoded, timeStamp) {\n        var polylineLength = decoded.length;\n        if (polylineLength > 0) {\n            for (var index = 0; index < polylineLength - 1; index++) {\n                var currentTimeStamp = decoded[index][2];\n                if (timeStamp < currentTimeStamp) {\n                    return [decoded[index][0], decoded[index][1]];\n                }\n            }\n            return [decoded[polylineLength - 1][0], decoded[polylineLength - 1][1]];\n        }\n    };\n    TimeAwareEncoder.prototype.getDistance = function (origin, destination) {\n        // return distance in meters\n        var lon1 = this.toRadian(origin[1]), lat1 = this.toRadian(origin[0]), lon2 = this.toRadian(destination[1]), lat2 = this.toRadian(destination[0]);\n        var deltaLat = lat2 - lat1;\n        var deltaLon = lon2 - lon1;\n        var a = Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon / 2), 2);\n        var c = 2 * Math.asin(Math.sqrt(a));\n        return c * EARTH_RADIUS * 1000;\n    };\n    TimeAwareEncoder.prototype.toRadian = function (degree) {\n        return degree * Math.PI / 180;\n    };\n    TimeAwareEncoder.prototype.computeHeading = function (start, end) {\n        var lat1 = this.toRadian(start[0]);\n        var lat2 = this.toRadian(end[0]);\n        var lng1 = this.toRadian(start[1]);\n        var lng2 = this.toRadian(end[1]);\n        return Math.atan2(Math.sin(lng2 - lng1) * Math.cos(lat2), Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1)) * 180 / Math.PI;\n    };\n    TimeAwareEncoder.prototype.areEqualLatlngs = function (latlngA, latlngB) {\n        return (latlngA[0] == latlngB[0]) && (latlngA[1] == latlngB[1]);\n    };\n    TimeAwareEncoder.prototype.removeTimeStamps = function (segment) {\n        var result = [];\n        for (var i = 0; i < segment.length; i++) {\n            result.push([segment[i][0], segment[i][1]]);\n        }\n        return result;\n    };\n    /*\n    Helpers\n     */\n    TimeAwareEncoder.prototype.getDecodedDimensionFromPolyline = function (polyline, index) {\n        // Method to decode one dimension of the encoder\n        var result = 1;\n        var shift = 0;\n        while (true) {\n            var polylineChar = polyline[index];\n            var b = polylineChar.charCodeAt(0) - 63 - 1;\n            index++;\n            result += this.lshiftOperator(b, shift);\n            shift += 5;\n            if (b < 0x1f) {\n                break;\n            }\n        }\n        if ((result % 2) !== 0) {\n            return [index, this.rshiftOperator(this.notOperator(result), 1)];\n        }\n        else {\n            return [index, this.rshiftOperator(result, 1)];\n        }\n    };\n    TimeAwareEncoder.prototype.extendTimeAwarePolyline = function (polyline, points, lastPoint) {\n        var lastLat = 0, lastLng = 0, lastTimeStamp = 0;\n        if (polyline == null) {\n            polyline = '';\n        }\n        if (lastPoint != null) {\n            lastLat = this.getLat(lastPoint);\n            lastLng = this.getLng(lastPoint);\n            lastTimeStamp = this.getTimeStamp(lastPoint);\n        }\n        if (points.length < 1) {\n            return polyline;\n        }\n        for (var i = 0; i < points.length; i++) {\n            var currentGpxLog = points[i];\n            var lat = this.getLat(currentGpxLog);\n            var lng = this.getLng(currentGpxLog);\n            var timeStamp = this.getTimeStamp(currentGpxLog);\n            var diffArray = [lat - lastLat, lng - lastLng, timeStamp - lastTimeStamp];\n            for (var j = 0; j < diffArray.length; j++) {\n                var currentDiff = diffArray[j];\n                currentDiff = (currentDiff < 0) ? this.notOperator(this.lshiftOperator(currentDiff, 1)) : this.lshiftOperator(currentDiff, 1);\n                while (currentDiff >= 0x20) {\n                    polyline += String.fromCharCode((0x20 | (currentDiff & 0x1f)) + 63);\n                    currentDiff = this.rshiftOperator(currentDiff, 5);\n                }\n                polyline += String.fromCharCode(currentDiff + 63);\n            }\n            lastLat = lat, lastLng = lng, lastTimeStamp = timeStamp;\n        }\n        return polyline;\n    };\n    TimeAwareEncoder.prototype.getCoordinate = function (intRepresentation) {\n        var coordinate = intRepresentation * 0.00001;\n        return +coordinate.toFixed(5);\n    };\n    TimeAwareEncoder.prototype.getIsoTime = function (timeStamp) {\n        // timeStamp is in seconds\n        return new Date(timeStamp * 1000).toISOString();\n    };\n    TimeAwareEncoder.prototype.getGpxLog = function (lat, lng, timeStamp) {\n        return [\n            this.getCoordinate(lat), this.getCoordinate(lng), this.getIsoTime(timeStamp)\n        ];\n    };\n    TimeAwareEncoder.prototype.getLat = function (gpxLog) {\n        return Math.round(gpxLog[0] * 100000);\n    };\n    TimeAwareEncoder.prototype.getLng = function (gpxLog) {\n        return Math.round(gpxLog[1] * 100000);\n    };\n    TimeAwareEncoder.prototype.getTimeStamp = function (gpxLog) {\n        return +new Date(gpxLog[2]) / 1000;\n    };\n    TimeAwareEncoder.prototype.lshiftOperator = function (num, bits) {\n        // Custom left shift for 64 bit integers\n        return num * Math.pow(2, bits);\n    };\n    TimeAwareEncoder.prototype.rshiftOperator = function (num, bits) {\n        // Custom right shift for 64 bit integers\n        return Math.floor(num / Math.pow(2, bits));\n    };\n    TimeAwareEncoder.prototype.notOperator = function (num) {\n        // Custom not operator for 64 bit integers\n        return ~num;\n    };\n    return TimeAwareEncoder;\n}());\nvar EARTH_RADIUS = 6371;\nvar PolylineUtils = /*@__PURE__*/ (function () {\n    function PolylineUtils() {\n        this.encoder = new TimeAwareEncoder();\n    }\n    PolylineUtils.prototype.updateTimeAwarePolyline = function (encodedPolyline) {\n        if (this.isNewPolyline(encodedPolyline)) {\n            this.encodedPolyline = encodedPolyline;\n            this.timeAwarePolyline = this.encoder.decodeTimeAwarePolyline(this.encodedPolyline);\n        }\n    };\n    PolylineUtils.prototype.getPolylineToTime = function (timestamp) {\n        return this.encoder.getLocationsElapsedByTimestamp(this.timeAwarePolyline, timestamp);\n    };\n    PolylineUtils.prototype.getLatestTime = function () {\n        if (this.timeAwarePolyline) {\n            var lastI = this.timeAwarePolyline.length - 1;\n            return lastI > -1 ? this.timeAwarePolyline[lastI][2] : null;\n        }\n        else {\n            return null;\n        }\n    };\n    PolylineUtils.prototype.isNewPolyline = function (encodedPolyline) {\n        return encodedPolyline != this.encodedPolyline;\n    };\n    return PolylineUtils;\n}());\nvar TimeAwareAnimation = /*@__PURE__*/ (function () {\n    function TimeAwareAnimation() {\n        this.polylineUtils = new PolylineUtils();\n        this.animationSpeed = 20;\n        this.animationProps = { speedScale: 1, interval: 20 };\n        this.updateEvent = new CustomEvent();\n    }\n    /*\n    Update animation from encoded polyline string\n    */\n    TimeAwareAnimation.prototype.updatePolylineString = function (timeAwarePolylineString) {\n        var timeAwarePolyline = this.polylineUtils.encoder.decodeTimeAwarePolyline(timeAwarePolylineString);\n        this.update(timeAwarePolyline);\n    };\n    /*\n    Update animation from encoded time aware array [lat, lng, time]\n     */\n    TimeAwareAnimation.prototype.update = function (timeAwarePolyline) {\n        if (!timeAwarePolyline) {\n            this.clear();\n            return true;\n        }\n        this.polylineUtils.timeAwarePolyline = timeAwarePolyline;\n        if (!this.animationPoll)\n            this.handleAnimation(timeAwarePolyline);\n    };\n    TimeAwareAnimation.prototype.handleAnimation = function (timeAwarePolyline) {\n        var _this = this;\n        if (!timeAwarePolyline)\n            return;\n        if (this.animationPoll)\n            this.clearAnimationPoll();\n        this.updateCurrentTime();\n        this.setPathBearing();\n        this.animationPoll = setInterval(function () {\n            _this.updateCurrentTime();\n            _this.setPathBearing();\n        }, this.animationSpeed);\n    };\n    TimeAwareAnimation.prototype.updateCurrentTime = function () {\n        var _this = this;\n        if (this.currentTime) {\n            var timeToAdd = this.getTimeToAdd();\n            this.currentTime = this.addISOTime(this.currentTime, timeToAdd);\n        }\n        else {\n            var last = this.polylineUtils.getLatestTime();\n            var delay = new Date().getTime() - new Date(last).getTime();\n            var timeToAdd = delay > 15 * 60 * 1000 ? 0 : -20000;\n            this.currentTime = this.addISOTime(last, timeToAdd);\n        }\n        this.capTime(function () {\n            _this.clearAnimationPoll();\n        });\n    };\n    TimeAwareAnimation.prototype.setPathBearing = function () {\n        var _a = this.currentTimePolylineData(), path = _a.path, bearing = _a.bearing;\n        this.updatePathBearing(path, bearing);\n        this.updateEvent.publish('update', { path: path, bearing: bearing, time: this.currentTime });\n    };\n    TimeAwareAnimation.prototype.updatePathBearing = function (path, bearing) {\n    };\n    TimeAwareAnimation.prototype.capTime = function (callback) {\n        if (new Date(this.currentTime) > new Date(this.polylineUtils.getLatestTime())) {\n            this.currentTime = this.polylineUtils.getLatestTime();\n            if (callback && typeof callback == 'function')\n                callback();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TimeAwareAnimation.prototype.clearAnimationPoll = function () {\n        clearInterval(this.animationPoll);\n        this.animationPoll = null;\n    };\n    TimeAwareAnimation.prototype.getTimeToAdd = function () {\n        var lastTime = new Date(this.polylineUtils.getLatestTime()).getTime();\n        var currentTime = new Date(this.currentTime).getTime();\n        var totalDuration = (lastTime - currentTime) / 1000;\n        var factor = 1;\n        if (typeof totalDuration == 'number') {\n            var mid = 5;\n            var power = 2;\n            if (totalDuration > mid) {\n                factor = Math.pow(totalDuration, power) / Math.pow(mid, power);\n            }\n        }\n        return factor * this.animationProps.interval;\n    };\n    TimeAwareAnimation.prototype.currentTimePolylineData = function () {\n        var polylineData = this.polylineUtils.getPolylineToTime(this.currentTime);\n        var path = polylineData.path.map(function (array) {\n            return { lat: array[0], lng: array[1] };\n        });\n        return { path: path, bearing: polylineData.bearing };\n    };\n    TimeAwareAnimation.prototype.clear = function () {\n        this.clearAnimationPoll();\n    };\n    TimeAwareAnimation.prototype.addISOTime = function (time, timeToAdd) {\n        return new Date(new Date(time).getTime() + timeToAdd).toISOString();\n    };\n    return TimeAwareAnimation;\n}());\nvar CustomEvent = /*@__PURE__*/ (function () {\n    function CustomEvent() {\n        this.topics = {};\n        this.hOP = this.topics.hasOwnProperty;\n    }\n    CustomEvent.prototype.publish = function (topic, info) {\n        // If the topic doesn't exist, or there's no listeners in queue, just leave\n        if (!this.hOP.call(this.topics, topic))\n            return;\n        // Cycle through topics queue, fire!\n        this.topics[topic].forEach(function (item) {\n            item(info != undefined ? info : {});\n        });\n    };\n    CustomEvent.prototype.subscribe = function (topic, listener) {\n        // Create the topic's object if not yet created\n        if (!this.hOP.call(this.topics, topic))\n            this.topics[topic] = [];\n        // Add the listener to queue\n        var index = this.topics[topic].push(listener) - 1;\n        // Provide handle back for removal of topic\n        return {\n            unsubscribe: function () {\n                delete this.topics[topic][index];\n            }\n        };\n    };\n    return CustomEvent;\n}());\n// export interface IPathBearing {\n//   path: HtPosition[],\n//   bearing: number,\n// }\nexport { TimeAwareEncoder, EARTH_RADIUS, PolylineUtils, TimeAwareAnimation, CustomEvent };\n//# sourceMappingURL=time-aware-polyline.es5.js.map\n",null]}