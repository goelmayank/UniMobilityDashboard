{"remainingRequest":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Github/UniDashboard/node_modules/ht-maps/dist/ht-maps.es5.js","dependencies":[{"path":"/Github/UniDashboard/node_modules/ht-maps/dist/ht-maps.es5.js","mtime":0},{"path":"/Github/UniDashboard/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { filter, map, take } from 'rxjs/operators';\nimport { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';\nimport { each, filter as filter$1, map as map$1, reduce, values } from 'underscore';\nimport { fromEventPattern as fromEventPattern$1 } from 'rxjs/observable/fromEventPattern';\nimport { circleMarker, divIcon, heatLayer, latLng, latLngBounds, map as map$2, marker, markerClusterGroup, polyline, popup, tileLayer } from 'leaflet';\nimport 'leaflet.markercluster';\nimport 'leaflet.heat';\nimport { Color, DateString, HMString, HtCustomEvent, NameCase, TimeString } from 'ht-utility';\nimport { TimeAwareAnimation, TimeAwareEncoder } from 'time-aware-polyline';\nimport { combineLatest as combineLatest$1 } from 'rxjs/observable/combineLatest';\nimport { dataWithSelectedId$, htAction, htUser, orCombine } from 'ht-data';\nvar LightColorMapStyle = [\n    {\n        \"featureType\": \"all\",\n        \"elementType\": \"labels.text.fill\",\n        \"stylers\": [\n            {\n                \"saturation\": 36\n            },\n            {\n                \"color\": \"#333333\"\n            },\n            {\n                \"lightness\": 40\n            }\n        ]\n    },\n    {\n        \"featureType\": \"all\",\n        \"elementType\": \"labels.text.stroke\",\n        \"stylers\": [\n            {\n                \"visibility\": \"on\"\n            },\n            {\n                \"color\": \"#ffffff\"\n            },\n            {\n                \"lightness\": 16\n            }\n        ]\n    },\n    {\n        \"featureType\": \"all\",\n        \"elementType\": \"labels.icon\",\n        \"stylers\": [\n            {\n                \"visibility\": \"off\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"administrative\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"color\": \"#fefefe\"\n            },\n            {\n                \"lightness\": 20\n            }\n        ]\n    },\n    {\n        \"featureType\": \"administrative\",\n        \"elementType\": \"geometry.stroke\",\n        \"stylers\": [\n            {\n                \"color\": \"#fefefe\"\n            },\n            {\n                \"lightness\": 17\n            },\n            {\n                \"weight\": 1.2\n            }\n        ]\n    },\n    {\n        \"featureType\": \"administrative.country\",\n        \"elementType\": \"geometry.stroke\",\n        \"stylers\": [\n            {\n                \"color\": \"#dadada\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"administrative.province\",\n        \"elementType\": \"geometry.stroke\",\n        \"stylers\": [\n            {\n                \"color\": \"#cfcfcf\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"landscape\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#f5f5f5\"\n            },\n            {\n                \"lightness\": 20\n            }\n        ]\n    },\n    {\n        \"featureType\": \"landscape.man_made\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"color\": \"#ecedee\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"landscape.natural.landcover\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"saturation\": \"-14\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"landscape.natural.landcover\",\n        \"elementType\": \"geometry.stroke\",\n        \"stylers\": [\n            {\n                \"saturation\": \"-12\"\n            },\n            {\n                \"lightness\": \"60\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"landscape.natural.terrain\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"color\": \"#dbe5da\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"poi\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#f5f5f5\"\n            },\n            {\n                \"lightness\": 21\n            }\n        ]\n    },\n    {\n        \"featureType\": \"poi.park\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#dedede\"\n            },\n            {\n                \"lightness\": 21\n            }\n        ]\n    },\n    {\n        \"featureType\": \"poi.park\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"color\": \"#e2f0e0\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road.highway\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            },\n            {\n                \"lightness\": 17\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road.highway\",\n        \"elementType\": \"geometry.stroke\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            },\n            {\n                \"lightness\": 29\n            },\n            {\n                \"weight\": 0.2\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road.arterial\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            },\n            {\n                \"lightness\": 18\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road.local\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            },\n            {\n                \"lightness\": 16\n            }\n        ]\n    },\n    {\n        \"featureType\": \"transit\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#f2f2f2\"\n            },\n            {\n                \"lightness\": 19\n            }\n        ]\n    },\n    {\n        \"featureType\": \"water\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#e9e9e9\"\n            },\n            {\n                \"lightness\": 17\n            }\n        ]\n    },\n    {\n        \"featureType\": \"water\",\n        \"elementType\": \"geometry.fill\",\n        \"stylers\": [\n            {\n                \"saturation\": \"6\"\n            },\n            {\n                \"gamma\": \"4.20\"\n            },\n            {\n                \"lightness\": \"72\"\n            },\n            {\n                \"color\": \"#d9e5eb\"\n            }\n        ]\n    }\n];\nvar __assign$1 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar GoogleMapUtilsClass = /*@__PURE__*/ (function () {\n    function GoogleMapUtilsClass() {\n        this.type = 'google';\n        this.defaultMapOptions = {\n            center: { lat: 0, lng: 0 },\n            zoom: 2,\n            fullscreenControl: false,\n            streetViewControl: false,\n            styles: LightColorMapStyle\n        };\n        this.setStyle = function (item, style) {\n            item.setOptions(style);\n        };\n    }\n    GoogleMapUtilsClass.prototype.setDefaultMapOptions = function (options) {\n        this.defaultMapOptions = __assign$1({}, this.defaultMapOptions, options);\n    };\n    GoogleMapUtilsClass.prototype.renderMap = function (elem, options) {\n        options = __assign$1({}, options, this.defaultMapOptions);\n        return new google.maps.Map(elem, options);\n    };\n    GoogleMapUtilsClass.prototype.setKey = function (key) {\n        if (document) {\n            this.loadGoogleMaps(key, function () {\n                // this.loadMarkerCluster();\n                // this.loadRichMarker();\n            });\n            return true;\n        }\n        return false;\n    };\n    GoogleMapUtilsClass.prototype.loadGoogleMaps = function (key, cb) {\n        var url = \"https://maps.googleapis.com/maps/api/js?key=\" + key + \"&libraries=geometry,visualization\";\n        this.loadScript(url, cb);\n    };\n    GoogleMapUtilsClass.prototype.loadMarkerCluster = function () {\n        // const url = \"https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js\";\n        // this.loadScript(url)\n        // import(\"./markerclusterer\")\n    };\n    GoogleMapUtilsClass.prototype.loadRichMarker = function () {\n        // const url = \"http://googlemaps.github.io/js-rich-marker/src/richmarker-compiled.js\";\n        // this.loadScript(url)\n        // import(\"./richmarker\")\n    };\n    GoogleMapUtilsClass.prototype.loadScript = function (url, cb) {\n        var script = document.createElement(\"script\");\n        script.src = url;\n        if (cb)\n            script.onload = cb();\n        document.head.appendChild(script);\n    };\n    GoogleMapUtilsClass.prototype.updatePositionPopup = function (marker$$1, position, infoContent, defaultOption) {\n        if (defaultOption === void 0) {\n            defaultOption = {};\n        }\n        marker$$1.setPosition(position);\n        this.updatePopup(marker$$1, infoContent, defaultOption);\n    };\n    GoogleMapUtilsClass.prototype.updatePopup = function (marker$$1, infoContent, defaultOption) {\n        // if(marker.getPopup()) {\n        //   marker.setPopupContent(infoContent)\n        // } else {\n        //   marker.bindPopup(infoContent, defaultOption);\n        // }\n    };\n    GoogleMapUtilsClass.prototype.setMap = function (item, map$$1) {\n        if (!map$$1) {\n            item.setMap(null);\n        }\n        else if ((item && !item.getMap) || (item && !item.getMap())) {\n            item.setMap(map$$1);\n        }\n    };\n    GoogleMapUtilsClass.prototype.clearItem = function (item) {\n        item.setMap(null);\n    };\n    GoogleMapUtilsClass.prototype.updatePosition = function (marker$$1, position, infoContent, defaultOption) {\n        if (infoContent === void 0) {\n            infoContent = \"\";\n        }\n        if (defaultOption === void 0) {\n            defaultOption = {};\n        }\n        position = this.getLatlng(position);\n        marker$$1.setPosition(position);\n        // if(infoContent) HtUpdateTooltip(marker, infoContent, defaultOption)\n    };\n    GoogleMapUtilsClass.prototype.updateTooltip = function (marker$$1, infoContent, defaultOption) {\n        // if(marker.getTooltip()) {\n        //   marker.setTooltipContent(infoContent)\n        // } else {\n        //   marker.bindTooltip(infoContent, defaultOption);\n        // }\n    };\n    GoogleMapUtilsClass.prototype.setCircleStyle = function (item, style) {\n        var circleStyle = __assign$1({}, style, { icon: __assign$1({}, style.icon, { path: google.maps.SymbolPath.CIRCLE }) });\n        this.setStyle(item, circleStyle);\n    };\n    GoogleMapUtilsClass.prototype.setPolylineStyle = function (polyline$$1, style) {\n        this.setStyle(polyline$$1, style);\n    };\n    GoogleMapUtilsClass.prototype.openTooltip = function (item, content) {\n        // if(content) item.setTooltipContent(content);\n        // item.openTooltip()\n    };\n    GoogleMapUtilsClass.prototype.closeTooltip = function (item) {\n        // item.closeTooltip()\n    };\n    GoogleMapUtilsClass.prototype.openPopup = function (item, map$$1, content, popup$$1) {\n        if (popup$$1) {\n            popup$$1.setContent(content);\n            // console.log(item.getPosition().lat());\n            popup$$1.open(map$$1, item);\n        }\n        // if(content) item.setPopupContent(content);\n        // item.openPopup()\n    };\n    GoogleMapUtilsClass.prototype.closePopup = function (item) {\n        // item.closePopup()\n    };\n    GoogleMapUtilsClass.prototype.bringToFront = function (item) {\n        // item.bringToFront()\n    };\n    GoogleMapUtilsClass.prototype.setFocus = function (item, map$$1, _a) {\n        var zoom = _a.zoom, _b = _a.force, force = _b === void 0 ? false : _b, center = _a.center;\n        if ((item && item.getMap()) || force) {\n            var markerCenter = this.getItemLatlng(item);\n            if (center)\n                map$$1.setCenter(markerCenter);\n            if (zoom && center)\n                map$$1.setZoom(zoom);\n            // item.setAnimation(google.maps.Animation.DROP);\n            // setTimeout(() => {\n            //   item.setAnimation(null);\n            //\n            // }, 1000)\n        }\n    };\n    GoogleMapUtilsClass.prototype.getItemLatlng = function (item) {\n        return item.getPosition();\n    };\n    GoogleMapUtilsClass.prototype.updateCirclePosition = function (circle, position) {\n        circle.setCenter(position);\n    };\n    GoogleMapUtilsClass.prototype.extendBounds = function (position, bounds) {\n        if (bounds === void 0) {\n            bounds = new google.maps.LatLngBounds();\n        }\n        var latlng = this.getLatlng(position);\n        bounds.extend(latlng);\n        return bounds;\n    };\n    GoogleMapUtilsClass.prototype.getCircleMarker = function () {\n        return new google.maps.Marker();\n    };\n    GoogleMapUtilsClass.prototype.getMarker = function () {\n        return new google.maps.Marker();\n    };\n    GoogleMapUtilsClass.prototype.getMarkerCluster = function (map$$1) {\n        // console.log(\"get\", map);\n        return new MarkerClusterer(map$$1, [], {\n            imagePath: \"https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m\"\n        });\n    };\n    GoogleMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {\n        cluster.clearMarkers();\n    };\n    GoogleMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker$$1) {\n        cluster.removeMarker(marker$$1);\n    };\n    GoogleMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers, map$$1) {\n        // if(listAll.length) console.log(map, \"map\", listAll[0]);\n        // cluster.setMap(map);\n        var clusterMarkers = cluster.getMarkers();\n        markers.forEach(function (marker$$1) {\n            // if(markerEntity[marker['id']]) {\n            //\n            // } else {\n            //   cluster.addMarker(marker)\n            // }\n            //alternate aproach\n            if (clusterMarkers.indexOf && clusterMarkers.indexOf(marker$$1) > -1) {\n            }\n            else {\n                cluster.addMarker(marker$$1);\n            }\n        });\n        // var hasId = clusterMarkers && clusterMarkers.length && clusterMarkers[0]['id'];\n        // if(hasId) {\n        //   let markerEntity = _.indexBy(clusterMarkers, 'id');\n        //   listAll.forEach((marker) => {\n        //     if(markerEntity[marker['id']]) {\n        //\n        //     } else {\n        //       cluster.addMarker(marker)\n        //     }\n        //   })\n        // } else {\n        //   _.each(listAll, (marker) => {\n        //     // console.log(marker.getPosition().lng());\n        //     cluster.removeMarker(marker);\n        //     cluster.addMarker(marker)\n        //     // if(marker.getPosition()) {\n        //     //   console.log(\"hit\", marker);\n        //     //   cluster.addMarker(marker)\n        //     // }\n        //   })\n        // }\n        // cluster.addMarkers(listAll)\n        // this.markerCluster.addLayers(listAll);\n        // this.markerCluster.refreshClusters(listAll);\n    };\n    GoogleMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {\n        if (item === void 0) {\n            item = null;\n        }\n        if (force === void 0) {\n            force = false;\n        }\n        bounds = bounds || new google.maps.LatLngBounds();\n        if (force || (item && item.getMap() && item.getPosition)) {\n            var p = item.getPosition();\n            var l = { lat: p.lat(), lng: p.lng() };\n            bounds.extend(l);\n        }\n        if (item && item.getMap() && item.getCenter) {\n            bounds.extend(item.getCenter());\n        }\n        return bounds;\n    };\n    GoogleMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline$$1, bounds) {\n        if (polyline$$1 === void 0) {\n            polyline$$1 = null;\n        }\n        if (bounds === void 0) {\n            bounds = new google.maps.LatLngBounds();\n        }\n        if (polyline$$1 && polyline$$1.getMap()) {\n            each(polyline$$1.getPath().getArray(), function (p) {\n                var l = { lat: p.lat(), lng: p.lng() };\n                bounds.extend(l);\n            });\n        }\n        return bounds;\n    };\n    GoogleMapUtilsClass.prototype.setEncodedPath = function (polyline$$1, encodedPolyline) {\n        var path = google.maps.geometry.encoding.decodePath(encodedPolyline);\n        return polyline$$1.setPath(path);\n    };\n    GoogleMapUtilsClass.prototype.getPopup = function (options) {\n        var defaultOption = {\n            disableAutoPan: true,\n            pixelOffset: new google.maps.Size(0, -37)\n        };\n        options = __assign$1({}, defaultOption, options);\n        return new google.maps.InfoWindow(options);\n    };\n    GoogleMapUtilsClass.prototype.getPolyline = function () {\n        return new google.maps.Polyline();\n    };\n    GoogleMapUtilsClass.prototype.setBounds = function (map$$1, bounds, padding) {\n        if (padding === void 0) {\n            padding = 0;\n        }\n        var newBounds = new google.maps.LatLngBounds(bounds.getSouthWest(), bounds.getNorthEast());\n        map$$1.fitBounds(newBounds);\n    };\n    GoogleMapUtilsClass.prototype.isValidBounds = function (bounds) {\n        // console.log(bounds);\n        // return !bounds.isEmpty()\n        return !this.getBoundsFix(bounds).isEmpty();\n    };\n    GoogleMapUtilsClass.prototype.getBoundsFix = function (bounds) {\n        return new google.maps.LatLngBounds(bounds.getSouthWest(), bounds.getNorthEast());\n    };\n    GoogleMapUtilsClass.prototype.invalidateSize = function (map$$1) {\n        google.maps.event.trigger(map$$1, \"resize\");\n    };\n    GoogleMapUtilsClass.prototype.onEvent$ = function (item, type) {\n        return fromEventPattern$1(this.mapEventHandler(item, type), this.removeHandler(item, type));\n    };\n    GoogleMapUtilsClass.prototype.mapEventHandler = function (item, type) {\n        var _this = this;\n        return function (handler) { return _this.onEvent(item, type, handler); };\n    };\n    GoogleMapUtilsClass.prototype.removeHandler = function (item, type) {\n        var _this = this;\n        return function (handler) { return _this.removeEvent(item, type, handler); };\n    };\n    GoogleMapUtilsClass.prototype.onEvent = function (item, event, cb) {\n        if (event == 'move')\n            event = 'bounds_changed';\n        item.addListener(event, function (e) {\n            cb(e);\n        });\n    };\n    GoogleMapUtilsClass.prototype.removeEvent = function (item, event, cb) {\n        if (event == 'move')\n            event = 'bounds_changed';\n        item.removeListener(event, function (e) {\n            cb(e);\n        });\n    };\n    GoogleMapUtilsClass.prototype.openPopupPosition = function (position, map$$1, content, popup$$1) {\n        popup$$1.setContent(content);\n        popup$$1.setPosition(this.getLatlng(position));\n        popup$$1.setMap(map$$1);\n    };\n    GoogleMapUtilsClass.prototype.setDivContent = function (marker$$1, content, options) {\n        var currentContent = marker$$1.getContent ? marker$$1.getContent() : null;\n        if (currentContent != content) {\n            marker$$1.setContent(content);\n            this.setDivMarkerStyle(marker$$1, options);\n        }\n    };\n    GoogleMapUtilsClass.prototype.getDivMarker = function () {\n        return new RichMarker({});\n    };\n    GoogleMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var zIndex = options.zIndex, flat = options.flat, anchor = options.anchor;\n        if (zIndex)\n            item.setZIndex(zIndex);\n        if (flat)\n            item.setFlat(flat);\n        if (anchor)\n            item.setAnchor(anchor);\n    };\n    GoogleMapUtilsClass.prototype.getHeatmap = function (options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var heatmap = new google.maps.visualization.HeatmapLayer(__assign$1({ data: [] }, options));\n        return heatmap;\n    };\n    GoogleMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {\n        var _this = this;\n        var latlngsPos = latlngs.map(function (pos) { return _this.getLatlng(pos); });\n        heatmap.setData(latlngsPos);\n    };\n    GoogleMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline$$1, positionTimeArray) {\n        var _this = this;\n        var path = map$1(positionTimeArray, function (point) {\n            return _this.getLatlng({ lat: +point[0], lng: +point[1] });\n        });\n        return polyline$$1.setPath(path);\n    };\n    GoogleMapUtilsClass.prototype.setPath = function (polyline$$1, path) {\n        var _this = this;\n        var newPath = path.map(function (pos) {\n            return _this.getLatlng(pos);\n        });\n        polyline$$1.setPath(newPath);\n    };\n    GoogleMapUtilsClass.prototype.getLatlng = function (_a) {\n        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;\n        return new google.maps.LatLng(lat, lng);\n    };\n    GoogleMapUtilsClass.prototype.getItemPosition = function (item) {\n        var position = item.getPosition();\n        return position ? { lat: position.lat(), lng: position.lng() } : null;\n    };\n    GoogleMapUtilsClass.prototype.getElement = function (item) {\n        return item ? item.markerWrapper_ : null;\n    };\n    return GoogleMapUtilsClass;\n}());\nvar defaultOptions = function (options) {\n    if (typeof options === 'number') {\n        // Legacy\n        options = {\n            precision: options\n        };\n    }\n    else {\n        options = options || {};\n    }\n    options.precision = options.precision || 5;\n    options.factor = options.factor || Math.pow(10, options.precision);\n    options.dimension = options.dimension || 2;\n    return options;\n};\nvar PolylineUtil = {\n    encode: function (points, options) {\n        options = defaultOptions(options);\n        var flatPoints = [];\n        for (var i = 0, len = points.length; i < len; ++i) {\n            var point = points[i];\n            if (options.dimension === 2) {\n                flatPoints.push(point.lat || point[0]);\n                flatPoints.push(point.lng || point[1]);\n            }\n            else {\n                for (var dim = 0; dim < options.dimension; ++dim) {\n                    flatPoints.push(point[dim]);\n                }\n            }\n        }\n        return this.encodeDeltas(flatPoints, options);\n    },\n    decode: function (encoded, options) {\n        options = defaultOptions(options);\n        var flatPoints = this.decodeDeltas(encoded, options);\n        var points = [];\n        for (var i = 0, len = flatPoints.length; i + (options.dimension - 1) < len;) {\n            var point = [];\n            for (var dim = 0; dim < options.dimension; ++dim) {\n                point.push(flatPoints[i++]);\n            }\n            points.push(point);\n        }\n        return points;\n    },\n    encodeDeltas: function (numbers, options) {\n        options = defaultOptions(options);\n        var lastNumbers = [];\n        for (var i = 0, len = numbers.length; i < len;) {\n            for (var d = 0; d < options.dimension; ++d, ++i) {\n                var num = numbers[i];\n                var delta = num - (lastNumbers[d] || 0);\n                lastNumbers[d] = num;\n                numbers[i] = delta;\n            }\n        }\n        return this.encodeFloats(numbers, options);\n    },\n    decodeDeltas: function (encoded, options) {\n        options = defaultOptions(options);\n        var lastNumbers = [];\n        var numbers = this.decodeFloats(encoded, options);\n        for (var i = 0, len = numbers.length; i < len;) {\n            for (var d = 0; d < options.dimension; ++d, ++i) {\n                numbers[i] = Math.round((lastNumbers[d] = numbers[i] + (lastNumbers[d] || 0)) * options.factor) / options.factor;\n            }\n        }\n        return numbers;\n    },\n    encodeFloats: function (numbers, options) {\n        options = defaultOptions(options);\n        for (var i = 0, len = numbers.length; i < len; ++i) {\n            numbers[i] = Math.round(numbers[i] * options.factor);\n        }\n        return this.encodeSignedIntegers(numbers);\n    },\n    decodeFloats: function (encoded, options) {\n        options = defaultOptions(options);\n        var numbers = this.decodeSignedIntegers(encoded);\n        for (var i = 0, len = numbers.length; i < len; ++i) {\n            numbers[i] /= options.factor;\n        }\n        return numbers;\n    },\n    encodeSignedIntegers: function (numbers) {\n        for (var i = 0, len = numbers.length; i < len; ++i) {\n            var num = numbers[i];\n            numbers[i] = (num < 0) ? ~(num << 1) : (num << 1);\n        }\n        return this.encodeUnsignedIntegers(numbers);\n    },\n    decodeSignedIntegers: function (encoded) {\n        var numbers = this.decodeUnsignedIntegers(encoded);\n        for (var i = 0, len = numbers.length; i < len; ++i) {\n            var num = numbers[i];\n            numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);\n        }\n        return numbers;\n    },\n    encodeUnsignedIntegers: function (numbers) {\n        var encoded = '';\n        for (var i = 0, len = numbers.length; i < len; ++i) {\n            encoded += this.encodeUnsignedInteger(numbers[i]);\n        }\n        return encoded;\n    },\n    decodeUnsignedIntegers: function (encoded) {\n        var numbers = [];\n        var current = 0;\n        var shift = 0;\n        for (var i = 0, len = encoded.length; i < len; ++i) {\n            var b = encoded.charCodeAt(i) - 63;\n            current |= (b & 0x1f) << shift;\n            if (b < 0x20) {\n                numbers.push(current);\n                current = 0;\n                shift = 0;\n            }\n            else {\n                shift += 5;\n            }\n        }\n        return numbers;\n    },\n    encodeSignedInteger: function (num) {\n        num = (num < 0) ? ~(num << 1) : (num << 1);\n        return this.encodeUnsignedInteger(num);\n    },\n    // This function is very similar to Google's, but I added\n    // some stuff to deal with the double slash issue.\n    encodeUnsignedInteger: function (num) {\n        var value, encoded = '';\n        while (num >= 0x20) {\n            value = (0x20 | (num & 0x1f)) + 63;\n            encoded += (String.fromCharCode(value));\n            num >>= 5;\n        }\n        value = num + 63;\n        encoded += (String.fromCharCode(value));\n        return encoded;\n    }\n};\nvar markerCluster = function () {\n    // console.log(L.MarkerClusterGroup);\n    return markerClusterGroup();\n};\nvar leafletHeat = function (latlng, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    // console.log(L.MarkerClusterGroup);\n    return heatLayer(latlng, options);\n};\nvar __assign$2 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar LeafletMapUtilsClass = /*@__PURE__*/ (function () {\n    function LeafletMapUtilsClass() {\n        this.type = 'leaflet';\n        this.defaultMapOptions = {\n            center: [3.505, 0],\n            zoom: 2,\n            tileLayerUrl: \"http://{s}.tile.osm.org/{z}/{x}/{y}.png\",\n            tileLayerOptions: {\n                attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n            }\n        };\n    }\n    LeafletMapUtilsClass.prototype.setDefaultMapOptions = function (options) {\n        this.defaultMapOptions = __assign$2({}, this.defaultMapOptions, options);\n    };\n    LeafletMapUtilsClass.prototype.renderMap = function (elem, options) {\n        options = __assign$2({}, options, this.defaultMapOptions);\n        var newmap = map$2(elem, options);\n        if (options.tileLayerUrl) {\n            tileLayer(options.tileLayerUrl, options.tileLayerOptions || {}).addTo(newmap);\n        }\n        return newmap;\n    };\n    LeafletMapUtilsClass.prototype.setMap = function (item, map$$1) {\n        if (((item && !item.getElement) || (item && !item.getElement())) && map$$1.getContainer().offsetWidth) {\n            item.addTo(map$$1);\n        }\n    };\n    LeafletMapUtilsClass.prototype.setKey = function (key) {\n        return true;\n    };\n    LeafletMapUtilsClass.prototype.setStyle = function (item, style) {\n        if (item.setStyle)\n            item.setStyle(style);\n    };\n    LeafletMapUtilsClass.prototype.setCircleStyle = function (item, style) {\n        this.setStyle(item, style);\n    };\n    LeafletMapUtilsClass.prototype.setPolylineStyle = function (polyline$$1, style) {\n        polyline$$1.setStyle(style);\n    };\n    LeafletMapUtilsClass.prototype.clearItem = function (item) {\n        item.remove();\n        item.off();\n    };\n    LeafletMapUtilsClass.prototype.extendItemBounds = function (item, bounds, force) {\n        if (item === void 0) {\n            item = null;\n        }\n        if (bounds === void 0) {\n            bounds = latLngBounds([]);\n        }\n        if (force === void 0) {\n            force = false;\n        }\n        if (force || (item && !item.getElement) || (item && item.getElement()))\n            bounds.extend(item.getLatLng());\n        return bounds;\n    };\n    LeafletMapUtilsClass.prototype.extendBounds = function (position, bounds) {\n        if (bounds === void 0) {\n            bounds = latLngBounds([]);\n        }\n        var latlng = this.getLatlng(position);\n        bounds.extend(latlng);\n        return bounds;\n    };\n    LeafletMapUtilsClass.prototype.extendBoundsWithPolyline = function (polyline$$1, bounds) {\n        if (polyline$$1 === void 0) {\n            polyline$$1 = null;\n        }\n        if (bounds === void 0) {\n            bounds = latLngBounds([]);\n        }\n        if (polyline$$1 && polyline$$1.getElement()) {\n            bounds.extend(polyline$$1.getBounds());\n        }\n        return bounds;\n    };\n    LeafletMapUtilsClass.prototype.getLatlng = function (_a) {\n        var _b = _a === void 0 ? { lat: 0, lng: 0 } : _a, lat = _b.lat, lng = _b.lng;\n        return latLng(lat, lng);\n    };\n    LeafletMapUtilsClass.prototype.updatePosition = function (marker$$1, position, infoContent, defaultOption) {\n        if (infoContent === void 0) {\n            infoContent = \"\";\n        }\n        if (defaultOption === void 0) {\n            defaultOption = {};\n        }\n        var latLng$$1 = this.getLatlng(position);\n        marker$$1.setLatLng(latLng$$1);\n        if (infoContent)\n            this.updateTooltip(marker$$1, infoContent, defaultOption);\n    };\n    LeafletMapUtilsClass.prototype.updateTooltip = function (marker$$1, infoContent, defaultOption) {\n        if (marker$$1.getTooltip()) {\n            marker$$1.setTooltipContent(infoContent);\n        }\n        else {\n            marker$$1.bindTooltip(infoContent, defaultOption);\n        }\n    };\n    LeafletMapUtilsClass.prototype.openTooltip = function (item, content) {\n        if (content)\n            item.setTooltipContent(content);\n        item.openTooltip();\n    };\n    LeafletMapUtilsClass.prototype.closeTooltip = function (item) {\n        item.closeTooltip();\n    };\n    LeafletMapUtilsClass.prototype.openPopup = function (item, map$$1, content) {\n        if (content)\n            item.setPopupContent(content);\n        item.openPopup();\n    };\n    LeafletMapUtilsClass.prototype.closePopup = function (item) {\n        item.closePopup();\n    };\n    LeafletMapUtilsClass.prototype.bringToFront = function (item) {\n        item.bringToFront();\n    };\n    LeafletMapUtilsClass.prototype.setFocus = function (item, map$$1, config) {\n        if ((item && item.getElement()) || config.force) {\n            var markerCenter = this.getItemLatlng(item);\n            if (config.center)\n                map$$1.panTo(markerCenter, { animate: true, duration: 1 });\n            if (config.zoom && config.center)\n                map$$1.setView(markerCenter, config.zoom);\n        }\n    };\n    LeafletMapUtilsClass.prototype.getItemLatlng = function (item) {\n        return item.getLatLng();\n    };\n    LeafletMapUtilsClass.prototype.updateCirclePosition = function (circle, position, infoContent, defaultOption) {\n        if (infoContent === void 0) {\n            infoContent = \"\";\n        }\n        if (defaultOption === void 0) {\n            defaultOption = {};\n        }\n        this.updatePosition(circle, position, infoContent, defaultOption);\n    };\n    LeafletMapUtilsClass.prototype.getCircleMarker = function () {\n        return circleMarker([0, 0]);\n    };\n    LeafletMapUtilsClass.prototype.getMarker = function () {\n        return marker([0, 0]);\n    };\n    LeafletMapUtilsClass.prototype.getMarkerCluster = function (map$$1) {\n        var cluster = markerCluster();\n        map$$1.addLayer(cluster);\n        return cluster;\n    };\n    LeafletMapUtilsClass.prototype.removeClusterMarkers = function (cluster) {\n        cluster.clearLayers();\n    };\n    LeafletMapUtilsClass.prototype.removeClusterMarker = function (cluster, marker$$1) {\n        cluster.removeLayer(marker$$1);\n    };\n    LeafletMapUtilsClass.prototype.addMarkersToCluster = function (cluster, markers) {\n        var marker$$1 = markers[0];\n        cluster.addLayers(markers);\n        cluster.refreshClusters(markers);\n    };\n    LeafletMapUtilsClass.prototype.getPolyline = function () {\n        return polyline([]);\n    };\n    LeafletMapUtilsClass.prototype.setBounds = function (map$$1, bounds, options) {\n        if (map$$1 && map$$1.getContainer() && map$$1.getContainer().offsetWidth) {\n            if (options.toFly) {\n                map$$1.flyToBounds(bounds, options);\n            }\n            else {\n                map$$1.fitBounds(bounds, options);\n            }\n        }\n    };\n    LeafletMapUtilsClass.prototype.isValidBounds = function (bounds) {\n        return bounds.isValid();\n    };\n    LeafletMapUtilsClass.prototype.invalidateSize = function (map$$1) {\n        if (map$$1 && map$$1.getContainer().offsetWidth) {\n            map$$1.invalidateSize();\n        }\n    };\n    LeafletMapUtilsClass.prototype.getPopup = function (options) {\n        return popup(options);\n    };\n    LeafletMapUtilsClass.prototype.onEvent$ = function (item, type) {\n        return fromEventPattern$1(this.mapEventHandler(item, type), this.removeHandler(item, type));\n    };\n    LeafletMapUtilsClass.prototype.mapEventHandler = function (item, type) {\n        var _this = this;\n        return function (handler) { return _this.onEvent(item, type, handler); };\n    };\n    LeafletMapUtilsClass.prototype.removeHandler = function (item, type) {\n        var _this = this;\n        return function (handler) { return _this.removeEvent(item, type, handler); };\n    };\n    LeafletMapUtilsClass.prototype.onEvent = function (item, event, cb) {\n        item.on(event, function (e) {\n            cb(e);\n        });\n    };\n    LeafletMapUtilsClass.prototype.removeEvent = function (item, event, cb) {\n        item.off(event, function (e) {\n            cb(e);\n        });\n    };\n    LeafletMapUtilsClass.prototype.openPopupPosition = function (position, map$$1, content, popup$$1) {\n        popup$$1\n            .setLatLng(position)\n            .setContent(content)\n            .openOn(map$$1);\n    };\n    LeafletMapUtilsClass.prototype.setDivContent = function (marker$$1, content, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var currentContent = marker$$1.options.icon ? marker$$1.options.icon.options.html : \"\";\n        if (content != currentContent) {\n            this.setDivMarkerStyle(marker$$1, __assign$2({ html: content }, options));\n            options['zIndexOffset'] && marker$$1.setZIndexOffset(options['zIndexOffset']);\n        }\n        // console.error('set div content not implemented')\n    };\n    LeafletMapUtilsClass.prototype.getDivMarker = function () {\n        return this.getMarker();\n    };\n    LeafletMapUtilsClass.prototype.setDivMarkerStyle = function (item, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var icon = divIcon(options);\n        this.setIcons(item, icon);\n    };\n    LeafletMapUtilsClass.prototype.setIcons = function (marker$$1, icon) {\n        marker$$1.setIcon(icon);\n    };\n    LeafletMapUtilsClass.prototype.getHeatmap = function (options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return leafletHeat([], options);\n    };\n    LeafletMapUtilsClass.prototype.updateHeatMapLatlng = function (latlngs, heatmap) {\n        var latlngArray = latlngs.map(function (pos) { return ([pos.lat, pos.lng, pos.weight || 1]); });\n        heatmap.setLatLngs(latlngArray);\n    };\n    LeafletMapUtilsClass.prototype.setEncodedPath = function (polyline$$1, encodedPolyline) {\n        var path = PolylineUtil.decode(encodedPolyline);\n        return polyline$$1.setLatLngs(path);\n    };\n    LeafletMapUtilsClass.prototype.setPath = function (polyline$$1, path) {\n        var _this = this;\n        path = path.map(function (pos) {\n            return _this.getLatlng(pos);\n        });\n        polyline$$1.setLatLngs(path);\n    };\n    LeafletMapUtilsClass.prototype.setPathPositionTimeArray = function (polyline$$1, positionTimeArray) {\n        return polyline$$1.setLatLngs(positionTimeArray);\n    };\n    LeafletMapUtilsClass.prototype.getItemPosition = function (item) {\n        var position = item.getLatLng();\n        return position ? { lat: position.lat, lng: position.lng } : null;\n    };\n    LeafletMapUtilsClass.prototype.getElement = function (item) {\n        return item ? item.getElement() : null;\n    };\n    return LeafletMapUtilsClass;\n}());\nvar mapTypeService = (function () {\n    var instance;\n    var currentmapType;\n    function getMapType(mapType) {\n        switch (mapType) {\n            case 'leaflet': {\n                return new LeafletMapUtilsClass();\n            }\n            case 'google': {\n                return new GoogleMapUtilsClass();\n            }\n            default: {\n                return new GoogleMapUtilsClass();\n            }\n        }\n    }\n    return {\n        getInstance: function (mapType) {\n            if (!instance || !currentmapType) {\n                currentmapType = mapType;\n                instance = getMapType(mapType);\n            }\n            return instance;\n        }\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar MapInstance = /*@__PURE__*/ (function () {\n    function MapInstance() {\n        var _this = this;\n        // mapUtils: MapUtils = null;\n        this.map = null;\n        this.map$ = new ReplaySubject$1();\n        this.clusters = [];\n        this.poppers = [];\n        this.itemsSet = [];\n        // mapType: HtMapType;\n        this.leafletSetBoundsOptions = {\n            animate: true,\n            duration: 0.3\n        };\n        this.googleSetBoundsOptions = {};\n        this.map$.subscribe(function (map$$1) {\n            _this.map = map$$1;\n        });\n    }\n    Object.defineProperty(MapInstance.prototype, \"mapUtils\", {\n        get: function () {\n            return mapTypeService.getInstance();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MapInstance.prototype, \"mapType\", {\n        get: function () {\n            return mapTypeService.getInstance().mapType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MapInstance.prototype.addToItemsSet = function (item) {\n        var i = this.itemsSet.indexOf(item);\n        if (i == -1)\n            this.itemsSet.push(item);\n    };\n    MapInstance.prototype.renderMap = function (elem, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var map$$1 = this.mapUtils.renderMap(elem, options);\n        this.setMap(map$$1);\n        return map$$1;\n    };\n    MapInstance.prototype.setMap = function (map$$1) {\n        this.map$.next(map$$1);\n    };\n    MapInstance.prototype.inValidateSize = function () {\n        this.mapUtils.invalidateSize(this.map);\n    };\n    // getMap() {\n    //   this.map$.take(1).subscribe(map => {\n    //     return map;\n    //   });\n    // }\n    MapInstance.prototype.setMapType = function (mapType, key) {\n        mapTypeService.getInstance(mapType);\n        if (key)\n            this.mapUtils.setKey(key);\n    };\n    MapInstance.prototype.addCluster = function (cluster) {\n        var _this = this;\n        if (!this.clusters.includes(cluster)) {\n            this.clusters.push(cluster);\n            this.map$.pipe(filter(function (data) { return !!data; }))\n                .subscribe(function (map$$1) {\n                cluster.cluster = _this.mapUtils.getMarkerCluster(map$$1);\n            });\n        }\n    };\n    MapInstance.prototype.addPopper = function (popper) {\n        if (!this.poppers.includes(popper)) {\n            this.poppers.push(popper);\n        }\n        if (!this.moveEvent) {\n            this.listenMove();\n        }\n    };\n    MapInstance.prototype.removePopper = function (popper) {\n        var i = this.poppers.indexOf(popper);\n        if (i > -1) {\n            this.poppers.splice(i, 1);\n        }\n    };\n    MapInstance.prototype.listenMove = function () {\n        var _this = this;\n        this.map$.pipe(filter(function (data) { return !!data; }), take(1)).subscribe(function (map$$1) {\n            _this.moveEvent = _this.mapUtils.onEvent(map$$1, 'move', function (e) {\n                _this.poppers.forEach(function (p) {\n                    p.scheduleUpdate();\n                });\n            });\n        });\n    };\n    MapInstance.prototype.getBounds = function (bounds, item) {\n        return item.extendBounds ? item.extendBounds(bounds) : null;\n    };\n    MapInstance.prototype.getItemsSetBounds = function (items) {\n        var _this = this;\n        var bounds = this.mapUtils.extendItemBounds();\n        return items.reduce(function (bounds, item) {\n            return _this.getBounds(bounds, item) || bounds;\n        }, bounds);\n    };\n    MapInstance.prototype.resetBounds = function (options) {\n        var _this = this;\n        if (this.resetBoundsTimeout)\n            clearTimeout(this.resetBoundsTimeout);\n        this.resetBoundsTimeout = setTimeout(function () {\n            var items = _this.itemsSet;\n            var bounds = _this.getItemsSetBounds(items);\n            if (bounds && _this.mapUtils.isValidBounds(bounds))\n                _this.setBounds(bounds, options);\n        }, 40);\n    };\n    MapInstance.prototype.setBounds = function (bounds, options) {\n        var map$$1 = this.map;\n        if (!map$$1)\n            return false;\n        var mapOptions = (this.mapType == \"leaflet\"\n            ? this.leafletSetBoundsOptions\n            : this.googleSetBoundsOptions);\n        options =\n            options || this.setBoundsOptions || mapOptions;\n        this.mapUtils.setBounds(map$$1 || this.map, bounds, __assign({}, mapOptions, options));\n    };\n    MapInstance.prototype.onEvent$ = function (type) {\n        return this.mapUtils.onEvent$(this.map, type);\n    };\n    MapInstance.prototype.mapEventHandler = function (type) {\n        var _this = this;\n        return function (handler) { return _this.mapUtils.onEvent(_this.map, type, handler); };\n    };\n    MapInstance.prototype.removeHandler = function (type) {\n        var _this = this;\n        return function (handler) { return _this.mapUtils.removeEvent(_this.map, type, handler); };\n    };\n    return MapInstance;\n}());\nvar segmentPolylineStyles = {\n    get: function (type) {\n        switch (type) {\n            case \"google\":\n                {\n                    return {\n                        default: {\n                            strokeColor: Color.blue,\n                            strokeOpacity: 1,\n                            strokeWeight: 5\n                        },\n                        highlight: {\n                            strokeColor: Color.blue,\n                            strokeOpacity: 1,\n                            strokeWeight: 5\n                        },\n                        fade: {\n                            strokeColor: Color.grey5,\n                            strokeOpacity: 0.2,\n                            strokeWeight: 2\n                        }\n                    };\n                }\n                ;\n            case \"leaflet\": {\n                return {\n                    default: {\n                        weight: 5,\n                        color: Color.blue,\n                        opacity: 1\n                    },\n                    highlight: {\n                        weight: 5,\n                        color: Color.blue,\n                        opacity: 1\n                    },\n                    fade: {\n                        weight: 2,\n                        color: Color.grey2,\n                        opacity: 0.2\n                    }\n                };\n            }\n        }\n    },\n};\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nfunction ExtendBoundsMixin(Base) {\n    return (function (_super) {\n        __extends(class_1, _super);\n        function class_1() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            _this.entities = {};\n            _this.toIncludeInBounds = true;\n            return _this;\n        }\n        class_1.prototype.extendBounds = function (bounds) {\n            var _this = this;\n            if (!this.toIncludeInBounds)\n                return bounds;\n            var mapUtils = this.mapInstance.mapUtils;\n            bounds = bounds || mapUtils.extendItemBounds();\n            var newBounds = reduce(this.entities, function (bounds, entity) {\n                return _this.getBounds(entity.item, bounds);\n            }, bounds);\n            return newBounds;\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$1 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction MarkersMixin(Base) {\n    return (function (_super) {\n        __extends$1(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.entities = {};\n            _this.event = new HtCustomEvent();\n            return _this;\n        }\n        class_1.prototype.htShow = function (item) {\n            return \"display: \" + (item ? \"flex\" : \"none\");\n        };\n        class_1.prototype.getItem = function (data) {\n            return this.mapInstance.mapUtils.getMarker();\n        };\n        class_1.prototype.getBounds = function (item, bounds) {\n            return this.mapInstance.mapUtils.extendItemBounds(item, bounds, this.forceExtendBounds);\n        };\n        class_1.prototype.update = function (_a, positionBearing) {\n            var item = _a.item, data = _a.data;\n            var pathPosition = positionBearing && positionBearing.path.length ?\n                positionBearing.path[positionBearing.path.length - 1] : null;\n            var position = pathPosition || this.getPosition(data);\n            if (position)\n                this.mapInstance.mapUtils.updatePosition(item, position);\n            if (!this.toNotSetMap)\n                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);\n            var id = this.trackBy(data);\n            this.event.next('update-' + id, { item: item, data: data });\n        };\n        /**\n         *\n         * @param id string return trackBy\n         * @returns {{subscribe: (cb) => IEventSub}}\n         */\n        class_1.prototype.onEntityUpdate = function (id) {\n            var _this = this;\n            var eventName = \"update-\" + id;\n            return {\n                subscribe: function (cb) {\n                    return _this.event.subscribe(eventName, cb);\n                }\n            };\n        };\n        class_1.prototype.removeItem = function (item) {\n            this.mapInstance.mapUtils.clearItem(item);\n        };\n        class_1.prototype.removeAll = function (entities) {\n            var _this = this;\n            each(entities, function (entity) {\n                _this.removeItem(entity.item);\n            });\n            this.entities = {};\n        };\n        class_1.prototype.clear = function () {\n            var entities = this.entities;\n            this.removeAll(entities);\n        };\n        class_1.prototype.clearItem = function (_a) {\n            var item = _a.item, data = _a.data;\n            this.removeData(data);\n            this.removeItem(item);\n        };\n        class_1.prototype.removeData = function (data) {\n            var id = this.trackBy(data);\n            if (this.entities[id])\n                delete this.entities[id];\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$2 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$3 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nfunction StyleMixin(Base) {\n    return (function (_super) {\n        __extends$2(class_1, _super);\n        function class_1() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            _this.defaultstyleFunct = {\n                get: function (type) {\n                    return {\n                        default: {}\n                    };\n                }\n            };\n            _this.highlightedId = null;\n            return _this;\n        }\n        class_1.prototype.getStyle = function (selectedStyleType, fallbackStyle) {\n            if (selectedStyleType === void 0) {\n                selectedStyleType = \"default\";\n            }\n            var mapType = this.mapInstance.mapUtils.type;\n            var styleFunct = this.styleFunct || this.defaultstyleFunct;\n            var mapTypetype = this.styleObj || styleFunct.get(mapType);\n            // console.log(this.name, \"style\", selectedStyleType, styleFunct, this.styleFunct);\n            // const styleType = mapTypetype[selectedStyleType] ? selectedStyleType : this.styleType;\n            var style = mapTypetype[selectedStyleType] || fallbackStyle;\n            if (!style)\n                console.error(\"style type does not exist \", this.name, selectedStyleType);\n            if (this.isAnimated && style)\n                style = __assign$3({}, style, { className: style['className'] ? style['className'] + \" animated-marker\" : 'animated-marker' });\n            return style;\n        };\n        class_1.prototype.setStyleType = function (styleType) {\n            if (styleType === void 0) {\n                styleType = 'default';\n            }\n            this.styleType = styleType;\n        };\n        class_1.prototype.setStyle = function (_a) {\n            var item = _a.item, data = _a.data;\n            var styleType = this.getStyleType(data);\n            var style = this.getStyle(styleType);\n            this.setItemStyle(item, style);\n        };\n        class_1.prototype.getStyleType = function (datum) {\n            if (this.highlightedId && datum) {\n                return this.highlightedId == this.trackBy(datum) ? 'highlight' : 'fade';\n            }\n            else {\n                return this.styleType;\n            }\n        };\n        class_1.prototype.setItemStyle = function (item, style) {\n            this.mapInstance.mapUtils.setStyle(item, style);\n        };\n        return class_1;\n    }(Base));\n}\n// export class Styles {\n//   styleFunct: StyleFunct = {\n//     google: {\n//       default: {\n//\n//       }\n//     },\n//     leaflet: {\n//       default: {\n//\n//       }\n//     }\n//   };\n//\n//   styleType = 'default';\n//\n//   getStyle(selectedStyleType: string = 'default', fallbackStyle?) {\n//     const mapType = GlobalMap.mapUtils.type;\n//     const mapTypetype = this.styleFunct[mapType];\n//     const styleType = selectedStyleType && mapTypetype[selectedStyleType] ? selectedStyleType : this.styleType;\n//     const style = mapTypetype[styleType] || fallbackStyle;\n//     if(!style) console.error(\"style type does not exist\");\n//     return this.styleFunct[mapType][styleType]\n//   }\n// }\nvar __extends$3 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction TraceMixin(Base) {\n    return (function (_super) {\n        __extends$3(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        // setMap: (item, map) => void;\n        class_1.prototype.trace = function (data, map$$1) {\n            var _this = this;\n            map$$1 = map$$1 || this.mapInstance.map;\n            var mapUtils = this.mapInstance.mapUtils;\n            if (!map$$1) {\n                console.warn(\"Map is not initialized\");\n                return false;\n            }\n            if (data && data.length) {\n                // if(this.cluster) this.clearAllClusters(data);\n                data.forEach(function (datum) {\n                    var id = _this.trackBy(datum);\n                    var entity = _this.entities[id];\n                    var hasEntity = !!entity;\n                    var item = !hasEntity ? _this.getItem(datum) : entity.item;\n                    entity = { data: datum, item: item, isOld: false };\n                    _this.entities[id] = entity;\n                    if (!hasEntity) {\n                        _this.addEvents(item, id);\n                    }\n                    if (item)\n                        _this.setStyle(entity);\n                    if (!_this.toNotTraceItem)\n                        _this.traceItem(datum);\n                    // if (!this.toNotSetMap) mapUtils.setMap(item, map);\n                });\n                if (this.traceEffect)\n                    this.traceEffect();\n            }\n            else {\n                // console.log(\"remove all\", this);\n                this.removeAll(this.entities);\n            }\n            this.bustOldItem();\n        };\n        class_1.prototype.traceItem = function (datum) {\n            var id = this.trackBy(datum);\n            var entity = this.entities[id];\n            if (entity) {\n                this.update(entity);\n            }\n        };\n        class_1.prototype.addEvents = function (item, id) {\n            var _this = this;\n            var mapUtils = this.mapInstance.mapUtils;\n            mapUtils.onEvent(item, \"click\", function () {\n                var entity = _this.entities[id];\n                if (_this.onMouseLeave)\n                    _this.onMouseLeave(entity);\n                if (_this.onClick)\n                    _this.onClick(entity);\n            });\n            mapUtils.onEvent(item, \"mouseover\", function () {\n                var entity = _this.entities[id];\n                if (_this.onMouseEnter)\n                    _this.onMouseEnter(entity);\n            });\n            mapUtils.onEvent(item, \"mouseout\", function () {\n                var entity = _this.entities[id];\n                if (_this.onMouseLeave)\n                    _this.onMouseLeave(entity);\n            });\n        };\n        class_1.prototype.bustOldItem = function () {\n            var _this = this;\n            var keys = Object.keys(this.entities);\n            keys.forEach(function (key) {\n                var entity = _this.entities[key];\n                if (entity.isOld) {\n                    _this.clearItem(entity);\n                    delete _this.entities[key];\n                }\n                else {\n                    _this.entities[key].isOld = true;\n                }\n            });\n        };\n        return class_1;\n    }(Base));\n}\nvar positionTime = {\n    positionTimePoints: [],\n    decode: function (encodedPolyline) {\n        this.positionTimePoints = new TimeAwareEncoder().decodeTimeAwarePolyline(encodedPolyline);\n        return this.positionTimePoints;\n    }\n};\nvar __extends$4 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction PolylinesMixin(Base) {\n    return (function (_super) {\n        __extends$4(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.positionTimeArray = [];\n            return _this;\n        }\n        class_1.prototype.getItem = function (data) {\n            return this.mapInstance.mapUtils.getPolyline();\n        };\n        class_1.prototype.getBounds = function (item, bounds) {\n            return this.mapInstance.mapUtils.extendBoundsWithPolyline(item, bounds);\n        };\n        class_1.prototype.update = function (_a, pathBearing) {\n            var item = _a.item, data = _a.data;\n            if (this.getPath || pathBearing) {\n                var path = pathBearing ? pathBearing.path : this.getPath(data);\n                this.mapInstance.mapUtils.setPath(item, path);\n            }\n            else if (this.getEncodedPositionTime) {\n                this.positionTimeArray = positionTime.decode(this.getEncodedPositionTime(data));\n                this.mapInstance.mapUtils.setPathPositionTimeArray(item, this.positionTimeArray);\n            }\n            else {\n                this.mapInstance.mapUtils.setEncodedPath(item, this.getEncodedPath(data));\n            }\n            if (!this.toNotSetMap)\n                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);\n        };\n        class_1.prototype.setItemStyle = function (item, style) {\n            this.mapInstance.mapUtils.setPolylineStyle(item, style);\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$5 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction MapItemsMixin(Base) {\n    return (function (_super) {\n        __extends$5(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.entities = {};\n            return _this;\n        }\n        class_1.prototype.getEntity = function (id) {\n            if (!this.entities)\n                return null;\n            if (id)\n                return this.entities[id];\n            var keys = Object.keys(this.entities);\n            if (keys.length == 0)\n                return null;\n            var key = keys[0];\n            return this.entities[key];\n        };\n        class_1.prototype.trackBy = function (datum) {\n            return _super.prototype.trackBy ? _super.prototype.trackBy.call(this, datum) : datum.id;\n        };\n        class_1.prototype.trackAnimationBy = function (datum) {\n            return _super.prototype.trackAnimationBy ? _super.prototype.trackAnimationBy.call(this, datum) : this.trackBy(datum);\n        };\n        return class_1;\n    }(Base));\n}\nvar SegmentPolylines = /*@__PURE__*/ (function () {\n    function SegmentPolylines(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.styleFunct = segmentPolylineStyles;\n        this.name = \"segment polyline\";\n    }\n    SegmentPolylines.prototype.getEncodedPath = function (data) {\n        return data.encoded_polyline;\n    };\n    SegmentPolylines.prototype.getEncodedPositionTime = function (data) {\n        return data.time_aware_polyline;\n    };\n    SegmentPolylines.prototype.getPosition = function () {\n        return { lat: 0, lng: 0 };\n    };\n    return SegmentPolylines;\n}());\nvar SegmentPolylinesTrace = TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(SegmentPolylines))))));\n// export class SegmentPolylines {\n//   styleFunct = segmentPolylineStyles;\n//\n//   getEncodedPath(data) {\n//     return data.encoded_polyline;\n//   };\n//\n//   getEncodedPositionTime(data: ISegment) {\n//     return data.time_aware_polyline\n//   }\n// }\n//\n// export const SegmentPolylinesTrace = mapItemsFactory(SegmentPolylines, {\n//   isPolyline: true,\n//   hasDataObservable: false\n// });\n// export const SegmentPolylinesTrace = _.compose(\n//   PolylinesMixin,\n//   MarkersMixin,\n//   StyleMixin,\n//   TraceMixin,\n// )(SegmentPolylines);\nvar stopStyles = {\n    get: function (type) {\n        switch (type) {\n            case 'google':\n                {\n                    return {\n                        default: {\n                            icon: {\n                                fillColor: Color.stop,\n                                fillOpacity: 1,\n                                strokeColor: Color.stopDark,\n                                strokeOpacity: 1,\n                                path: google.maps.SymbolPath.CIRCLE,\n                                scale: 8,\n                                strokeWeight: 2\n                            }\n                        },\n                        popup: {\n                            disableAutoPan: true,\n                            pixelOffset: new google.maps.Size(0, -10)\n                        },\n                        highlight: {\n                            icon: {\n                                fillColor: Color.stop,\n                                fillOpacity: 1,\n                                strokeColor: Color.stopDark,\n                                strokeOpacity: 1,\n                                path: google.maps.SymbolPath.CIRCLE,\n                                scale: 8,\n                                strokeWeight: 2\n                            }\n                        },\n                        fade: {\n                            icon: {\n                                fillColor: Color.stop,\n                                fillOpacity: 0.1,\n                                strokeColor: Color.stopDark,\n                                strokeOpacity: 0.2,\n                                path: google.maps.SymbolPath.CIRCLE,\n                                scale: 8,\n                                strokeWeight: 2\n                            }\n                        },\n                    };\n                }\n                ;\n            case \"leaflet\": {\n                return {\n                    default: {\n                        radius: 10,\n                        fillColor: Color.stop,\n                        fillOpacity: 1,\n                        weight: 2,\n                        color: Color.stopDark,\n                        pane: \"markerPane\"\n                    },\n                    popup: {\n                        offset: [0, -5],\n                        // offset: point(0, -5),\n                        closeButton: false\n                    },\n                    highlight: {\n                        radius: 10,\n                        fillColor: Color.stop,\n                        fillOpacity: 1,\n                        weight: 4,\n                        color: Color.stopDark,\n                        pane: \"markerPane\"\n                    },\n                    fade: {\n                        radius: 10,\n                        fillColor: Color.stop,\n                        fillOpacity: 0.1,\n                        weight: 2,\n                        color: Color.stopDark,\n                        pane: \"markerPane\"\n                    }\n                };\n            }\n        }\n    }\n};\nvar __extends$6 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction SingleItemMixin(Base) {\n    return (function (_super) {\n        __extends$6(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.trace = function (user, map$$1) {\n            var data = user ? [user] : [];\n            _super.prototype.trace.call(this, data, map$$1);\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$7 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction PopupMixin(Base) {\n    return (function (_super) {\n        __extends$7(class_1, _super);\n        function class_1() {\n            var arg = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                arg[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, arg) || this;\n            _this.defaultPopupStyle = {\n                disableAutoPan: true,\n            };\n            _this.addPopup();\n            return _this;\n        }\n        class_1.prototype.addPopup = function () {\n            this.popup = this.mapInstance.mapUtils.getPopup(this.getStyle(\"popup\", this.defaultPopupStyle));\n        };\n        class_1.prototype.setPopup = function (id) {\n            if (id && this.entities[id]) {\n                var data = this.entities[id].data;\n                var popup$$1 = this.popup;\n                var map$$1 = this.mapInstance.map;\n                this.mapInstance.mapUtils.openPopupPosition(this.getPosition(data), map$$1, this.getInfoContent(data), popup$$1);\n            }\n            else {\n                this.mapInstance.mapUtils.clearItem(this.popup);\n            }\n        };\n        class_1.prototype.onMouseEnter = function (entity) {\n            var id = this.trackBy(entity.data);\n            this.setPopup(id);\n        };\n        class_1.prototype.onMouseLeave = function (entity) {\n            this.popup && this.mapInstance.mapUtils.clearItem(this.popup);\n        };\n        return class_1;\n    }(Base));\n}\n// export class PopupRenderer {\n//   popup;\n//   getStyle: (styleType?) => object;\n//   entities: Entities<any>;\n//   getPosition: (data) => HtPosition;\n//   getInfoContent: (data) => string;\n//   // setMap: (item, map) => void;\n//   defaultPopupStyle =  {\n//     disableAutoPan: true,\n//     pixelOffset: new google.maps.Size(0, -35)\n//   };\n//\n//   addPopup() {\n//     this.popup = GlobalMap.mapUtils.getPopup(this.getStyle('popup'))\n//   }\n//\n//   setPopup(id: string | null) {\n//     if (id && this.entities[id]) {\n//       let {data} = this.entities[id];\n//       let popup = this.popup;\n//       let map = GlobalMap.map;\n//       GlobalMap.mapUtils.openPopupPosition(this.getPosition(data), map, this.getInfoContent(data), popup);\n//     } else {\n//       GlobalMap.mapUtils.setMap(this.popup, null)\n//     }\n//   };\n//\n//   onMouseEnter(entity: Entity<any>) {\n//     let id = entity.data.id;\n//     this.setPopup(id);\n//\n//   };\n//\n//   onMouseLeave(entity: Entity<any>) {\n//     this.popup && GlobalMap.mapUtils.setMap(this.popup, null)\n//   }\n// }\nvar __extends$8 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction DivMarkersMixin(Base) {\n    return (function (_super) {\n        __extends$8(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.getItem = function (data) {\n            return this.mapInstance.mapUtils.getDivMarker();\n        };\n        class_1.prototype.update = function (_a, pathBearing) {\n            var item = _a.item, data = _a.data;\n            var bearing = pathBearing ? pathBearing.bearing : null;\n            var content = this.getDivContent(data, bearing);\n            this.setContent({ item: item, content: content });\n            _super.prototype.update.call(this, { item: item, data: data }, pathBearing);\n        };\n        class_1.prototype.setContent = function (_a) {\n            var item = _a.item, content = _a.content;\n            this.mapInstance.mapUtils.setDivContent(item, content, this.getStyle());\n        };\n        class_1.prototype.setStyle = function (entity) {\n            // let style = this.getStyle();\n            // GlobalMap.mapUtils.setDivMarkerStyle(item, style)\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$9 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction CircleMixin(Base) {\n    return (function (_super) {\n        __extends$9(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.getItem = function (data) {\n            return this.mapInstance.mapUtils.getCircleMarker();\n        };\n        return class_1;\n    }(Base));\n}\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction createCommonjsModule(fn, module) {\n    return module = { exports: {} }, fn(module, module.exports), module.exports;\n}\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nvar isFunction_2 = isFunction;\nvar isFunction_1 = {\n    isFunction: isFunction_2\n};\nvar isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\nvar isArray = {\n    isArray: isArray_1\n};\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nvar isObject_2 = isObject;\nvar isObject_1 = {\n    isObject: isObject_2\n};\n// typeof any so that it we don't have to cast when comparing a result to the error object\nvar errorObject_1 = { e: {} };\nvar errorObject = {\n    errorObject: errorObject_1\n};\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject.errorObject.e = e;\n        return errorObject.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nvar tryCatch_2 = tryCatch;\nvar tryCatch_1 = {\n    tryCatch: tryCatch_2\n};\nvar __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends$13(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nvar UnsubscriptionError_2 = UnsubscriptionError;\nvar UnsubscriptionError_1 = {\n    UnsubscriptionError: UnsubscriptionError_2\n};\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = /*@__PURE__*/ (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);\n            }\n        }\n        if (isArray.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nvar Subscription_2 = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\nvar Subscription_1 = {\n    Subscription: Subscription_2\n};\nvar empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\nvar Observer = {\n    empty: empty\n};\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;\nvar _root = __window || __global || __self;\nvar root_1 = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\nvar root = {\n    root: root_1\n};\nvar rxSubscriber = createCommonjsModule(function (module, exports) {\n    var Symbol = root.root.Symbol;\n    exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n    /**\n     * @deprecated use rxSubscriber instead\n     */\n    exports.$$rxSubscriber = exports.rxSubscriber;\n});\nvar rxSubscriber_1 = rxSubscriber.rxSubscriber;\nvar rxSubscriber_2 = rxSubscriber.$$rxSubscriber;\nvar __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends$12(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nvar Subscriber_2 = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends$12(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\nvar Subscriber_1 = {\n    Subscriber: Subscriber_2\n};\nvar __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n}\nvar distinctUntilChanged_2 = distinctUntilChanged;\nvar DistinctUntilChangedOperator = /*@__PURE__*/ (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends$11(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject.errorObject) {\n                return this.destination.error(errorObject.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject.errorObject) {\n                return this.destination.error(errorObject.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\nvar __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter$2(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nvar filter_2 = filter$2;\nvar FilterOperator = /*@__PURE__*/ (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends$14(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\nvar __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map$3(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== 'function') {\n            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\nvar map_2 = map$3;\nvar MapOperator = /*@__PURE__*/ (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends$15(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\nvar __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return function scanOperatorFunction(source) {\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n    };\n}\nvar scan_2 = scan;\nvar ScanOperator = /*@__PURE__*/ (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) {\n            hasSeed = false;\n        }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends$16(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\nvar __extends$10 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// import { GlobalMap } from \"../global/map-service\";\nfunction DataObservableMixin(Base) {\n    return (function (_super) {\n        __extends$10(class_1, _super);\n        function class_1() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            _this.mapInstance.addToItemsSet(_this);\n            return _this;\n        }\n        class_1.prototype._procData$ = function () {\n            var _this = this;\n            return function (source$) {\n                return source$.pipe(filter_2(function (data) { return !!data; }), map_2(function (pageData) {\n                    var isNew = pageData && pageData.count && !pageData.previous;\n                    var results = pageData ? pageData.results : [];\n                    return _this.getMarkersArray(results, isNew);\n                }));\n            };\n        };\n        class_1.prototype.getMarkersArray = function (array, isNew) {\n            var _this = this;\n            if (isNew === void 0) {\n                isNew = false;\n            }\n            return reduce(array, function (acc, item) {\n                var isValid = _this.isValidMapItems\n                    ? _this.isValidMapItems(item)\n                    : !!_this.getPosition(item);\n                if (isValid) {\n                    acc.valid.push(item);\n                }\n                else {\n                    acc.invalid.push(item);\n                }\n                return acc;\n            }, { valid: [], invalid: [], isNew: isNew });\n        };\n        class_1.prototype.setPageData$ = function (data$, config) {\n            if (config === void 0) {\n                config = {};\n            }\n            //todo take page data, add diff apis\n            if (this.dataSub) {\n                this.dataSub.unsubscribe();\n            }\n            var hide$ = config.hide$;\n            this.dataPageSource$ = hide$\n                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) {\n                    return !!hide ? { results: [], count: 0, next: \"\", previous: \"\" } : data;\n                })\n                : data$;\n            this.data$ = this.dataPageSource$.pipe(this._procData$());\n            this._initDataObserver();\n        };\n        class_1.prototype.setData$ = function (data$, config) {\n            var _this = this;\n            if (config === void 0) {\n                config = {};\n            }\n            if (this.dataSub) {\n                this.dataSub.unsubscribe();\n            }\n            var hide$ = config.hide$;\n            this.dataArraySource$ = hide$\n                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) { return (!!hide ? [] : data); })\n                : data$;\n            this.data$ = this.dataArraySource$.pipe(scan_2(function (acc, data) {\n                return { new: data, old: acc.new };\n            }, { old: null, new: null }), map_2(function (dataArray) {\n                return _this.getMarkersArray(dataArray.new, !dataArray.old);\n            }));\n            this._initDataObserver();\n        };\n        // _initData$() {\n        //   let userData$ = this.dataPageSource$.pipe(\n        //     filter(data => !!GlobalMap.map),\n        //     pluck('valid'),\n        //     scan((acc: {user: any, oldUser: any}, data: object) => {\n        //       const oldUser = acc.user;\n        //       return {user: data, oldUser }\n        //     }, {user: null, oldUser: null})\n        //   );\n        //   return userData$;\n        // };\n        class_1.prototype._initDataObserver = function () {\n            var _this = this;\n            var mapData$ = this.data$.pipe(filter_2(function (data) { return !!_this.mapInstance.map; }));\n            var render$ = combineLatest$1(mapData$, this.mapInstance.map$.pipe(filter_2(function (data) { return !!data; })), function (mapData, map$$1) { return mapData; });\n            // function isNewId (newItem, old) {\n            //   if(!old && newItem) return true;\n            //   if(newItem && old) return  newItem.id !== old.id\n            // }\n            // function isNewList(newList, old) {\n            //   if(!old && newList) return true;\n            //   if(newList && old) return !newList.next && newList.count\n            // }\n            var sub = render$.subscribe(function (_a) {\n                var valid = _a.valid, invalid = _a.invalid, isNew = _a.isNew;\n                _this.trace(valid);\n                if (isNew)\n                    _this.mapInstance.resetBounds();\n            });\n            this.dataSub = sub;\n        };\n        class_1.prototype.clear = function () {\n            this.dataSub.unsubscribe();\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$17 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// import { GlobalMap } from \"../global/map-service\";\nfunction ClusterMixin(Base) {\n    return (function (_super) {\n        __extends$17(class_1, _super);\n        function class_1() {\n            var arg = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                arg[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, arg) || this;\n            _this.forceExtendBounds = true;\n            _this.toNotSetMap = true;\n            _this.addCluster();\n            return _this;\n        }\n        class_1.prototype.trace = function (items, map$$1) {\n            if (items && items.length) {\n                this.clearAllClusters(items);\n            }\n            _super.prototype.trace.call(this, items, map$$1);\n        };\n        class_1.prototype.addCluster = function () {\n            this.mapInstance.addCluster(this);\n        };\n        class_1.prototype.traceEffect = function () {\n            if (this.cluster) {\n                var userMarkerArray = values(this.entities).map(function (userMarker) {\n                    return userMarker.item;\n                });\n                this.mapInstance.mapUtils.addMarkersToCluster(this.cluster, userMarkerArray, this.mapInstance.map);\n            }\n        };\n        class_1.prototype.getBounds = function (item, bounds) {\n            return this.mapInstance.mapUtils.extendItemBounds(item, bounds, true);\n        };\n        class_1.prototype.removeItem = function (item) {\n            this.mapInstance.mapUtils.removeClusterMarker(this.cluster, item);\n            _super.prototype.removeItem.call(this, item);\n        };\n        class_1.prototype.removeAll = function (entities) {\n            this.cluster && this.mapInstance.mapUtils.removeClusterMarkers(this.cluster);\n            this.entities = {};\n            // super.removeAll(entities);\n        };\n        class_1.prototype.clearAllClusters = function (data) {\n            var entitiesCount = Object.keys(this.entities).length;\n            if (entitiesCount > 400 && entitiesCount - data.length > 100) {\n                this.removeAll(this.entities);\n            }\n        };\n        return class_1;\n    }(Base));\n}\nvar MarkersBase = /*@__PURE__*/ (function () {\n    function MarkersBase(renderConfig, styleFunct, name) {\n        this.renderConfig = renderConfig;\n        this.styleFunct = styleFunct;\n        this.name = name;\n        this.mapInstance = renderConfig.mapInstance || new MapInstance();\n    }\n    MarkersBase.prototype.getPosition = function (data) {\n        return this.renderConfig.getPosition(data);\n    };\n    MarkersBase.prototype.getInfoContent = function (data) {\n        return this.renderConfig.getInfoContent(data);\n    };\n    return MarkersBase;\n}());\nvar PolylinesBase = /*@__PURE__*/ (function () {\n    function PolylinesBase(renderConfig, styleFunct) {\n        this.renderConfig = renderConfig;\n        this.styleFunct = styleFunct;\n        this.mapInstance = renderConfig.mapInstance || new MapInstance();\n    }\n    PolylinesBase.prototype.getEncodedPath = function (data) {\n        return this.renderConfig.getEncodedPath(data);\n    };\n    PolylinesBase.prototype.getEncodedPositionTime = function (data) {\n        return this.renderConfig.getEncodedPositionTime(data);\n    };\n    return PolylinesBase;\n}());\nvar DivMarkersBase = /*@__PURE__*/ (function () {\n    function DivMarkersBase(renderConfig, styleFunct) {\n        this.renderConfig = renderConfig;\n        this.styleFunct = styleFunct;\n        this.mapInstance = renderConfig.mapInstance || new MapInstance();\n    }\n    DivMarkersBase.prototype.getPosition = function (data) {\n        return this.renderConfig.getPosition(data);\n    };\n    DivMarkersBase.prototype.getInfoContent = function (data) {\n        return this.renderConfig.getInfoContent(data);\n    };\n    DivMarkersBase.prototype.getDivContent = function (data) {\n        return this.renderConfig.getDivContent(data);\n    };\n    return DivMarkersBase;\n}());\nvar __assign$4 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar mapItemsFactory = function (baseClass, config) {\n    var defaultConfig = {\n        isCluster: false,\n        hasPopup: false,\n        isPolyline: false,\n        isDiv: false,\n        isSingleItem: false,\n        isCircle: false,\n        hasDataObservable: false\n    };\n    var finalConfig = __assign$4({}, defaultConfig, config);\n    var itemClass = baseClass;\n    itemClass = MarkersMixin(itemClass);\n    itemClass = StyleMixin(itemClass);\n    itemClass = TraceMixin(itemClass);\n    itemClass = ExtendBoundsMixin(itemClass);\n    if (finalConfig.isSingleItem)\n        itemClass = SingleItemMixin(itemClass);\n    if (finalConfig.hasPopup)\n        itemClass = PopupMixin(itemClass);\n    if (finalConfig.isCluster)\n        itemClass = ClusterMixin(itemClass);\n    if (finalConfig.isDiv)\n        itemClass = DivMarkersMixin(itemClass);\n    if (finalConfig.isCircle)\n        itemClass = CircleMixin(itemClass);\n    if (finalConfig.isPolyline)\n        itemClass = PolylinesMixin(itemClass);\n    if (finalConfig.hasDataObservable)\n        itemClass = DataObservableMixin(itemClass);\n    return itemClass;\n};\nvar itemsBaseFactory = function (_a) {\n    var renderConfig = _a.renderConfig, typeConfig = _a.typeConfig, styleFunct = _a.styleFunct;\n    var mapTypesBase = {\n        polylines: PolylinesBase,\n        markers: MarkersBase,\n        divMarkers: DivMarkersBase\n    };\n    typeConfig = typeConfig || {};\n    var MapItemBase = mapTypesBase.markers;\n    if (typeConfig.isDiv)\n        MapItemBase = mapTypesBase.divMarkers;\n    if (typeConfig.isPolyline)\n        MapItemBase = mapTypesBase.polylines;\n    var base = mapItemsFactory(MapItemBase, typeConfig);\n    return base;\n};\nvar itemsFactory = function (_a) {\n    var renderConfig = _a.renderConfig, typeConfig = _a.typeConfig, styleFunct = _a.styleFunct, styleObj = _a.styleObj;\n    var base = itemsBaseFactory({ renderConfig: renderConfig, typeConfig: typeConfig, styleFunct: styleFunct });\n    function getStyleFunct(styleObj) {\n        return {\n            get: function (type) {\n                return styleObj[type];\n            }\n        };\n    }\n    return new base(renderConfig, styleFunct || getStyleFunct(styleObj));\n};\nvar stopMarkersConfig = {\n    renderConfig: {\n        getPosition: function (data) {\n            if (data.location && data.location.geojson) {\n                var lat = data.location.geojson.coordinates[1];\n                var lng = data.location.geojson.coordinates[0];\n                return { lat: lat, lng: lng };\n            }\n            else {\n                return null;\n            }\n        },\n        getInfoContent: function (data) {\n            var durationString = null;\n            if (data.started_at && data.ended_at) {\n                var durationMin = new Date(new Date(data.ended_at).getTime() -\n                    new Date(data.started_at).getTime()).getTime() /\n                    (1000 * 60);\n                durationString = HMString(durationMin);\n            }\n            var start = TimeString(data.started_at);\n            var end = TimeString(data.ended_at);\n            var startDate = DateString(data.started_at);\n            var startDateShort = DateString(data.started_at, \"short\");\n            var endDate = DateString(data.ended_at);\n            var sameDate = startDate == endDate;\n            function htShow(item) {\n                return \"display: \" + (item ? \"flex\" : \"none\");\n            }\n            return \"<div class=\\\"flex-column\\\">\\n<strong class=\\\"text-muted text-center\\\" style=\\\"padding-bottom: 0; color: \" + Color.stop + \"\\\">Stop</strong>\\n<div style=\\\"display: \" + (start ? \"display\" : \"none\") + \"\\\" class=\\\"flex-row space-between\\\">\\n    <div>\" + (start ||\n                \"--:--\") + \"</div><div>&nbsp; to &nbsp;</div><div class=\\\"text-right\\\">\" + (end ||\n                \"--:--\") + \"</div>\\n</div>\\n<div style=\\\"\" + htShow(startDate || endDate) + \"\\\" class=\\\"\" + (sameDate || !endDate ? \"space-around\" : \"space-between\") + \" text-2 text-muted flex-row\\\">\\n    <div>\" + startDateShort + \"</div><div style=\\\"display: \" + (sameDate || !endDate ? \"none\" : \"block\") + \"\\\">\" + endDate + \"</div>\\n</div>\\n<div style=\\\"display: \" + (durationString ? \"block\" : \"none\") + \"\\\" class=\\\"text-3 text-center\\\">\" + durationString + \"</div>\\n</div>\";\n        }\n    },\n    styleFunct: stopStyles,\n    typeConfig: {\n        hasPopup: true,\n        isCircle: true,\n        hasDataObservable: false\n    },\n    name: \"stop\"\n};\nvar stopMarkersTrace = function () {\n    return itemsFactory(stopMarkersConfig);\n};\nvar StopMarkers = /*@__PURE__*/ (function () {\n    function StopMarkers(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.styleFunct = stopStyles;\n    }\n    StopMarkers.prototype.getPosition = function (data) {\n        if (data.location && data.location.geojson) {\n            var lat = data.location.geojson.coordinates[1];\n            var lng = data.location.geojson.coordinates[0];\n            return { lat: lat, lng: lng };\n        }\n        else {\n            return null;\n        }\n    };\n    StopMarkers.prototype.getInfoContent = function (data) {\n        var durationString = null;\n        if (data.started_at && data.ended_at) {\n            var durationMin = new Date(new Date(data.ended_at).getTime() -\n                new Date(data.started_at).getTime()).getTime() /\n                (1000 * 60);\n            durationString = HMString(durationMin);\n        }\n        var start = TimeString(data.started_at);\n        var end = TimeString(data.ended_at);\n        var startDate = DateString(data.started_at);\n        var startDateShort = DateString(data.started_at, \"short\");\n        var endDate = DateString(data.ended_at);\n        var sameDate = startDate == endDate;\n        function htShow(item) {\n            return \"display: \" + (item ? \"flex\" : \"none\");\n        }\n        return \"<div class=\\\"flex-column\\\">\\n<strong class=\\\"text-muted text-center\\\" style=\\\"padding-bottom: 0; color: \" + Color.stop + \"\\\">Stop</strong>\\n<div style=\\\"display: \" + (start ? \"display\" : \"none\") + \"\\\" class=\\\"flex-row space-between\\\">\\n    <div>\" + (start ||\n            \"--:--\") + \"</div><div>&nbsp; to &nbsp;</div><div class=\\\"text-right\\\">\" + (end ||\n            \"--:--\") + \"</div>\\n</div>\\n<div style=\\\"\" + htShow(startDate || endDate) + \"\\\" class=\\\"\" + (sameDate || !endDate ? \"space-around\" : \"space-between\") + \" text-2 text-muted flex-row\\\">\\n    <div>\" + startDateShort + \"</div><div style=\\\"display: \" + (sameDate || !endDate ? \"none\" : \"block\") + \"\\\">\" + endDate + \"</div>\\n</div>\\n<div style=\\\"display: \" + (durationString ? \"block\" : \"none\") + \"\\\" class=\\\"text-3 text-center\\\">\" + durationString + \"</div>\\n</div>\";\n    };\n    return StopMarkers;\n}());\nvar StopMarkersTrace = PopupMixin(TraceMixin(ExtendBoundsMixin(CircleMixin(MarkersMixin(StyleMixin(MapItemsMixin(StopMarkers)))))));\n// export abstract class StopMarkers {\n//   name = \"Stop\";\n//   styleFunct = stopStyles;\n//\n//   htShow(item) {\n//     return `display: ${item ? 'flex' : 'none'}`\n//   };\n//\n//   getPosition(data) {\n//     if(data.location && data.location.geojson) {\n//       let lat = data.location.geojson.coordinates[1];\n//       let lng = data.location.geojson.coordinates[0];\n//       return {lat, lng}\n//     } else {\n//       return null;\n//     }\n//\n//   };\n//\n//   getInfoContent(data: ISegment) {\n//     function htShow(item) {\n//       return `display: ${item ? 'flex' : 'none'}`\n//     };\n//     console.log(this.htShow, \"htShow\");\n//     let durationString = null;\n//     if(data.started_at && data.ended_at) {\n//       let durationMin = (new Date(new Date(data.ended_at).getTime() - new Date(data.started_at).getTime()).getTime()) / (1000 * 60);\n//       durationString = HMString(durationMin)\n//     }\n//\n//     let start = TimeString(data.started_at);\n//     let end = TimeString(data.ended_at);\n//     let startDate = DateString(data.started_at);\n//     let startDateShort = DateString(data.started_at, 'short');\n//     let endDate = DateString(data.ended_at);\n//     let sameDate = startDate == endDate;\n//     return `<div class=\"flex-column\">\n// <strong class=\"text-muted text-center\" style=\"padding-bottom: 0; color: ${Color.stop}\">Stop</strong>\n// <div style=\"display: ${start ? 'display' : 'none'}\" class=\"flex-row space-between\">\n//     <div>${start || '--:--'}</div><div>&nbsp; to &nbsp;</div><div class=\"text-right\">${end || '--:--'}</div>\n// </div>\n// <div style=\"${htShow(startDate || endDate)}\" class=\"${sameDate || !endDate ? 'space-around' : 'space-between'} text-2 text-muted flex-row\">\n//     <div>${startDateShort}</div><div style=\"display: ${sameDate || !endDate ? 'none' : 'block'}\">${endDate}</div>\n// </div>\n// <div style=\"display: ${durationString ? 'block' : 'none'}\" class=\"text-3 text-center\">${durationString}</div>\n// </div>`\n//   }\n// }\n//\n// export const StopMarkersTrace = mapItemsFactory(StopMarkers, {\n//   hasPopup: true,\n//   isCircle: true,\n//   hasDataObservable: false\n// });\nvar ActionMarkers = /*@__PURE__*/ (function () {\n    function ActionMarkers(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.name = \"Action\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {\n                                flat: true,\n                                anchor: RichMarkerPosition.MIDDLE,\n                                zIndex: 1\n                            },\n                            popup: {\n                                pixelOffset: new google.maps.Size(0, -5),\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                iconAnchor: [12, 12]\n                                // iconSize: [35, 35],\n                                // className: 'current-action-marker',\n                                // iconAnchor: point(15, 43)\n                                // iconAnchor: [15, 43]\n                            },\n                            popup: {\n                                // offset: point(0, -35),\n                                offset: [0, -5],\n                                closeButton: false\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    ActionMarkers.prototype.getPosition = function (data) {\n        var posObj = htAction(data).getPositionsObject();\n        return posObj ? posObj.position : null;\n    };\n    ActionMarkers.prototype.getDivContent = function (action) {\n        var icon = \"<div class=\\\"action-marker flex-row\\\">\\n<span style=\\\"margin: auto\\\">\" + NameCase(action.type[0]) + \"</span>\\n</div>\";\n        return icon;\n    };\n    return ActionMarkers;\n}());\nvar ActionMarkersTrace = ExtendBoundsMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionMarkers))))));\nvar userDivFactory = function (user) {\n    return \"<div class=\\\"m-marker\\\">\\n        <div class=\\\"m-box\\\" style=\\\"background-image: url('\" + user.photo + \"')\\\"></div>\\n          <i class=\\\"fa fa-neuter\\\"></i>\\n      </div>\";\n};\nvar __extends$18 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction AnimationMixin(Base) {\n    return (function (_super) {\n        __extends$18(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            // bearing: number = 0;\n            // item;\n            _this.isAnimated = true;\n            return _this;\n        }\n        class_1.prototype.setTimeAwareAnimation = function (animation) {\n            var _this = this;\n            this.animation = animation || new TimeAwareAnimation();\n            this.animation.updateEvent.subscribe('update', function (_a) {\n                var path = _a.path, bearing = _a.bearing;\n                var entity = _this.getEntity();\n                if (entity)\n                    _this.update(entity, { path: path, bearing: bearing });\n            });\n        };\n        return class_1;\n    }(Base));\n}\nvar currentUserConfig = {\n    renderConfig: {\n        getPosition: function (data) {\n            return htUser(data).getPosition();\n        },\n        getDivContent: function (data) {\n            return userDivFactory(data);\n        }\n    },\n    styleFunct: {\n        get: function (type) {\n            switch (type) {\n                case \"google\":\n                    {\n                        return {\n                            default: {\n                                flat: true,\n                                anchor: RichMarkerPosition.BOTTOM_CENTER\n                            }\n                        };\n                    }\n                    ;\n                case \"leaflet\": {\n                    return {\n                        default: {\n                            // iconAnchor: point(15, 43)\n                            iconAnchor: [15, 43]\n                        }\n                    };\n                }\n            }\n        }\n    },\n    typeConfig: {\n        isSingleItem: true,\n        isDiv: true,\n        hasDataObservable: false\n    },\n    name: \"Current user\"\n};\nvar currentUserTrace = function () {\n    return itemsFactory(currentUserConfig);\n};\nvar CurrentUser = /*@__PURE__*/ (function () {\n    function CurrentUser(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.name = \"Current user\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case \"google\":\n                        {\n                            return {\n                                default: {\n                                    flat: true,\n                                    anchor: RichMarkerPosition.BOTTOM_CENTER\n                                }\n                            };\n                        }\n                        ;\n                    case \"leaflet\": {\n                        return {\n                            default: {\n                                // iconAnchor: point(15, 43)\n                                iconAnchor: [15, 43]\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    CurrentUser.prototype.getPosition = function (data) {\n        return htUser(data).getPosition();\n    };\n    CurrentUser.prototype.getDivContent = function (data) {\n        return userDivFactory(data);\n    };\n    return CurrentUser;\n}());\nvar CurrentUserTrace = AnimationMixin(SingleItemMixin(DivMarkersMixin(TraceMixin(MarkersMixin(StyleMixin(MapItemsMixin(CurrentUser)))))));\n// export class CurrentUser {\n//   name = \"Current user\";\n//   styleFunct: StyleFunct = {\n//     google: {\n//       default: {\n//         flat: true,\n//         anchor: RichMarkerPosition.BOTTOM_CENTER,\n//       }\n//     },\n//     leaflet: {\n//       default: {\n//\n//       }\n//     }\n//   };\n//\n//   getPosition(data): HtPosition {\n//     return htUser(data).getPosition()\n//   };\n//\n//   getDivContent(data) {\n//     return userDivFactory(data)\n//\n//   }\n// };\n//\n// export const CurrentUserTrace = mapItemsFactory(CurrentUser, {\n//   isSingleItem: true,\n//   isDiv: true,\n//   hasDataObservable: false\n// });\nvar __extends$19 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// import { GlobalMap } from \"../global/map-service\";\nfunction CompoundDataObservableMixin(Base) {\n    return (function (_super) {\n        __extends$19(class_1, _super);\n        function class_1() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            _this.mapInstance.addToItemsSet(_this);\n            return _this;\n        }\n        class_1.prototype._procData$ = function () {\n            return function (source$) {\n                return source$.pipe(map_2(function (markers) {\n                    return reduce(markers, function (acc, item) {\n                        var isValid = true;\n                        if (isValid) {\n                            acc.valid.push(item);\n                        }\n                        else {\n                            acc.invalid.push(item);\n                        }\n                        return acc;\n                    }, { valid: [], invalid: [] });\n                    // return markers\n                }));\n            };\n        };\n        class_1.prototype.setCompoundData$ = function (data$, config) {\n            if (config === void 0) {\n                config = {};\n            }\n            this.compoundSetDataConfig = config;\n            if (this.dataSub) {\n                this.dataSub.unsubscribe();\n            }\n            var hide$ = config.hide$;\n            var filter$ = config.filter$;\n            var dataSource$ = hide$\n                ? combineLatest$1(data$, hide$.pipe(distinctUntilChanged_2()), function (data, hide) { return (!!hide ? null : data); })\n                : data$;\n            if (config.roots && config.highlighted$) {\n                dataSource$ = dataWithSelectedId$(dataSource$, config.highlighted$, config.roots, 'highlightedSegment');\n            }\n            if (config.roots && filter$)\n                dataSource$ = dataWithSelectedId$(dataSource$, filter$, config.roots, 'selectedSegment');\n            this.dataSource$ = dataSource$;\n            this.data$ = this.dataSource$;\n            this._initDataObserver();\n        };\n        class_1.prototype._initData$ = function () {\n            var _this = this;\n            var userData$ = this.data$.pipe(filter_2(function (data) { return !!_this.mapInstance.map; }), scan_2(function (acc, data) {\n                var oldUser = acc.user;\n                return { user: data, oldUser: oldUser };\n            }, { user: null, oldUser: null }));\n            return userData$;\n        };\n        class_1.prototype._initDataObserver = function () {\n            var _this = this;\n            var userData$ = this._initData$();\n            function isNewItem(newItem, old) {\n                if (!old && newItem)\n                    return true;\n                if (newItem && old)\n                    return !old && !!newItem;\n            }\n            var newPlaceline$ = userData$.pipe(map_2(function (acc) {\n                var userData = acc.user;\n                _this.trace(userData);\n                var isNew = isNewItem(acc.user, acc.oldUser);\n                return isNew;\n                // if(isNew) GlobalMap.resetBounds()\n            }));\n            var sub = orCombine(newPlaceline$.pipe(filter_2(function (data) { return !!data; })), this.compoundSetDataConfig.resetMap$.pipe(map_2(function (data) { return true; }))).subscribe(function (toReset) {\n                if (toReset)\n                    _this.mapInstance.resetBounds();\n            });\n            this.dataSub = sub;\n        };\n        return class_1;\n    }(Base));\n}\nvar __extends$20 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar AnimPolyline = (function (_super) {\n    __extends$20(AnimPolyline, _super);\n    function AnimPolyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = \"anim polyline\";\n        return _this;\n    }\n    return AnimPolyline;\n}(SegmentPolylines));\nvar AnimPolylineTrace = AnimationMixin(SingleItemMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(AnimPolyline))))))));\nvar __extends$21 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ActionsPolyline = (function (_super) {\n    __extends$21(ActionsPolyline, _super);\n    function ActionsPolyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lineSymbol = {\n            path: 'M 0,-1 0,1',\n            strokeOpacity: 1,\n            scale: 4\n        };\n        _this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case \"google\":\n                        {\n                            return {\n                                default: {\n                                    strokeColor: Color.grey3,\n                                    strokeOpacity: 0,\n                                    strokeWeight: 5,\n                                    icons: [{\n                                            icon: {\n                                                path: 'M 0,-1 0,0',\n                                                strokeOpacity: 1,\n                                                scale: 4\n                                            },\n                                            offset: '0',\n                                            repeat: '13px'\n                                        }],\n                                },\n                                highlight: {\n                                    strokeColor: Color.grey2,\n                                    strokeOpacity: 1,\n                                    strokeWeight: 5\n                                },\n                                fade: {\n                                    strokeColor: Color.grey2,\n                                    strokeOpacity: 0.2,\n                                    strokeWeight: 2\n                                }\n                            };\n                        }\n                        ;\n                    case \"leaflet\": {\n                        return {\n                            default: {\n                                weight: 5,\n                                color: Color.grey4,\n                                opacity: 1,\n                                dashArray: \"7 10\"\n                            },\n                            highlight: {\n                                weight: 5,\n                                color: Color.grey2,\n                                opacity: 1\n                            },\n                            fade: {\n                                weight: 2,\n                                color: Color.grey2,\n                                opacity: 0.2\n                            }\n                        };\n                    }\n                }\n            },\n        };\n        _this.name = \"action polyline\";\n        return _this;\n    }\n    ActionsPolyline.prototype.getPathFromData = function (data) {\n        return data ? data.actions.reduce(function (path, action) {\n            return htAction(action).getExpectedPosition() && !action.completed_at ? path.concat([htAction(action).getPosition()]) : path;\n        }, []) : null;\n    };\n    return ActionsPolyline;\n}(SegmentPolylines));\nvar ActionsPolylineTrace = ConnectorMixin(AnimationMixin(SingleItemMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsPolyline)))))))));\nfunction ConnectorMixin(Base) {\n    return (function (_super) {\n        __extends$21(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.positionTimeArray = [];\n            return _this;\n        }\n        /*\n        Need to ensure connector is traced before this class is traced\n         */\n        class_1.prototype.setConnector = function (entity) {\n            this.connector = entity ? entity.item : null;\n        };\n        class_1.prototype.getConnectorPosition = function () {\n            return this.connector ? this.mapInstance.mapUtils.getItemPosition(this.connector) : null;\n        };\n        class_1.prototype.update = function (_a, pathBearing) {\n            var item = _a.item, data = _a.data;\n            var startPosition;\n            if (pathBearing) {\n                var path = pathBearing.path;\n                startPosition = path[path.length - 1];\n            }\n            else {\n                startPosition = this.getConnectorPosition();\n            }\n            var dataPath = this.getPathFromData(data);\n            if (dataPath && startPosition) {\n                var finalPath = [startPosition].concat(dataPath);\n                this.mapInstance.mapUtils.setPath(item, finalPath);\n                this.mapInstance.mapUtils.setMap(item, this.mapInstance.map);\n            }\n            else {\n                this.clear();\n            }\n        };\n        return class_1;\n    }(Base));\n}\nvar Placeline = /*@__PURE__*/ (function () {\n    function Placeline(options) {\n        this.options = options;\n        this.allowedEvents = {};\n        this.anim = new TimeAwareAnimation();\n        this.mapInstance = this.options.mapInstance;\n        this.stopMarkers = new StopMarkersTrace(this.mapInstance);\n        this.userMarker = new CurrentUserTrace(this.mapInstance);\n        this.userMarker.setTimeAwareAnimation(this.anim);\n        this.segmentsPolylines = new SegmentPolylinesTrace(this.mapInstance);\n        this.actionMarkers = new ActionMarkersTrace(this.mapInstance);\n        this.animPolyline = new AnimPolylineTrace(this.mapInstance);\n        this.animPolyline.setTimeAwareAnimation(this.anim);\n        this.actionsPolyline = new ActionsPolylineTrace(this.mapInstance);\n        this.actionsPolyline.setTimeAwareAnimation(this.anim);\n    }\n    Object.defineProperty(Placeline.prototype, \"map\", {\n        get: function () {\n            return this.mapInstance.map;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Placeline.prototype.trace = function (user, map$$1) {\n        var selectedSegment = user ? user.selectedSegment : null;\n        this.setHighlightId(user);\n        var userSegments = user && user.segments ? user.segments : [];\n        var segType = this.getSegmentTypes(userSegments);\n        var lastSegment = segType.lastSegment;\n        var restTrips = segType.tripSegment.pop();\n        this.traceStops(segType.stopSegment, selectedSegment, lastSegment);\n        if (lastSegment) {\n            var string = this.getTimeAwarePolyline(lastSegment);\n            if (string) {\n                //todo infer toNotTraceItem from animMixin trace\n                this.userMarker.toNotTraceItem = true;\n                this.animPolyline.toNotTraceItem = true;\n                this.actionsPolyline.toNotTraceItem = true;\n                // this.animPolyline.trace(restTrips);\n                this.anim.updatePolylineString(string);\n            }\n            else {\n                this.animPolyline.toNotTraceItem = false;\n                this.userMarker.toNotTraceItem = false;\n                this.actionsPolyline.toNotTraceItem = false;\n                // if (!selectedSegment) this.animPolyline.trace(restTrips);\n                this.anim.clear();\n            }\n            this.userMarker.trace(user);\n            this.traceAnimPolyline(restTrips, selectedSegment);\n            this.actionsPolyline.setConnector(this.userMarker.getEntity());\n            this.actionsPolyline.trace(user);\n        }\n        else {\n            this.anim.clear();\n            this.userMarker.clear();\n            this.animPolyline.clear();\n            this.actionsPolyline.clear();\n        }\n        this.traceSegments(segType.tripSegment, selectedSegment);\n        this.traceAction(user, selectedSegment);\n        // this.actionsPolyline.setConnector(this.userMarker.getEntity());\n        // this.actionsPolyline.trace(user)\n    };\n    Placeline.prototype.traceAnimPolyline = function (restTrip, selectedSegment) {\n        if (!restTrip) {\n            this.animPolyline.clear();\n        }\n        else if (!selectedSegment || selectedSegment.id === restTrip.id) {\n            this.animPolyline.trace(restTrip);\n        }\n        else {\n            this.animPolyline.clear();\n        }\n    };\n    Placeline.prototype.traceStops = function (stops, selectedSegment, lastSegment) {\n        if (selectedSegment) {\n            stops = selectedSegment.type == 'stop' ? [selectedSegment] : [];\n        }\n        this.stopMarkers.trace(stops);\n    };\n    Placeline.prototype.traceSegments = function (trips, selectedSegment) {\n        if (trips === void 0) {\n            trips = [];\n        }\n        if (selectedSegment) {\n            var matchedTrip = trips.find(function (trip) { return trip.id === selectedSegment.id; });\n            trips = matchedTrip ? [matchedTrip] : [];\n        }\n        this.segmentsPolylines.trace(trips);\n    };\n    Placeline.prototype.traceAction = function (user, selectedSegment) {\n        var actions = user && user.actions && !selectedSegment ? user.actions : [];\n        var filteredActions = filter$1(actions, function (action) {\n            return htAction(action).isValidMarker();\n        });\n        if (this.actionMarkers)\n            this.actionMarkers.trace(filteredActions);\n    };\n    Placeline.prototype.setHighlightId = function (user) {\n        var data = user && !user.selectedSegment ? user.highlightedSegment : null;\n        var id = data ? data.id : null;\n        this.stopMarkers.highlightedId = id;\n        this.segmentsPolylines.highlightedId = id;\n        this.animPolyline.highlightedId = id;\n    };\n    Placeline.prototype.getTimeAwarePolyline = function (segment) {\n        return segment ? segment.time_aware_polyline : null;\n    };\n    Placeline.prototype.extendBounds = function (bounds) {\n        bounds = this.stopMarkers.extendBounds(bounds);\n        bounds = this.segmentsPolylines.extendBounds(bounds);\n        bounds = this.animPolyline.extendBounds(bounds);\n        bounds = this.actionMarkers.extendBounds(bounds);\n        // bounds = this.userMarker.extendBounds(bounds);\n        // console.log(bounds, \"final\");\n        return bounds;\n    };\n    Placeline.prototype.getSegmentTypes = function (userSegments) {\n        return reduce(userSegments, function (segmentType, segment) {\n            segmentType.lastSegment = segment;\n            if (segment.type == \"stop\") {\n                if (segment.location && segment.location.geojson)\n                    segmentType.stopSegment.push(segment);\n            }\n            else {\n                if (segment.encoded_polyline)\n                    segmentType.tripSegment.push(segment);\n            }\n            return segmentType;\n        }, { tripSegment: [], stopSegment: [], lastSegment: null });\n    };\n    return Placeline;\n}());\nvar PlacelineTrace = CompoundDataObservableMixin(Placeline);\nvar UsersCluster = /*@__PURE__*/ (function () {\n    function UsersCluster(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.name = \"users cluster\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {\n                                flat: true,\n                                anchor: RichMarkerPosition.BOTTOM_CENTER,\n                                zIndex: 1\n                            },\n                            popup: {\n                                disableAutoPan: true,\n                                pixelOffset: new google.maps.Size(0, -35)\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                // iconAnchor: point(15, 43)\n                                iconAnchor: [15, 43]\n                            },\n                            popup: {\n                                // offset: point(0, -35),\n                                offset: [0, -35],\n                                closeButton: false\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    UsersCluster.prototype.getPosition = function (data) {\n        return htUser(data).getPosition();\n    };\n    UsersCluster.prototype.getDivContent = function (data) {\n        return userDivFactory(data);\n    };\n    UsersCluster.prototype.getInfoContent = function (data) {\n        var string = \"<div>\\n<strong>\" + data.name + \"</strong>\\n<div>\" + data.display.status_text + \"</div>\\n<div>\" + data.display.sub_status_text + \"</div>\\n</div>\";\n        return string;\n    };\n    UsersCluster.prototype.traceEffect = function () {\n    };\n    return UsersCluster;\n}());\nvar UsersClusterTrace = DataObservableMixin(PopupMixin(ClusterMixin(TraceMixin(ExtendBoundsMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(UsersCluster)))))))));\n// export class UsersClusters {\n//   name = \"Cluster user\";\n//   styleFunct: StyleFunct = {\n//     google: {\n//       default: {\n//         flat: true,\n//         anchor: RichMarkerPosition.BOTTOM_CENTER,\n//         zIndex: 1\n//       },\n//       popup: {\n//         disableAutoPan: true,\n//         pixelOffset: new google.maps.Size(0, -35)\n//       }\n//     },\n//     leaflet: {\n//       default: {\n//\n//       }\n//     }\n//   };\n//\n//   getPosition(data): HtPosition {\n//     return htUser(data).getPosition()\n//   };\n//\n//   getDivContent(data) {\n//     return userDivFactory(data)\n//   };\n//\n//   getInfoContent(data) {\n//     let string = `<div>\n// <strong>${data.name}</strong>\n// <div>${data.display.status_text}</div>\n// <div>${data.display.sub_status_text}</div>\n// </div>`;\n//     return string\n//   }\n// }\n//\n// export const UsersClustersTrace = mapItemsFactory(UsersClusters, {\n//   hasPopup: true,\n//   isCluster: true,\n//   isDiv: true,\n//   hasDataObservable: true\n// });\nvar __extends$22 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction HeatmapMixin(Base) {\n    return (function (_super) {\n        __extends$22(class_1, _super);\n        function class_1() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            _this.forceExtendBounds = true;\n            var style = _this.getStyle();\n            _this.heatmap = _this.mapInstance.mapUtils.getHeatmap(style);\n            return _this;\n        }\n        class_1.prototype.trace = function (items, map$$1) {\n            var _this = this;\n            this.entities = items.map(function (item) { return ({ item: item }); });\n            this.map = map$$1 || this.mapInstance.map;\n            if (this.map) {\n                if (items) {\n                    var latLngs = items.reduce(function (acc, item) {\n                        var position = _this.getPosition(item);\n                        return position ? acc.concat([position]) : acc;\n                    }, []);\n                    this.mapInstance.mapUtils.updateHeatMapLatlng(latLngs, this.heatmap);\n                    this.mapInstance.mapUtils.setMap(this.heatmap, this.map);\n                }\n                else {\n                    this.clear();\n                }\n            }\n            else {\n                console.warn(\"Map is not initialized\");\n                return false;\n            }\n        };\n        class_1.prototype.getBounds = function (item, bounds) {\n            var position = this.getPosition(item);\n            return this.mapInstance.mapUtils.extendBounds(position, bounds);\n        };\n        class_1.prototype.clear = function () {\n            this.trace([]);\n        };\n        return class_1;\n    }(Base));\n}\nvar StopsHeatmap = /*@__PURE__*/ (function () {\n    function StopsHeatmap(mapInstance) {\n        this.name = \"stop heatmap\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case \"google\": {\n                        return {\n                            default: {}\n                        };\n                    }\n                    case \"leaflet\": {\n                        return {\n                            default: {\n                                radius: 7,\n                                minOpacity: 0.6\n                            }\n                        };\n                    }\n                }\n            }\n        };\n        this.mapInstance = mapInstance;\n    }\n    StopsHeatmap.prototype.getPosition = function (item) {\n        return {\n            lat: item.place__location[1],\n            lng: item.place__location[0],\n            weight: item.intensity\n        };\n    };\n    return StopsHeatmap;\n}());\nvar StopsHeatmapTrace = ExtendBoundsMixin(DataObservableMixin(HeatmapMixin(StyleMixin(MapItemsMixin(StopsHeatmap)))));\nvar ActionsCluster = /*@__PURE__*/ (function () {\n    function ActionsCluster(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {\n                                flat: true,\n                                anchor: RichMarkerPosition.MIDDLE,\n                                zIndex: 1\n                            },\n                            popup: {\n                                pixelOffset: new google.maps.Size(0, -5),\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                iconAnchor: [12, 12]\n                                // iconSize: [35, 35],\n                                // className: 'current-action-marker',\n                                // iconAnchor: point(15, 43)\n                                // iconAnchor: [15, 43]\n                            },\n                            popup: {\n                                // offset: point(0, -35),\n                                offset: [0, -5],\n                                closeButton: false\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    ActionsCluster.prototype.getPosition = function (data) {\n        return htAction(data).getPosition();\n    };\n    ActionsCluster.prototype.getDivContent = function (action) {\n        var icon = \"<div class=\\\"action-marker flex-row\\\">\\n<span style=\\\"margin: auto\\\">\" + NameCase(action.type[0]) + \"</span>\\n</div>\";\n        return icon;\n    };\n    ActionsCluster.prototype.getInfoContent = function (item) {\n        function htShow(item, style) {\n            if (style === void 0) {\n                style = \"flex\";\n            }\n            return \"display: \" + (item ? style : \"none\");\n        }\n        var userName = item.user ? item.user.name : '';\n        return \"<div class=\\\"flex-column flex-center\\\" style=\\\"min-width: 180px\\\">\\n<div class=\\\"\\\">\\n    <div class=\\\"text-center\\\">\" + NameCase(item.type) + \"\\n    <span style=\\\"\" + htShow(item.display.duration_remaining && !item.display.show_summary) + \"\\\"> in \" + HMString(item.display.duration_remaining / 60) + \"</span>\\n    <span style=\\\"\" + htShow(!!item.completed_at) + \"\\\"> completed at \" + TimeString(item.completed_at) + \"</span>\\n   \\n    </div>\\n</div>\\n    <div class=\\\"text-muted text-center\\\" style=\\\"\" + htShow(!!item.completed_at) + \"\\\"> \" + DateString(item.completed_at) + \"</div>\\n<div class=\\\"text-center\\\">\" + NameCase(userName) + \"<span style=\\\"\" + htShow(!!item.lookup_id, 'block') + \"\\\"> | #\" + item.lookup_id + \"</span></div>\\n</div>\";\n    };\n    ActionsCluster.prototype.traceEffect = function () {\n    };\n    return ActionsCluster;\n}());\nvar ActionsClusterTrace = DataObservableMixin(PopupMixin(ClusterMixin(TraceMixin(ExtendBoundsMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsCluster)))))))));\nvar ActionsHeatmap = /*@__PURE__*/ (function () {\n    function ActionsHeatmap(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case \"google\": {\n                        return {\n                            default: {}\n                        };\n                    }\n                    case \"leaflet\": {\n                        return {\n                            default: {\n                                radius: 7,\n                                minOpacity: 0.6\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    ActionsHeatmap.prototype.getPosition = function (item) {\n        return {\n            lat: item.completed_place__location[1],\n            lng: item.completed_place__location[0],\n        };\n    };\n    return ActionsHeatmap;\n}());\nvar ActionsHeatmapTrace = ExtendBoundsMixin(DataObservableMixin(ExtendBoundsMixin(HeatmapMixin(StyleMixin(MapItemsMixin(ActionsHeatmap))))));\nvar __assign$5 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar HtMapClass = /*@__PURE__*/ (function () {\n    // clusters = [];\n    // map$ = new ReplaySubject();\n    function HtMapClass(mapType, options) {\n        if (mapType === void 0) {\n            mapType = \"leaflet\";\n        }\n        if (options === void 0) {\n            options = {};\n        }\n        this.mapType = mapType;\n        // map: HtMap;\n        // mapUtils: MapUtils;\n        // userData$: Observable<IUserData | null>;\n        this.mapInstance = new MapInstance();\n        this.leafletSetBoundsOptions = {\n            animate: true,\n            duration: 0.3\n        };\n        this.googleSetBoundsOptions = {};\n        this.googleMapOptions = {\n            center: { lat: 0, lng: 0 },\n            zoom: 2,\n            fullscreenControl: false,\n            streetViewControl: false,\n            styles: LightColorMapStyle\n        };\n        this.leafletMapOptions = { center: [3.505, 0], zoom: 2 };\n        this.mapItemsSet = [];\n        mapTypeService.getInstance(mapType);\n        if (options.mapKey) {\n            // mapTypeService.getInstance().setKey(options.mapKey);\n        }\n        this.usersCluster = new UsersClusterTrace(this.mapInstance);\n        this.actionsCluster = new ActionsClusterTrace(this.mapInstance);\n        this.usersHeatmap = new StopsHeatmapTrace(this.mapInstance);\n        this.actionsHeatmap = new ActionsHeatmapTrace(this.mapInstance);\n        this.placeline = new PlacelineTrace({ mapInstance: this.mapInstance });\n    }\n    Object.defineProperty(HtMapClass.prototype, \"segmentTrace\", {\n        get: function () {\n            return this.placeline;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HtMapClass.prototype, \"map$\", {\n        get: function () {\n            return this.mapInstance.map$;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HtMapClass.prototype, \"map\", {\n        get: function () {\n            return this.mapInstance.map;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HtMapClass.prototype.initMap = function (elem, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var mapOptions = this.mapType == \"leaflet\"\n            ? this.leafletMapOptions\n            : this.googleMapOptions;\n        var map$$1 = this.mapInstance.mapUtils.renderMap(elem, __assign$5({}, mapOptions, options));\n        this.mapInstance.setMap(map$$1);\n        return map$$1;\n    };\n    // setPlacelineData$(data$: Observable<IUserData | null>) {\n    //   if (this.userDataSub) {\n    //     this.userDataSub.unsubscribe();\n    //   }\n    //   this.initUserDataObserver(data$)\n    // }\n    //\n    // private initUserDataObserver(data$: Observable<IUserData | null>) {\n    //   let userData$ = data$.scan((acc, data) => {\n    //     const oldId = acc.user ? acc.user.id : null;\n    //     const currentId = data ? data.id : null;\n    //     const isNew = currentId && oldId ? currentId !== oldId : true;\n    //     return {user: data, isNew, oldId }\n    //   }, {user: null, oldId: null, isNew: true});\n    //\n    //   let sub = userData$.subscribe((acc) => {\n    //     const userData = acc.user;\n    //     const isNew = acc.isNew;\n    //     this.tracePlaceline(userData);\n    //     if(isNew) this.resetBounds()\n    //   });\n    //   this.userDataSub = sub;\n    // }\n    HtMapClass.prototype.tracePlaceline = function (user) {\n        this.placeline.trace(user);\n    };\n    HtMapClass.prototype.resetBounds = function (options) {\n        this.mapInstance.resetBounds(options);\n    };\n    HtMapClass.prototype.getBoundsItem = function (items) {\n        var _this = this;\n        var bounds = this.mapInstance.mapUtils.extendItemBounds();\n        return reduce(items, function (bounds, item) {\n            return _this.getBounds(bounds, item);\n        }, bounds);\n    };\n    HtMapClass.prototype.getBounds = function (bounds, item) {\n        return item.extendBounds(bounds);\n    };\n    HtMapClass.prototype.setBounds = function (bounds, options) {\n        options =\n            options || this.mapType == \"leaflet\"\n                ? this.leafletSetBoundsOptions\n                : this.googleSetBoundsOptions;\n        this.mapInstance.mapUtils.setBounds(this.map, bounds, options);\n    };\n    HtMapClass.prototype.inValidateSize = function () {\n        this.mapInstance.mapUtils.invalidateSize(this.map);\n    };\n    HtMapClass.prototype.addEntities = function (entities) {\n        this.mapInstance.addToItemsSet(entities);\n    };\n    HtMapClass.prototype.clear = function () {\n        this.mapInstance.setMap(null);\n    };\n    return HtMapClass;\n}());\nvar DestinationMap = /*@__PURE__*/ (function () {\n    function DestinationMap(mapInstance) {\n        this.name = \"Destination\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {},\n                            popup: {\n                                pixelOffset: new google.maps.Size(0, -5),\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                zIndexOffset: 10,\n                                iconSize: [30, 30],\n                                className: \"destination-marker\"\n                            }\n                        };\n                    }\n                }\n            }\n        };\n        this.mapInstance = mapInstance;\n    }\n    DestinationMap.prototype.getPosition = function (data) {\n        var place = data.completed_place || data.expected_place;\n        if (place && place.location) {\n            return { lat: place.location.coordinates[1], lng: place.location.coordinates[0] };\n        }\n        else {\n            return null;\n        }\n    };\n    DestinationMap.prototype.getDivContent = function () {\n        return \"<div style=\\\"width: 30px; height: 30px; background: #00C94B; border-radius: 50%\\\"></div>\";\n    };\n    return DestinationMap;\n}());\nvar DestinationMarker = DataObservableMixin(ExtendBoundsMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(DestinationMap)))))));\nvar __extends$23 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction AnimationsEntitiesMixin(Base) {\n    return (function (_super) {\n        __extends$23(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            // bearing: number = 0;\n            // item;\n            _this.isAnimated = true;\n            _this.toNotTraceItem = false;\n            _this.subs = {};\n            return _this;\n        }\n        class_1.prototype.setTimeAwareAnimationEntity = function (animationEntity) {\n            this.animationEntities = animationEntity || new AnimationsEntities();\n        };\n        class_1.prototype.clearItem = function (entity) {\n            var id = this.trackBy(entity.data);\n            var animId = entity.data.id;\n            this.animationEntities.clearItem(animId);\n            this.clearSub(id);\n            _super.prototype.clearItem.call(this, entity);\n        };\n        class_1.prototype.update = function (entity, pathBearing) {\n            var id = this.trackBy(entity.data);\n            var animId = entity.data.id;\n            this.initSub(id, animId);\n            var encodedString = this.getTimeAwarePolyline ? this.getTimeAwarePolyline(entity.data) : null;\n            if (encodedString) {\n                this.animationEntities.update(id, encodedString);\n            }\n            else {\n                // super.update(entity, {path, bearing})\n            }\n        };\n        class_1.prototype.initSub = function (id, animId) {\n            var _this = this;\n            animId = animId || id;\n            var sub = this.subs[id];\n            if (sub) {\n            }\n            else {\n                if (this['name'] == \"action user\")\n                    console.log(\"id sub craete sub\");\n                var newsub = this.animationEntities\n                    .getEntity(animId)\n                    .updateEvent\n                    .subscribe('update', function (_a) {\n                    var path = _a.path, bearing = _a.bearing;\n                    var entity = _this.getEntity(id);\n                    if (entity) {\n                        _super.prototype.update.call(_this, entity, { path: path, bearing: bearing });\n                    }\n                });\n                this.subs[id] = newsub;\n            }\n        };\n        class_1.prototype.clearSub = function (id) {\n            var sub = this.subs[id];\n            sub.unsubscribe();\n            delete this.subs[id];\n        };\n        return class_1;\n    }(Base));\n}\nvar AnimationsEntities = /*@__PURE__*/ (function () {\n    function AnimationsEntities() {\n        this.enitites = {};\n    }\n    AnimationsEntities.prototype.clearItem = function (id) {\n        var entity = this.enitites[id];\n        entity.clear();\n        delete this.enitites[id];\n    };\n    AnimationsEntities.prototype.update = function (id, polyline$$1) {\n        var entity = this.getEntity(id);\n        entity.updatePolylineString(polyline$$1);\n    };\n    AnimationsEntities.prototype.getEntity = function (id) {\n        var entity = this.enitites[id];\n        if (entity) {\n            return entity;\n        }\n        else {\n            var newEntity = new TimeAwareAnimation();\n            this.enitites[id] = newEntity;\n            return newEntity;\n        }\n    };\n    return AnimationsEntities;\n}());\nvar ActionsDataPolyline = /*@__PURE__*/ (function () {\n    function ActionsDataPolyline(mapInstance) {\n        this.name = \"Actions data polyline\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {},\n                            popup: {\n                                pixelOffset: new google.maps.Size(0, -5),\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                fillColor: '#9155f4',\n                                color: '#9155f4',\n                                weight: 5\n                                // iconAnchor: [12, 12]\n                                // iconSize: [35, 35],\n                                // className: 'current-action-marker',\n                                // iconAnchor: point(15, 43)\n                                // iconAnchor: [15, 43]\n                            },\n                            popup: {\n                                // offset: point(0, -35),\n                                offset: [0, -5],\n                                closeButton: false\n                            }\n                        };\n                    }\n                }\n            }\n        };\n        this.mapInstance = mapInstance;\n    }\n    ActionsDataPolyline.prototype.getEncodedPositionTime = function (data) {\n        return data.time_aware_polyline;\n    };\n    //todo remove this, use getTimeAwarePolyline\n    ActionsDataPolyline.prototype.getEncodedPath = function (data) {\n        return data.encoded_polyline;\n    };\n    ActionsDataPolyline.prototype.getPosition = function (action) {\n        var position = action.user ?\n            action.user.last_location ? action.user.last_location.geojson.coordinates : null\n            : null;\n        return position ? { lat: position[1], lng: position[0] } : null;\n    };\n    ActionsDataPolyline.prototype.getTimeAwarePolyline = function (data) {\n        return data.time_aware_polyline;\n    };\n    return ActionsDataPolyline;\n}());\n// export interface IActionsPolylineBase {\n//   mapInstance: MapInstance\n//   // getStyle: (styleType?) => object;\n// }\n//\n// export function ActionsPolylineMixin<TBase extends Constructor<IActionsPolylineBase>>(Base: TBase) {\n//   return class extends Base {\n//     start;\n//\n//\n//\n//\n//\n//   };\n// }\nvar ActionsPolylineTrace$1 = DataObservableMixin(AnimationsEntitiesMixin(TraceMixin(ExtendBoundsMixin(PolylinesMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionsDataPolyline))))))));\n// export const ActionsPolylineTrace = DataObservableMixin(AnimationMixin(TraceMixin(PolylinesMixin(StyleMixin(ActionsDataPolyline)))))\nvar StartMarker = /*@__PURE__*/ (function () {\n    function StartMarker(mapInstance) {\n        this.name = \"Start marker\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case 'google': {\n                        return {\n                            default: {},\n                            popup: {\n                                pixelOffset: new google.maps.Size(0, -5),\n                            }\n                        };\n                    }\n                    case 'leaflet': {\n                        return {\n                            default: {\n                                zIndexOffset: 10,\n                                iconSize: [20, 20],\n                                className: \"destination-marker\"\n                            }\n                        };\n                    }\n                }\n            }\n        };\n        this.mapInstance = mapInstance;\n    }\n    StartMarker.prototype.trace = function (mapItem) {\n    };\n    StartMarker.prototype.getPosition = function (data) {\n        var place = data.started_place;\n        if (place && place.location) {\n            return { lat: place.location.coordinates[1], lng: place.location.coordinates[0] };\n        }\n        else {\n            return null;\n        }\n    };\n    StartMarker.prototype.getDivContent = function () {\n        return \"<div style=\\\"width: 20px; height: 20px; background: #9013FE; border-radius: 50%\\\"></div>\";\n    };\n    return StartMarker;\n}());\nvar StartMarkerTrace = ExtendBoundsMixin(DataObservableMixin(TraceMixin(DivMarkersMixin(MarkersMixin(StyleMixin(MapItemsMixin(StartMarker)))))));\nvar ActionUser = /*@__PURE__*/ (function () {\n    function ActionUser(mapInstance) {\n        this.mapInstance = mapInstance;\n        this.name = \"action user\";\n        this.styleFunct = {\n            get: function (type) {\n                switch (type) {\n                    case \"google\":\n                        {\n                            return {\n                                default: {\n                                    flat: true,\n                                    anchor: RichMarkerPosition.BOTTOM_CENTER\n                                }\n                            };\n                        }\n                        ;\n                    case \"leaflet\": {\n                        return {\n                            default: {\n                                zIndexOffset: 10,\n                                iconSize: [60, 60],\n                                className: \"action-marker\"\n                                // iconAnchor: point(15, 43)\n                                // iconAnchor: [0, 0]\n                            }\n                        };\n                    }\n                }\n            }\n        };\n    }\n    ActionUser.prototype.getPosition = function (data) {\n        return htUser(data.user).getPosition();\n    };\n    ActionUser.prototype.trackBy = function (action) {\n        return action.user.id;\n    };\n    ActionUser.prototype.trackAnimationBy = function (action) {\n        return action.id;\n    };\n    ActionUser.prototype.getDivContent = function (data) {\n        var content = \"\\n    <div style=\\\"border-radius: 50%; height: 60px; width: 60px; background: rgba(95,143,213,0.67) \\\">\\n  <div style=\\\"height: 30px; width: 30px; background-image: url('\" + data.user.photo + \"'); background-repeat: no-repeat;\\n  background-size: cover;     top: 15px;\\n    position: relative;\\n    left: 15px;\\n    border-radius: 50%;\\\"></div>\\n</div> \\n    \";\n        return content;\n    };\n    return ActionUser;\n}());\nvar ActionUserTrace = DataObservableMixin(ExtendBoundsMixin(AnimationsEntitiesMixin(DivMarkersMixin(TraceMixin(MarkersMixin(StyleMixin(MapItemsMixin(ActionUser))))))));\nvar ActionMap = /*@__PURE__*/ (function () {\n    function ActionMap(mapInstance, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        this.anim = new AnimationsEntities();\n        this.mapInstance = mapInstance;\n        this.destination = new DestinationMarker(mapInstance);\n        this.polyline = new ActionsPolylineTrace$1(mapInstance);\n        this.polyline.setTimeAwareAnimationEntity(this.anim);\n        this.user = new ActionUserTrace(mapInstance);\n        this.user.setTimeAwareAnimationEntity(this.anim);\n        if (options.hasPulse) {\n            this.pulse = new ActionUserTrace(mapInstance);\n            this.pulse.setTimeAwareAnimationEntity(this.anim);\n        }\n        // this.user.setTimeAwareAnimation(this.anim);\n        // this.user.toNotTraceItem = true;\n        this.start = new StartMarkerTrace(mapInstance);\n    }\n    ActionMap.prototype.setData$ = function (data$) {\n        this.destination.setData$(data$);\n        this.polyline.setData$(data$);\n        this.start.setData$(data$);\n        if (this.pulse)\n            this.pulse.setData$(data$.pipe(map(function (actions) {\n                return actions.reduce(function (acc, action) {\n                    return action.display.show_summary ? acc : acc.concat([action]);\n                }, []);\n            })));\n        this.user.setData$(data$.pipe(map(function (actions) {\n            return actions.reduce(function (acc, action) {\n                return action.display.show_summary ? acc : acc.concat([action]);\n            }, []);\n        })));\n    };\n    return ActionMap;\n}());\nvar ActionTrace = ActionMap;\nexport { MapInstance, Placeline, PlacelineTrace, HtMapClass, mapTypeService, mapItemsFactory, itemsBaseFactory, itemsFactory, MarkersBase, UsersCluster, UsersClusterTrace, ActionMarkers, ActionMarkersTrace, SegmentPolylines, SegmentPolylinesTrace, stopMarkersConfig, stopMarkersTrace, StopMarkers, StopMarkersTrace, currentUserConfig, currentUserTrace, CurrentUser, CurrentUserTrace, ActionsHeatmap, ActionsHeatmapTrace, StopsHeatmap, StopsHeatmapTrace, ActionsCluster, ActionsClusterTrace, DestinationMap, DestinationMarker, CompoundDataObservableMixin, AnimationMixin, CircleMixin, ClusterMixin, DataObservableMixin, DivMarkersMixin, ExtendBoundsMixin, HeatmapMixin, MarkersMixin, PolylinesMixin, PopupMixin, SingleItemMixin, StyleMixin, TraceMixin, ActionMap, ActionTrace };\n",null]}