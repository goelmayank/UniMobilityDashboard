{"remainingRequest":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Github/UniDashboard/node_modules/ht-data/dist/ht-data.es5.js","dependencies":[{"path":"/Github/UniDashboard/node_modules/ht-data/dist/ht-data.es5.js","mtime":0},{"path":"/Github/UniDashboard/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Github/UniDashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import _ from 'underscore';\nimport { DateString, DistanceLocale, DotString, GetDateRangeQuery, GetMinute, HMString, IsRangeADay, IsRangeToday, NameCase, TimeString, isSameRange } from 'ht-utility';\nimport { addDays, addSeconds, endOfToday, endOfYesterday, isSameDay, isToday, startOfDay, startOfMonth, startOfToday, startOfYesterday } from 'date-fns';\nimport { combineLatest as combineLatest$1 } from 'rxjs/observable/combineLatest';\nimport { distinctUntilChanged, expand, filter, map, scan, share } from 'rxjs/operators';\nimport { of as of$1 } from 'rxjs/observable/of';\nimport { empty as empty$1 } from 'rxjs/observable/empty';\nvar __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar HtAction = /*@__PURE__*/ (function () {\n    function HtAction(data) {\n        this.data = data;\n        this.types = [\"delivery\", \"pickup\", \"task\", \"visit\", \"stopover\", \"trip\"];\n        this.sortingQueryMap = {\n            assigned_at: \"Assigned\",\n            completed_at: \"Completed\",\n            type: \"Type\",\n            user__name: \"User name\",\n            status: \"Status\"\n        };\n        this.ontimeFilters = [\n            { event_flags: \"action.delayed\" },\n            { event_flags: \"action.completed_late\" }\n        ];\n        this.statusQueryMap = {\n            created: \"Not yet started\",\n            \"assigned,started\": \"Assigned\",\n            \"started,assigned\": \"Assigned\",\n            completed: \"Completed\"\n        };\n        this.ontimeQueryMap = {\n            \"action.delayed\": \"Running delayed\",\n            \"action.completed_late\": \"Completed late\"\n        };\n        this.markerFilterMap = {\n            \"assigned,started\": function (action) {\n                return action.status == \"assigned\" || action.status == \"started\";\n            },\n            \"started,assigned\": function (action) {\n                return action.status == \"assigned\" || action.status == \"started\";\n            },\n            completed: function (action) {\n                return action.status == \"completed\";\n            },\n            created: function (action) {\n                return action.status == \"created\";\n            }\n        };\n    }\n    Object.defineProperty(HtAction.prototype, \"filterQueryMap\", {\n        get: function () {\n            return __assign({}, this.statusQueryMap, this.ontimeQueryMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HtAction.prototype, \"sortings\", {\n        get: function () {\n            return Object.keys(this.sortingQueryMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HtAction.prototype.getStatusString = function (status) {\n        return this.statusQueryMap[status] || status;\n    };\n    HtAction.prototype.getOntimeString = function (value) {\n        return this.ontimeQueryMap[value] || value;\n    };\n    HtAction.prototype.getFilterString = function (value) {\n        return this.filterQueryMap[value] || value;\n    };\n    HtAction.prototype.getSortingString = function (value) {\n        return this.sortingQueryMap[value] || value;\n    };\n    HtAction.prototype.getMarkerFilter = function (key) {\n        var filter$$1 = this.markerFilterMap[key];\n        if (key) {\n            if (filter$$1) {\n                return filter$$1;\n            }\n            else {\n                return function () { return false; };\n            }\n        }\n        else {\n            return function () { return true; };\n        }\n    };\n    HtAction.prototype.getMarkerSeached = function (key) {\n        return function (action) {\n            return ((action.lookup_id && action.lookup_id.indexOf(key) > -1) ||\n                (action.user && action.user.name.indexOf(key) > -1));\n        };\n    };\n    HtAction.prototype.isAwayFromExpected = function () {\n        var action = this.data;\n        if (action.expected_place && action.event_flags) {\n            var flag = _.find(action.event_flags, function (flag) {\n                return (flag[\"type\"] == \"action.completed_at_different_place_than_expected\");\n            });\n            return !!flag;\n        }\n        return false;\n    };\n    HtAction.prototype.isValidMarker = function (action) {\n        action = action || this.data;\n        return !!((action.expected_place && action.expected_place.location) ||\n            (action.completed_place && action.completed_place.location));\n    };\n    HtAction.prototype.getDateRangeQuery = function (query) {\n        return GetDateRangeQuery(query, \"created_at\");\n    };\n    HtAction.prototype.getPositionsObject = function () {\n        var completedPosition = this.getCompletedPosition();\n        var expectedPosition = this.getExpectedPosition();\n        var isAwayFromExpected = this.isAwayFromExpected();\n        return {\n            completedPosition: completedPosition,\n            expectedPosition: expectedPosition,\n            isAwayFromExpected: isAwayFromExpected,\n            hasEnded: this.hasEnded(),\n            position: completedPosition || expectedPosition\n        };\n    };\n    HtAction.prototype.getCompletedPosition = function () {\n        var action = this.data;\n        if (action && action.completed_place && action.completed_place.location) {\n            var compLoc = action.completed_place.location.coordinates;\n            var lat = compLoc[1];\n            var lng = compLoc[0];\n            return { lat: lat, lng: lng };\n            // return [compLoc[1], compLoc[0]]\n        }\n        return null;\n    };\n    HtAction.prototype.getExpectedPosition = function () {\n        var action = this.data;\n        if (action && action.expected_place && action.expected_place.location) {\n            var expLoc = action.expected_place.location.coordinates;\n            var lat = expLoc[1];\n            var lng = expLoc[0];\n            return { lat: lat, lng: lng };\n            // return [expLoc[1], expLoc[0]]\n        }\n        return null;\n    };\n    HtAction.prototype.getPosition = function () {\n        return this.getPositionsObject().position;\n    };\n    HtAction.prototype.hasEnded = function () {\n        return !!this.data.display.ended_at;\n    };\n    HtAction.prototype.getETATimestamp = function () {\n        var action = this.data;\n        if (action.display.duration_remaining) {\n            return addSeconds(new Date(), action.display.duration_remaining).toISOString();\n        }\n        return null;\n    };\n    HtAction.prototype.getHeatmapLatlng = function (item) {\n        return {\n            lat: item.completed_place__location[1],\n            lng: item.completed_place__location[0],\n        };\n    };\n    HtAction.prototype.getHeatLatlngs = function (items) {\n        return _.reduce(items, function (acc, place) {\n            var placeLatlng = [place.completed_place__location[1], place.completed_place__location[0]];\n            var placeArray = Array(place.num_actions).fill(placeLatlng);\n            return acc.concat(placeArray);\n        }, []);\n    };\n    return HtAction;\n}());\nvar htAction = function (action) { return new HtAction(action); };\nvar __assign$1 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar HtUser = /*@__PURE__*/ (function () {\n    function HtUser(data) {\n        this.data = data;\n        this.statusQueryMap = {\n            stopped: \"Stopped\",\n            on_trip: \"Moving\",\n            logged_off: \"Logged off\",\n            \"location_disabled,network_offline\": \"Error\",\n            location_disabled: \"Location disabled\",\n            network_offline: \"Network offline\",\n            never_tracked: \"Never tracked\"\n        };\n        this.sortingQueryMap = {\n            num_trips: \"Trips\",\n            name: \"Name\",\n            status: \"Status\",\n            num_places: \"Places\",\n            total_distance: \"Distance\",\n            total_duration: \"Duration\",\n            stop_duration: \"Stop duration\",\n            location_disabled_duration: \"Location disabled\",\n            network_offline_duration: \"Network offline\",\n            num_actions: \"Actions\",\n            last_heartbeat_at: \"Last updated\"\n        };\n        this.markerFilterMap = {\n            stopped: function (user) {\n                return user.status == \"stopped\";\n            },\n            on_trip: function (user) {\n                return (user.status == \"walk\" ||\n                    user.status == \"run\" ||\n                    user.status == \"cycle\" ||\n                    user.status == \"drive\" ||\n                    user.status == \"moving\");\n                //moving: walk, drive, cycle, run\n            },\n            logged_off: function (user) {\n                return user.status == \"logged_off\";\n            },\n            location_disabled: function (user) {\n                return user.status == \"location_disabled\";\n            },\n            network_offline: function (user) {\n                return user.status == \"network_offline\";\n            }\n        };\n    }\n    HtUser.prototype.getMarkerSearched = function (key) {\n        return function (user) {\n            if (!user.name)\n                return false;\n            var name = user.name.toLowerCase();\n            key = key.toLowerCase();\n            return name.includes(key);\n        };\n    };\n    HtUser.prototype.getMarkerFilter = function (key) {\n        var filter$$1 = this.markerFilterMap[key];\n        if (key) {\n            if (filter$$1) {\n                return filter$$1;\n            }\n            else {\n                return function () { return false; };\n            }\n        }\n        else {\n            return function () { return true; };\n        }\n    };\n    Object.defineProperty(HtUser.prototype, \"sortings\", {\n        get: function () {\n            return Object.keys(this.sortingQueryMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HtUser.prototype.getSegmentTypes = function (userSegments) {\n        return _.reduce(userSegments, function (segmentType, segment) {\n            if (segment.type == \"stop\") {\n                if (segment.location && segment.location.geojson)\n                    segmentType.stopSegment.push(segment);\n            }\n            else {\n                if (segment.encoded_polyline)\n                    segmentType.tripSegment.push(segment);\n            }\n            return segmentType;\n        }, { tripSegment: [], stopSegment: [] });\n    };\n    HtUser.prototype.getPosition = function () {\n        var data = this.data;\n        if (data.last_location && data.last_location.geojson) {\n            var lat = data.last_location.geojson.coordinates[1];\n            var lng = data.last_location.geojson.coordinates[0];\n            return { lat: lat, lng: lng };\n            // return L.latLng([item.last_location.geojson.coordinates[1], item.last_location.geojson.coordinates[0]])\n        }\n        else {\n            return null;\n        }\n    };\n    HtUser.prototype.isValidMarker = function (user) {\n        user = user || this.data;\n        return !!(user.last_location && user.last_location.geojson);\n    };\n    return HtUser;\n}());\nvar htUser = function (user) {\n    var extras = {\n        statusQueryMap: {\n            stopped: \"Stopped\",\n            on_trip: \"Moving\",\n            logged_off: \"Logged off\",\n            \"location_disabled,network_offline\": \"Error\",\n            location_disabled: \"Location disabled\",\n            network_offline: \"Network offline\",\n            never_tracked: \"Never tracked\"\n        },\n        sortingQueryMap: {\n            num_trips: \"Trips\",\n            name: \"Name\",\n            status: \"Status\",\n            num_places: \"Places\",\n            total_distance: \"Distance\",\n            total_duration: \"Duration\",\n            stop_duration: \"Stop duration\",\n            location_disabled_duration: \"Location disabled\",\n            network_offline_duration: \"Network offline\",\n            num_actions: \"Actions\",\n            last_heartbeat_at: \"Last updated\"\n        },\n        markerFilterMap: {\n            stopped: function (user) {\n                return user.status == \"stopped\";\n            },\n            on_trip: function (user) {\n                return (user.status == \"walk\" ||\n                    user.status == \"run\" ||\n                    user.status == \"cycle\" ||\n                    user.status == \"drive\" ||\n                    user.status == \"moving\");\n                //moving: walk, drive, cycle, run\n            },\n            logged_off: function (user) {\n                return user.status == \"logged_off\";\n            },\n            location_disabled: function (user) {\n                return user.status == \"location_disabled\";\n            },\n            network_offline: function (user) {\n                return user.status == \"network_offline\";\n            }\n        },\n        getMarkerSearched: function (key) {\n            return function (user) {\n                if (!user.name)\n                    return false;\n                var name = user.name.toLowerCase();\n                key = key.toLowerCase();\n                return name.includes(key);\n            };\n        },\n        getMarkerFilter: function (key) {\n            var filter$$1 = this.markerFilterMap[key];\n            if (key) {\n                if (filter$$1) {\n                    return filter$$1;\n                }\n                else {\n                    return function () { return false; };\n                }\n            }\n            else {\n                return function () { return true; };\n            }\n        }\n    };\n    return __assign$1({ data: user, isValidMarker: function () {\n            var user = this.data;\n            return !!(user.last_location && user.last_location.geojson);\n        },\n        getPosition: function () {\n            if (this.isValidMarker()) {\n                return this.getValidPosition();\n            }\n            else {\n                return null;\n            }\n        },\n        getValidPosition: function () {\n            var data = this.data;\n            var lat = data.last_location.geojson.coordinates[1];\n            var lng = data.last_location.geojson.coordinates[0];\n            return { lat: lat, lng: lng };\n        },\n        // update(user) {\n        //   return {...this, ...user}\n        // },\n        getInfoContent: function () {\n            var user = this;\n            return user.name;\n        } }, extras);\n};\nvar HtEvent = /*@__PURE__*/ (function () {\n    function HtEvent(data) {\n        this.data = data;\n    }\n    HtEvent.prototype.getEventDisplay = function (event) {\n        event = event || this.data;\n        switch (event.type) {\n            case \"tracking.started\":\n                return {\n                    text: \"Tracking started\",\n                    subText: \"\"\n                };\n            case \"tracking.ended\":\n                return {\n                    text: \"Tracking ended\",\n                    subText: \"\"\n                };\n            // case 'device.location.disabled':\n            //   return {\n            //     text: 'Location disabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location.enabled':\n            //   return {\n            //     text: 'Location enabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location_permission.disabled':\n            //   return {\n            //     text: 'Location permission disabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location_permission.enabled':\n            //   return {\n            //     text: 'Location permission enabled',\n            //     subtext: ''\n            //   };\n            case \"device.secondary.ignored\":\n                return {\n                    text: \"Secondary device ignored\",\n                    subText: \"\"\n                };\n        }\n    };\n    return HtEvent;\n}());\nvar htEvent = function (event) { return new HtEvent(event); };\nvar __assign$3 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar CommonFunctions = {\n    setEntityCountMap: function (entity, entityCountMap, uniqueProp) {\n        if (entity === void 0) {\n            entity = {};\n        }\n        if (entityCountMap === void 0) {\n            entityCountMap = {};\n        }\n        if (uniqueProp === void 0) {\n            uniqueProp = \"id\";\n        }\n        var newEntityMap = __assign$3({}, entityCountMap);\n        var type = entity[uniqueProp] + \"-count\";\n        var id = entity[\"id\"];\n        var typeCount = entityCountMap[type];\n        var actionShort = entityCountMap[id];\n        if (typeCount) {\n            if (!actionShort) {\n                newEntityMap[type] = entityCountMap[type] + 1;\n                newEntityMap[id] = \"\" + entityCountMap[type];\n            }\n        }\n        else {\n            newEntityMap[type] = 1;\n            newEntityMap[id] = \"\";\n        }\n        // console.log(actionMap, \"map\");\n        return newEntityMap;\n    }\n};\nvar __assign$2 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar HtPlaceline = /*@__PURE__*/ (function () {\n    function HtPlaceline(userData) {\n        this.userData = userData;\n    }\n    HtPlaceline.prototype.getPlacelineSegments = function () {\n        var _this = this;\n        var userData = this.userData;\n        var _a = this.createActivitiesSegments(userData), lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;\n        var actionsMarks = this.createActionsMarks(userData.actions);\n        var eventsMarks = _.map(userData.events, function (event) {\n            return _this.createEventMark(event);\n        });\n    };\n    HtPlaceline.prototype.createActivitiesSegments = function (userData) {\n        var _this = this;\n        var segments = userData.segments;\n        var _a = _.reduce(segments.concat([{}]), function (_a, segment) {\n            var lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;\n            var nextLastSegment = segment;\n            if (lastSegment) {\n                if (segment.id) {\n                    var activitySegment = _this.createActivitySegment(lastSegment);\n                    if (activitySegment)\n                        activitySegments.push(activitySegment);\n                }\n                else {\n                    //last segment\n                    nextLastSegment = _this.getLastSegment(segment, userData.last_heartbeat_at);\n                }\n            }\n            return { lastSegment: nextLastSegment, activitySegments: activitySegments };\n        }, { activitySegments: [], lastSegment: null }), lastSegment = _a.lastSegment, activitySegments = _a.activitySegments;\n        return { lastSegment: lastSegment, activitySegments: activitySegments };\n    };\n    HtPlaceline.prototype.createActivitySegment = function (segment) {\n        var placelineTime = segment.started_at;\n        var activityText = this.getActivityText(segment);\n        var activityAddress = this.getActivityPlaceAddress(segment);\n        var end = segment.ended_at ? new Date(segment.ended_at).getTime() : null;\n        return __assign$2({ placelineTime: placelineTime,\n            activityText: activityText }, this.getActivityStyleClass(segment), { segmentId: segment.id, segment: segment, start: new Date(placelineTime).getTime(), end: end });\n    };\n    HtPlaceline.prototype.createEventSegment = function (eventMark, segment) {\n        return __assign$2({}, segment, { placelineTime: eventMark.event.recorded_at }, eventMark);\n    };\n    HtPlaceline.prototype.createActionSegment = function (actionMark, segment) {\n        return __assign$2({}, segment, { placelineTime: actionMark.actionTime }, actionMark);\n    };\n    HtPlaceline.prototype.createActionsMarks = function (actions) {\n        var actionMarksObj = _.reduce(actions, function (acc, action) {\n            // acc.actionCountMap = this.setActionCountMap(action, acc.actionCountMap);\n            // let assign: IActionMark = this.getActionMark(\n            //   action,\n            //   acc.actionCountMap,\n            //   false,\n            //   false\n            // );\n            // if (assign.actionTime) acc.actionMarks.push(assign);\n            // let end = this.getActionMark(\n            //   action,\n            //   acc.actionMarks,\n            //   true,\n            //   !!action.display.ended_at\n            // );\n            // acc.actionMarks.push(end);\n            return acc;\n        }, { actionMarks: [], actionCountMap: {} });\n        return actionMarksObj.actionMarks;\n    };\n    HtPlaceline.prototype.createEventMark = function (event) {\n        return { event: event, display: htEvent().getEventDisplay(event) };\n    };\n    HtPlaceline.prototype.getLastSegment = function (lastSeg, lastHearbeatAt) {\n        // let last = {time: lastSeg['last_heartbeat_at']};\n        var placelineTime;\n        var isLive = false;\n        if (lastSeg.ended_at) {\n            placelineTime = lastSeg.ended_at;\n        }\n        else {\n            isLive = true;\n            placelineTime = lastHearbeatAt;\n        }\n        return __assign$2({ placelineTime: placelineTime,\n            isLive: isLive, isLast: true, segmentId: lastSeg.id }, this.getActivityStyleClass(lastSeg));\n    };\n    HtPlaceline.prototype.isLive = function (placeline) {\n        var old = placeline.display.seconds_elapsed_since_last_heartbeat;\n        var date = placeline.timeline_date;\n        var status = placeline.display.status_text;\n        return status !== \"Tracking stopped\" && old < 15 * 60 && isToday(new Date(date));\n    };\n    HtPlaceline.prototype.getSegmentTypes = function (userSegments) {\n        return _.reduce(userSegments, function (segmentType, segment) {\n            if (segment.type == \"stop\") {\n                if (segment.location && segment.location.geojson)\n                    segmentType.stopSegment.push(segment);\n            }\n            else {\n                if (segment.encoded_polyline)\n                    segmentType.tripSegment.push(segment);\n            }\n            return segmentType;\n        }, { tripSegment: [], stopSegment: [] });\n    };\n    //helpers\n    HtPlaceline.prototype.getActivityStyleClass = function (segment) {\n        var activityClass = this.getActivityClass(segment);\n        return this.getActivityStyle(activityClass);\n    };\n    HtPlaceline.prototype.getActivityStyle = function (activityClass) {\n        if (activityClass === void 0) {\n            activityClass = \"no-info\";\n        }\n        return {\n            activityBg: activityClass + \"-bg\",\n            activityBorder: activityClass + \"-border\",\n            activityClass: activityClass,\n            activityColor: activityClass + \"-color\"\n        };\n    };\n    HtPlaceline.prototype.getActivityClass = function (segment) {\n        var type = segment.type;\n        if (type == \"location_void\") {\n            return \"warning\";\n        }\n        return type == \"stop\" ? \"stop\" : \"trip\";\n    };\n    HtPlaceline.prototype.setActionCountMap = function (action, actionCountMap) {\n        return CommonFunctions.setEntityCountMap(action, actionCountMap, \"type\");\n    };\n    HtPlaceline.prototype.getActionMark = function (action, actionMap, isEnd, isDone) {\n        return {\n            actionText: NameCase(action.type) + \" scheduled\",\n            actionTime: action.eta || null,\n            actionDot: NameCase(action.type[0]) + actionMap[action.id],\n            isEnd: isEnd,\n            isDone: isDone,\n            action: action\n        };\n    };\n    HtPlaceline.prototype.getActivityText = function (segment) {\n        if (segment.activity) {\n            return segment.activity;\n        }\n        else if (segment.type == \"stop\") {\n            return \"Stop\";\n        }\n        else if (segment.reason) {\n            return this.getLocationVoidText(segment);\n        }\n        else {\n            return NameCase(segment.type);\n        }\n    };\n    HtPlaceline.prototype.getActivityPlaceAddress = function (segment) {\n        if (segment.type == \"stop\" && segment.place && segment.place.locality) {\n            return segment.place.locality;\n        }\n        return \"\";\n    };\n    HtPlaceline.prototype.getLocationVoidText = function (segment) {\n        switch (segment.reason) {\n            case \"disabled\":\n                return \"Location disabled\";\n            case \"no_permission\":\n                return \"Location permission unavailable\";\n            case \"unknown\":\n                return \"Location unavailable\";\n            default:\n                return \"Location unavailable\";\n        }\n    };\n    HtPlaceline.prototype.getEventDisplay = function (event) {\n        switch (event.type) {\n            case \"tracking.started\":\n                return {\n                    text: \"Tracking started\",\n                    subtext: \"\"\n                };\n            case \"tracking.ended\":\n                return {\n                    text: \"Tracking ended\",\n                    subtext: \"\"\n                };\n            // case 'device.location.disabled':\n            //   return {\n            //     text: 'Location disabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location.enabled':\n            //   return {\n            //     text: 'Location enabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location_permission.disabled':\n            //   return {\n            //     text: 'Location permission disabled',\n            //     subtext: ''\n            //   };\n            // case 'device.location_permission.enabled':\n            //   return {\n            //     text: 'Location permission enabled',\n            //     subtext: ''\n            //   };\n            case \"device.secondary.ignored\":\n                return {\n                    text: \"Secondary device ignored\",\n                    subtext: \"\"\n                };\n        }\n    };\n    HtPlaceline.prototype.getGapSegment = function (segment, lastSeg) {\n        var gaps = [];\n        if (!lastSeg)\n            return [];\n        if (segment.started_at && lastSeg.ended_at) {\n            var endMin = GetMinute(segment.started_at);\n            var startMin = GetMinute(lastSeg.ended_at);\n            var duration = (new Date(segment.started_at).getTime() -\n                new Date(lastSeg.ended_at).getTime()) /\n                1000;\n            if (endMin != startMin && startMin < endMin) {\n                var gap = __assign$2({}, this.getActivityStyle(\"no-info\"), { time: lastSeg.ended_at, activityText: \"No information\", events: [], duration: duration, id: \"asd\" });\n                gaps.push(gap);\n            }\n        }\n        return gaps;\n    };\n    return HtPlaceline;\n}());\nvar htPlaceline = function (userData) { return new HtPlaceline(userData); };\nvar __assign$4 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nfunction UpdateSubAccountOfAccount(account, updatedSubAccount, tokenType) {\n    var subAccounts = _.map(account.sub_accounts, function (subAccount) {\n        if (subAccount.type == tokenType) {\n            return __assign$4({}, subAccount, updatedSubAccount);\n        }\n        else {\n            return subAccount;\n        }\n    });\n    return __assign$4({}, account, { sub_accounts: subAccounts });\n}\n// export function UpdateAccountOfAccountUser(accountUser: IAccountUser, account: IAccount, config): IAccountUser {\n//   let memberships = _.map(accountUser.memberships, (member: IMembership) => {\n//     let isMember = IsCurrentMember(member, config.currentToken, config.tokenType);\n//     return isMember ? {...member, account: account} : member;\n//   });\n//   let defaultAccount = account.id == accountUser.default_account.id ? account : accountUser.default_account;\n//   return {...accountUser, memberships: memberships, default_account: defaultAccount};\n// }\n// export function GetAccountFromAccountUser (accountUser: IAccountUser, currentToken: string, tokenType: 'test' | 'production') {\n//   if(!accountUser) return null;\n//   if(isCurrentAccount(accountUser.default_account, currentToken, tokenType)) {\n//     return accountUser.default_account;\n//   }\n//   let membership = _.find(accountUser.memberships, (member: IMembership) => {\n//     return isCurrentAccount(member.account, currentToken, tokenType);\n//   });\n//   return membership ? membership.account : null\n// }\nfunction isCurrentAccount(account, token, tokenType) {\n    return GetSecretToken(account, tokenType) == token;\n}\nfunction IsCurrentMember(member, token, tokenType) {\n    return GetSecretToken(member.account, tokenType) == token;\n}\nfunction GetSecretToken(account, tokenType) {\n    return getToken(getSubAccountToken(account, tokenType), \"secret\");\n}\nvar getToken = function (subAccounts, type) {\n    var tokenObject = _.find(subAccounts, function (token) {\n        return token.scope == type;\n    });\n    return tokenObject ? tokenObject.key : null;\n};\nfunction getAccountFromAccountUserId(accountUser, accountId) {\n    if (!accountUser)\n        return null;\n    if (accountUser.default_account.id == accountId) {\n        return accountUser.default_account;\n    }\n    else {\n        var membership = _.find(accountUser.memberships, function (member) {\n            return (member.account.id = accountId);\n        });\n        return membership ? membership.account : null;\n    }\n}\nfunction getSubAccountToken(account, type) {\n    return _.find(account.sub_accounts, function (subAccount) {\n        return subAccount.type == type;\n    }).tokens;\n}\nvar getAuthHeaders = function (token) {\n    return { Authorization: \"token \" + token };\n};\nvar itemAsPage$ = function () {\n    return function (item$) {\n        return item$.pipe(map(function (item) {\n            return item\n                ? {\n                    count: 1,\n                    next: null,\n                    previous: null,\n                    results: [item]\n                }\n                : null;\n        }));\n    };\n};\nvar __assign$5 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar dataWithSelectedId$ = function (data$, id$, keys, prop) {\n    return combineLatest$1(data$, id$, function (data, id) {\n        if (!data && keys.length)\n            return data;\n        var allItems = keys.reduce(function (items, key) {\n            return items.concat(data[key]);\n        }, []);\n        var selected = allItems.find(function (item) {\n            return item.id === id;\n        });\n        return __assign$5({}, data, (_a = {}, _a[prop] = selected, _a));\n        var _a;\n    });\n};\nvar listwithSelectedId$ = function (list$, id$) {\n    return combineLatest$1(list$, id$.pipe(distinctUntilChanged()), function (list, id) {\n        if (!list)\n            return list;\n        return !id\n            ? list\n            : {\n                count: 1,\n                next: null,\n                page: null,\n                results: list.results.filter(function (item) {\n                    return item.id === id;\n                })\n            };\n    });\n};\nvar listWithItem$ = function (list$, item$) {\n    return combineLatest$1(list$, item$.pipe(itemAsPage$()), function (list, itemPage) {\n        return itemPage ? itemPage : list;\n    });\n};\nvar andCombine = function () {\n    var source$ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        source$[_i] = arguments[_i];\n    }\n    return combineLatest$1.apply(void 0, source$.filter(function (data) { return !!data; }).concat([function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return args.reduce(function (acc, arg) {\n                return acc && !!arg;\n            }, true);\n        }])).pipe(distinctUntilChanged());\n};\nvar orCombine = function () {\n    var source$ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        source$[_i] = arguments[_i];\n    }\n    return combineLatest$1.apply(void 0, source$.concat([function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return args.reduce(function (acc, arg) {\n                return acc || !!arg;\n            }, false);\n        }]));\n};\nvar __assign$6 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar MergeQuery = function (defaultQuery) {\n    return function (query$) {\n        return query$.pipe(map(function (query) {\n            console.log(query);\n            return query ? __assign$6({}, defaultQuery, query) : query;\n        }));\n    };\n};\nvar __assign$7 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar CombineQueries = function (addQueries$) {\n    return function (query$) {\n        if (addQueries$ && addQueries$.length) {\n            return combineLatest$1.apply(void 0, [query$].concat(addQueries$.filter(function (data) { return !!data; }), [function (query) {\n                    var addQueries = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        addQueries[_i - 1] = arguments[_i];\n                    }\n                    if (!query)\n                        return query;\n                    return addQueries.reduce(function (acc, currentQ) {\n                        return __assign$7({}, currentQ, acc);\n                    }, query);\n                }]));\n        }\n        else {\n            return query$;\n        }\n    };\n};\nvar DateRangeToQuery$ = function (dateRangeParam) {\n    return function (dateRangeQuery$) {\n        return dateRangeQuery$.pipe(map(function (dateRange) {\n            if (!dateRange || (typeof dateRange == 'object' && Object.keys(dateRange).length == 0))\n                return {};\n            var start = dateRange[\"start\"];\n            var end = dateRange[\"end\"];\n            var param = dateRangeParam;\n            return _a = {}, _a[\"min_\" + param] = start, _a[\"max_\" + param] = end, _a;\n            var _a;\n        }));\n    };\n};\nvar PageResults$ = function (pageData$, defaultValue) {\n    return pageData$.pipe(map(function (pageDate) {\n        return pageDate ? pageDate.results : defaultValue || pageDate;\n    }));\n};\nvar __assign$8 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar AllowedQueryKeys$ = function (allowedQueryKeys) {\n    return function (queryStore$) {\n        if (allowedQueryKeys && allowedQueryKeys.length) {\n            var keys$ = allowedQueryKeys.map(function (key) {\n                return queryStore$.pipe(map(function (store) { return (store ? store[key] : null); }), distinctUntilChanged(), map(function (value) {\n                    return value ? (_a = {}, _a[key] = value, _a) : null;\n                    var _a;\n                }));\n            });\n            return combineLatest$1.apply(void 0, keys$).pipe(map(function (obsArray) {\n                console.log(obsArray, \"arr\");\n                return obsArray.reduce(function (acc, query) {\n                    return query ? __assign$8({}, acc, query) : acc;\n                }, {});\n            }));\n        }\n        else if (allowedQueryKeys) {\n            return of$1({});\n        }\n        else {\n            return queryStore$;\n        }\n    };\n};\nvar AllowedQueryMap = function (allowedQueryMaps) {\n    return function (queryStore$) {\n        if (allowedQueryMaps && allowedQueryMaps.length) {\n            var keys$ = allowedQueryMaps.map(function (queryMap) {\n                return queryStore$.pipe(map(function (store) { return (store ? store[queryMap.key] : null); }), scan(function (acc, value) {\n                    return { value: value, oldValue: acc.value };\n                }, { value: \"_no_val\", oldValue: \"_\" }), filter(function (obj) {\n                    if (obj.oldValue == \"_no_val\") {\n                        return true;\n                    }\n                    else if (!obj.oldValue || !obj.value) {\n                        return false;\n                    }\n                    else if (obj.oldValue == obj.value) {\n                        return false; //distinct unntil changed\n                    }\n                    else if (queryMap.filter) {\n                        return queryMap.filter(obj.value, obj.oldValue);\n                    }\n                    else {\n                        return true;\n                    }\n                }), map(function (obj) {\n                    return obj.value ? (_a = {}, _a[queryMap.key] = obj.value, _a) : null;\n                    var _a;\n                }));\n            });\n            return combineLatest$1.apply(void 0, keys$).pipe(map(function (obsArray) {\n                // console.log(obsArray, \"arr\");\n                return obsArray.reduce(function (acc, query) {\n                    return query ? __assign$8({}, acc, query) : acc;\n                }, {});\n            }));\n            // return queryStore$\n        }\n        else if (allowedQueryMaps) {\n            return of$1({});\n        }\n        else {\n            return queryStore$;\n        }\n    };\n};\nvar CombineLoadings$ = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var loadings$ = args.map(function (loading$) {\n        return loading$\n            .pipe(map(function (data) { return !!data; }), distinctUntilChanged());\n    });\n    return combineLatest$1.apply(void 0, loadings$.concat([function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return args.reduce(function (acc, arg) {\n                return acc || arg;\n            }, false);\n        }])).pipe(distinctUntilChanged(), share());\n};\nvar __assign$9 = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nfunction allPages(api$, req$, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return api$.pipe(expand(function (data) {\n        return data[\"next\"]\n            ? req$(data[\"next\"], options).pipe(map(function (newData) {\n                return __assign$9({}, newData, { results: data.results.concat(newData.results) });\n            }))\n            : empty$1();\n    }));\n}\nvar DateMapService = (function () {\n    var instance;\n    return {\n        getInstance: function () {\n            if (!instance) {\n                instance = {\n                    today_end: endOfToday().toISOString(),\n                    today_start: startOfToday().toISOString(),\n                    yesterday_start: startOfYesterday().toISOString(),\n                    yesterday_end: endOfYesterday().toISOString(),\n                    day_7_start: startOfDay(addDays(new Date(), -6)).toISOString(),\n                    month_start: startOfMonth(new Date()).toISOString(),\n                    day_30_start: startOfDay(addDays(new Date(), -29)).toISOString(),\n                };\n            }\n            return instance;\n        }\n    };\n})();\nvar DateRangeMap = {\n    \"today\": {\n        start: DateMapService.getInstance().today_start,\n        end: DateMapService.getInstance().today_end\n    },\n    \"yesterday\": {\n        start: DateMapService.getInstance().yesterday_start,\n        end: DateMapService.getInstance().yesterday_end,\n    },\n    \"last_7_days\": {\n        start: DateMapService.getInstance().day_7_start,\n        end: DateMapService.getInstance().today_end\n    },\n    \"this_month\": {\n        start: DateMapService.getInstance().month_start,\n        end: DateMapService.getInstance().today_end\n    },\n    \"last_30_days\": {\n        start: DateMapService.getInstance().day_30_start,\n        end: DateMapService.getInstance().today_end\n    }\n};\nvar DateRangeLabelMap = [\n    {\n        label: \"Today\",\n        range: DateRangeMap.today,\n        isSingleDay: true,\n        hasToday: true\n    },\n    {\n        label: \"Yesterday\",\n        range: DateRangeMap.yesterday,\n        isSingleDay: true,\n        hasToday: false\n    },\n    {\n        label: \"Last 7 days\",\n        range: DateRangeMap.last_7_days,\n        isSingleDay: false,\n        hasToday: true\n    },\n    {\n        label: \"This month\",\n        range: DateRangeMap.this_month,\n        isSingleDay: false,\n        hasToday: true\n    },\n    {\n        label: \"Last 30 days\",\n        range: DateRangeMap.last_30_days,\n        isSingleDay: false,\n        hasToday: true\n    }\n];\nvar dateRangeDisplay = function (range) {\n    var rangeItem = DateRangeLabelMap.find(function (item) {\n        return isSameDateRange(item.range, range);\n    });\n    if (rangeItem)\n        return rangeItem.label;\n    // const matchKey = Object.keys(DateRangeMap).find((key) => {\n    //   return isSameDateRange(DateRangeMap[key], range)\n    // });\n    // return \"\";\n    var customDate = DateRangeLabelMap.find(function (data) {\n        var customRange = data.range;\n        return isSameRange(range, customRange);\n    });\n    if (customDate)\n        return customDate.label;\n    var isSingleDay = IsRangeADay(range);\n    if (isSingleDay) {\n        var isToday$$1 = IsRangeToday(range);\n        var suffix = isToday$$1 ? \"Today \" : \"\";\n        var string = suffix + DateString(range.start);\n        return string;\n    }\n    else {\n        // console.log(DateString(range.start), range.start);\n        return DateString(range.start) + \" - \" + DateString(range.end);\n    }\n};\nvar isSameDateRange = function (range1, range2) {\n    function nearTime(t1, t2) {\n        return isSameDay(t1, t2);\n    }\n    return (nearTime(range1.start, range2.start) && nearTime(range1.end, range2.end));\n};\nvar tableFormat = function (data, config) {\n    var format = config.format;\n    return Object.keys(data).reduce(function (acc, key) {\n        var value = data[key];\n        if (typeof value === 'number' || typeof value === 'string' && !!!config.excludes.includes(key)) {\n            var formatKey = format[key];\n            if (formatKey) {\n                var label = formatKey.label || key;\n                var formattedValue = formatKey.selector(data) || value;\n                acc.push([label, formattedValue]);\n            }\n            else {\n                var label = key;\n                var formattedValue = value;\n                acc.push([label, formattedValue]);\n            }\n            return acc;\n        }\n        else {\n            return acc;\n        }\n    }, []);\n};\nvar actionTableFormat = {\n    \"assigned_at\": {\n        label: \"Assigned at\",\n        selector: function (action) {\n            return dateTimeString(action.assigned_at);\n        }\n    },\n    \"expected_at\": {\n        label: \"Expected at\",\n        selector: function (action) {\n            return action.expected_at ? dateTimeString(action.expected_at) : \"--\";\n        }\n    },\n    \"completed_at\": {\n        label: \"Completed at\",\n        selector: function (action) {\n            return dateTimeString(action.completed_at);\n        }\n    },\n    \"distance\": {\n        label: \"Distance\",\n        selector: function (action) {\n            return action.distance || action.distance == 0 ? DistanceLocale(action.distance) : \"--\";\n        }\n    },\n    \"duration\": {\n        label: \"Duration\",\n        selector: function (action) {\n            return action.duration || action.duration == 0 ? HMString(action.duration, 60) : \"--\";\n        }\n    },\n    \"scheduled_at\": {\n        label: \"Scheduled at\",\n        selector: function (action) {\n            return dateTimeString(action['scheduled_at']);\n        }\n    },\n    \"distance&duration\": {\n        label: \"Distance/Duration\",\n        selector: function (action) {\n            return actionTableFormat.distance.selector(action) + \"/\" + actionTableFormat.duration.selector(action);\n        }\n    },\n    \"type\": {\n        label: \"Type\",\n        selector: function (action) {\n            return NameCase(DotString(action.type));\n        }\n    }\n};\nvar userTableFormat = {\n    \"stop_duration\": {\n        label: \"Stop Duration\",\n        selector: function (user) {\n            return HMString(user.stop_duration, 60);\n        }\n    },\n    \"last_heartbeat_at\": {\n        label: \"Last updated at\",\n        selector: function (user) {\n            return dateTimeString(user.last_heartbeat_at);\n        }\n    },\n    \"last_battery\": {\n        label: \"Last battery\",\n        selector: function (user) {\n            return user.display.battery + \" %\";\n        }\n    },\n    \"total_duration\": {\n        label: \"Duration tracked\",\n        selector: function (user) {\n            return HMString(user.total_duration, 60);\n        }\n    },\n    \"num_places\": {\n        label: \"Number of stops\",\n        selector: function (user) {\n            return user.num_places;\n        }\n    },\n    \"location_disabled_duration\": {\n        label: \"Location disabled duration\",\n        selector: function (user) {\n            return HMString(user.location_disabled_duration, 60);\n        }\n    },\n    \"total_distance\": {\n        label: \"Total distance\",\n        selector: function (user) {\n            return DistanceLocale(user.total_distance);\n        }\n    },\n    \"num_trips\": {\n        label: \"Number of trips\",\n        selector: function (user) {\n            return user.num_trips;\n        }\n    },\n    \"network_offline_duration\": {\n        label: \"Network offline duration\",\n        selector: function (user) {\n            return HMString(user.network_offline_duration, 60);\n        }\n    },\n    \"num_actions\": {\n        label: \"Number of actions\",\n        selector: function (user) {\n            return user.num_actions;\n        }\n    }\n};\nfunction dateTimeString(time) {\n    return time ? TimeString(time) + \", \" + DateString(time, 'short') : \"--\";\n}\nexport { HtAction, htAction, HtUser, htUser, HtEvent, htEvent, HtPlaceline, htPlaceline, UpdateSubAccountOfAccount, isCurrentAccount, IsCurrentMember, GetSecretToken, getToken, getAccountFromAccountUserId, getAuthHeaders, dataWithSelectedId$, listwithSelectedId$, listWithItem$, andCombine, orCombine, MergeQuery, CombineQueries, itemAsPage$, DateRangeToQuery$, PageResults$, AllowedQueryKeys$, AllowedQueryMap, CombineLoadings$, allPages, DateMapService, DateRangeMap, DateRangeLabelMap, dateRangeDisplay, isSameDateRange, tableFormat, actionTableFormat, userTableFormat };\n",null]}