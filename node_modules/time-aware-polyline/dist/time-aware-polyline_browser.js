(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.timeAwarePolyline = {})));
}(this, (function (exports) { 'use strict';

var TimeAwareEncoder = /** @class */ (function () {
    function TimeAwareEncoder() {
    }
    TimeAwareEncoder.prototype.encodeTimeAwarePolyline = function (points) {
        return this.extendTimeAwarePolyline("", points, null);
    };
    TimeAwareEncoder.prototype.decodeTimeAwarePolyline = function (polyline) {
        // Method to decode a time aware encoder and return gpx logs
        var gpxLogs = [];
        var index = 0;
        var lat = 0;
        var lng = 0;
        var timeStamp = 0;
        var polylineLine = polyline.length;
        while (index < polylineLine) {
            // Decoding dimensions one by one
            var latResult = this.getDecodedDimensionFromPolyline(polyline, index);
            index = latResult[0];
            var lngResult = this.getDecodedDimensionFromPolyline(polyline, index);
            index = lngResult[0];
            var timeResult = this.getDecodedDimensionFromPolyline(polyline, index);
            index = timeResult[0];
            // Resultant variables
            lat += latResult[1];
            lng += lngResult[1];
            timeStamp += timeResult[1];
            gpxLogs.push(this.getGpxLog(lat, lng, timeStamp));
        }
        return gpxLogs;
    };
    TimeAwareEncoder.prototype.getLocationsAtTimestamps = function (decodedTimeAwarePolyline, timeStamps) {
        var index = 0, locations = [];
        for (index = 0; index < timeStamps.length; index++) {
            var locationsAndBearing = this.getLocationsTillTimeStamp(decodedTimeAwarePolyline, timeStamps[index]);
            var locationsFound = locationsAndBearing.locations;
            if (locationsFound.length > 0) {
                locations.push(locationsFound[locationsFound.length - 1]);
            }
            else {
                locations.push([]);
            }
        }
        return locations;
    };
    TimeAwareEncoder.prototype.getLocationsElapsedByTimestamp = function (decodedTimeAwarePolyline, timeStamp) {
        var locationsAndBearing = this.getLocationsTillTimeStamp(decodedTimeAwarePolyline, timeStamp);
        return { 'path': locationsAndBearing.locations, 'bearing': locationsAndBearing.bearing };
    };
    TimeAwareEncoder.prototype.getPolylineSegmentsPublic = function (decodedTimeAwarePolyline) {
        var lastTimeStamp = decodedTimeAwarePolyline[decodedTimeAwarePolyline.length - 1][2];
        var polylineSegments = this.getPolylineSegments(decodedTimeAwarePolyline, lastTimeStamp);
        var result = [];
        for (var i = 0; i < polylineSegments.length; i++) {
            result.push({ 'path': this.removeTimeStamps(polylineSegments[i].segment), 'style': polylineSegments[i].style });
        }
        return result;
    };
    TimeAwareEncoder.prototype.getPolylineSegmentsForLocationsElapsed = function (decodedTimeAwarePolyline, timeStamp) {
        var polylineSegments = this.getPolylineSegments(decodedTimeAwarePolyline, timeStamp);
        var result = [];
        for (var i = 0; i < polylineSegments.length; i++) {
            var elapsed = this.getLocationsElapsedByTimestamp(polylineSegments[i].segment, timeStamp);
            if (elapsed.path.length > 0) {
                result.push({
                    'path': elapsed.path, 'bearing': elapsed.bearing, 'style': polylineSegments[i].style
                });
            }
        }
        return result;
    };
    /*
    Other
     */
    TimeAwareEncoder.prototype.getLocationsTillTimeStamp = function (decodedPolyline, timeStamp) {
        var decoded = decodedPolyline;
        // decoded and timeStamps are both in order of times
        var index = 0;
        var currentPair = [];
        var locationsElapsed = [];
        var bearing = 0;
        if (decoded.length == 0) {
            return { 'locations': [], 'bearing': bearing };
        }
        // remove times before first time
        var timeStampToFind = timeStamp, startTime = decoded[0][2];
        while (timeStampToFind <= startTime) {
            return { 'locations': [[decoded[0][0], decoded[0][1]]], 'bearing': bearing };
        }
        for (index = 0; index < decoded.length; index++) {
            currentPair.push(decoded[index]);
            if (currentPair.length == 2) {
                var timeStampToFind = timeStamp;
                bearing = this.updateBearing(bearing, currentPair);
                var currentstartTime = currentPair[0][2], endTime = currentPair[1][2];
                if (timeStampToFind > currentstartTime && timeStampToFind <= endTime) {
                    // location is in the current pair
                    var midLocation = this.getLocationInPair(currentPair, timeStampToFind);
                    locationsElapsed.push(midLocation);
                    return { 'locations': locationsElapsed, 'bearing': bearing };
                    // it is possible that the next timestamp is also in the
                    // same pair, hence redo-ing same iteration
                    // currentPair.pop();
                    // index --;
                }
                else {
                    currentPair.shift();
                }
            }
            locationsElapsed.push([currentPair[0][0], currentPair[0][1]]);
        }
        return { 'locations': locationsElapsed, 'bearing': bearing };
    };
    TimeAwareEncoder.prototype.isDifferentSegment = function (end, start) {
        // function to determine whether a encoder
        // segment split should happen
        var distance = this.getDistance(start, end);
        return distance > 500;
    };
    TimeAwareEncoder.prototype.getPolylineSegments = function (decoded, timeLimit) {
        // this method breaks encoder till timeStamp when
        // consecutive time difference is greater than 10 minutes
        var segments = [], currentSegment = [];
        var index = 0;
        if (decoded.length == 0) {
            return [];
        }
        var start = decoded[0];
        for (index = 0; index < decoded.length; index++) {
            if (decoded[index][2] <= timeLimit) {
                if (this.isDifferentSegment(decoded[index], start) && currentSegment.length > 0) {
                    // time difference is more than 10 mins, so flush
                    segments.push({
                        'segment': currentSegment, 'style': 'solid'
                    });
                    var lastElement = currentSegment[currentSegment.length - 1];
                    currentSegment = [lastElement, decoded[index]];
                    segments.push({
                        'segment': currentSegment, 'style': 'dotted'
                    });
                    currentSegment = [decoded[index]];
                }
                else {
                    currentSegment.push(decoded[index]);
                }
                start = decoded[index];
            }
            else {
                // add one more location so that the locations elapsed
                // method can find an interpolated midpoint
                if (!this.isDifferentSegment(decoded[index], start)) {
                    currentSegment.push(decoded[index]);
                }
                break;
            }
        }
        segments.push({
            'segment': currentSegment, 'style': 'solid'
        });
        return segments;
    };
    TimeAwareEncoder.prototype.updateBearing = function (oldBearing, gpxPair) {
        var start = [gpxPair[0][0], gpxPair[0][1]];
        var end = [gpxPair[1][0], gpxPair[1][1]];
        var newBearing = this.computeHeading(start, end);
        if (newBearing != 0) {
            return Math.round(newBearing * 100) / 100.0;
        }
        else {
            return oldBearing;
        }
    };
    TimeAwareEncoder.prototype.getLocationInPair = function (gpxPair, timeStamp) {
        // timeStamp lies between the timeStamps in the gpx logs
        var startLat = gpxPair[0][0], startLng = gpxPair[0][1], endLat = gpxPair[1][0], endLng = gpxPair[1][1], startTime = new Date(gpxPair[0][2]), endTime = new Date(gpxPair[1][2]), currentTime = new Date(timeStamp);
        var ratio = (+startTime - +currentTime) / (+startTime - +endTime);
        return [startLat * (1 - ratio) + endLat * ratio, startLng * (1 - ratio) + endLng * ratio];
    };
    TimeAwareEncoder.prototype.getNextLatLng = function (decoded, timeStamp) {
        var polylineLength = decoded.length;
        if (polylineLength > 0) {
            for (var index = 0; index < polylineLength - 1; index++) {
                var currentTimeStamp = decoded[index][2];
                if (timeStamp < currentTimeStamp) {
                    return [decoded[index][0], decoded[index][1]];
                }
            }
            return [decoded[polylineLength - 1][0], decoded[polylineLength - 1][1]];
        }
    };
    TimeAwareEncoder.prototype.getDistance = function (origin, destination) {
        // return distance in meters
        var lon1 = this.toRadian(origin[1]), lat1 = this.toRadian(origin[0]), lon2 = this.toRadian(destination[1]), lat2 = this.toRadian(destination[0]);
        var deltaLat = lat2 - lat1;
        var deltaLon = lon2 - lon1;
        var a = Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon / 2), 2);
        var c = 2 * Math.asin(Math.sqrt(a));
        return c * EARTH_RADIUS * 1000;
    };
    TimeAwareEncoder.prototype.toRadian = function (degree) {
        return degree * Math.PI / 180;
    };
    TimeAwareEncoder.prototype.computeHeading = function (start, end) {
        var lat1 = this.toRadian(start[0]);
        var lat2 = this.toRadian(end[0]);
        var lng1 = this.toRadian(start[1]);
        var lng2 = this.toRadian(end[1]);
        return Math.atan2(Math.sin(lng2 - lng1) * Math.cos(lat2), Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1)) * 180 / Math.PI;
    };
    TimeAwareEncoder.prototype.areEqualLatlngs = function (latlngA, latlngB) {
        return (latlngA[0] == latlngB[0]) && (latlngA[1] == latlngB[1]);
    };
    TimeAwareEncoder.prototype.removeTimeStamps = function (segment) {
        var result = [];
        for (var i = 0; i < segment.length; i++) {
            result.push([segment[i][0], segment[i][1]]);
        }
        return result;
    };
    /*
    Helpers
     */
    TimeAwareEncoder.prototype.getDecodedDimensionFromPolyline = function (polyline, index) {
        // Method to decode one dimension of the encoder
        var result = 1;
        var shift = 0;
        while (true) {
            var polylineChar = polyline[index];
            var b = polylineChar.charCodeAt(0) - 63 - 1;
            index++;
            result += this.lshiftOperator(b, shift);
            shift += 5;
            if (b < 0x1f) {
                break;
            }
        }
        if ((result % 2) !== 0) {
            return [index, this.rshiftOperator(this.notOperator(result), 1)];
        }
        else {
            return [index, this.rshiftOperator(result, 1)];
        }
    };
    TimeAwareEncoder.prototype.extendTimeAwarePolyline = function (polyline, points, lastPoint) {
        var lastLat = 0, lastLng = 0, lastTimeStamp = 0;
        if (polyline == null) {
            polyline = '';
        }
        if (lastPoint != null) {
            lastLat = this.getLat(lastPoint);
            lastLng = this.getLng(lastPoint);
            lastTimeStamp = this.getTimeStamp(lastPoint);
        }
        if (points.length < 1) {
            return polyline;
        }
        for (var i = 0; i < points.length; i++) {
            var currentGpxLog = points[i];
            var lat = this.getLat(currentGpxLog);
            var lng = this.getLng(currentGpxLog);
            var timeStamp = this.getTimeStamp(currentGpxLog);
            var diffArray = [lat - lastLat, lng - lastLng, timeStamp - lastTimeStamp];
            for (var j = 0; j < diffArray.length; j++) {
                var currentDiff = diffArray[j];
                currentDiff = (currentDiff < 0) ? this.notOperator(this.lshiftOperator(currentDiff, 1)) : this.lshiftOperator(currentDiff, 1);
                while (currentDiff >= 0x20) {
                    polyline += String.fromCharCode((0x20 | (currentDiff & 0x1f)) + 63);
                    currentDiff = this.rshiftOperator(currentDiff, 5);
                }
                polyline += String.fromCharCode(currentDiff + 63);
            }
            lastLat = lat, lastLng = lng, lastTimeStamp = timeStamp;
        }
        return polyline;
    };
    TimeAwareEncoder.prototype.getCoordinate = function (intRepresentation) {
        var coordinate = intRepresentation * 0.00001;
        return +coordinate.toFixed(5);
    };
    TimeAwareEncoder.prototype.getIsoTime = function (timeStamp) {
        // timeStamp is in seconds
        return new Date(timeStamp * 1000).toISOString();
    };
    TimeAwareEncoder.prototype.getGpxLog = function (lat, lng, timeStamp) {
        return [
            this.getCoordinate(lat), this.getCoordinate(lng), this.getIsoTime(timeStamp)
        ];
    };
    TimeAwareEncoder.prototype.getLat = function (gpxLog) {
        return Math.round(gpxLog[0] * 100000);
    };
    TimeAwareEncoder.prototype.getLng = function (gpxLog) {
        return Math.round(gpxLog[1] * 100000);
    };
    TimeAwareEncoder.prototype.getTimeStamp = function (gpxLog) {
        return +new Date(gpxLog[2]) / 1000;
    };
    TimeAwareEncoder.prototype.lshiftOperator = function (num, bits) {
        // Custom left shift for 64 bit integers
        return num * Math.pow(2, bits);
    };
    TimeAwareEncoder.prototype.rshiftOperator = function (num, bits) {
        // Custom right shift for 64 bit integers
        return Math.floor(num / Math.pow(2, bits));
    };
    TimeAwareEncoder.prototype.notOperator = function (num) {
        // Custom not operator for 64 bit integers
        return ~num;
    };
    return TimeAwareEncoder;
}());

var EARTH_RADIUS = 6371;

var PolylineUtils = /** @class */ (function () {
    function PolylineUtils() {
        this.encoder = new TimeAwareEncoder();
    }
    PolylineUtils.prototype.updateTimeAwarePolyline = function (encodedPolyline) {
        if (this.isNewPolyline(encodedPolyline)) {
            this.encodedPolyline = encodedPolyline;
            this.timeAwarePolyline = this.encoder.decodeTimeAwarePolyline(this.encodedPolyline);
        }
    };
    PolylineUtils.prototype.getPolylineToTime = function (timestamp) {
        return this.encoder.getLocationsElapsedByTimestamp(this.timeAwarePolyline, timestamp);
    };
    PolylineUtils.prototype.getLatestTime = function () {
        if (this.timeAwarePolyline) {
            var lastI = this.timeAwarePolyline.length - 1;
            return lastI > -1 ? this.timeAwarePolyline[lastI][2] : null;
        }
        else {
            return null;
        }
    };
    PolylineUtils.prototype.isNewPolyline = function (encodedPolyline) {
        return encodedPolyline != this.encodedPolyline;
    };
    return PolylineUtils;
}());

var TimeAwareAnimation = /** @class */ (function () {
    function TimeAwareAnimation() {
        this.polylineUtils = new PolylineUtils();
        this.animationSpeed = 20;
        this.animationProps = { speedScale: 1, interval: 20 };
        this.updateEvent = new CustomEvent();
    }
    /*
    Update animation from encoded polyline string
    */
    TimeAwareAnimation.prototype.updatePolylineString = function (timeAwarePolylineString) {
        var timeAwarePolyline = this.polylineUtils.encoder.decodeTimeAwarePolyline(timeAwarePolylineString);
        this.update(timeAwarePolyline);
    };
    /*
    Update animation from encoded time aware array [lat, lng, time]
     */
    TimeAwareAnimation.prototype.update = function (timeAwarePolyline) {
        if (!timeAwarePolyline) {
            this.clear();
            return true;
        }
        
        this.polylineUtils.timeAwarePolyline = timeAwarePolyline;
        if (!this.animationPoll)
            this.handleAnimation(timeAwarePolyline);
    };
    TimeAwareAnimation.prototype.handleAnimation = function (timeAwarePolyline) {
        var _this = this;
        if (!timeAwarePolyline)
            return;
        if (this.animationPoll)
            this.clearAnimationPoll();
        this.updateCurrentTime();
        this.setPathBearing();
        this.animationPoll = setInterval(function () {
            _this.updateCurrentTime();
            _this.setPathBearing();
        }, this.animationSpeed);
    };
    TimeAwareAnimation.prototype.updateCurrentTime = function () {
        var _this = this;
        if (this.currentTime) {
            var timeToAdd = this.getTimeToAdd();
            this.currentTime = this.addISOTime(this.currentTime, timeToAdd);
        }
        else {
            var last = this.polylineUtils.getLatestTime();
            var delay = new Date().getTime() - new Date(last).getTime();
            var timeToAdd = delay > 15 * 60 * 1000 ? 0 : -20000;
            this.currentTime = this.addISOTime(last, timeToAdd);
        }
        this.capTime(function () {
            _this.clearAnimationPoll();
        });
    };
    TimeAwareAnimation.prototype.setPathBearing = function () {
        var _a = this.currentTimePolylineData(), path = _a.path, bearing = _a.bearing;
        this.updatePathBearing(path, bearing);
        this.updateEvent.publish('update', { path: path, bearing: bearing, time: this.currentTime });
    };
    
    TimeAwareAnimation.prototype.updatePathBearing = function (path, bearing) {
    };
    TimeAwareAnimation.prototype.capTime = function (callback) {
        if (new Date(this.currentTime) > new Date(this.polylineUtils.getLatestTime())) {
            this.currentTime = this.polylineUtils.getLatestTime();
            if (callback && typeof callback == 'function')
                callback();
            return true;
        }
        else {
            return false;
        }
    };
    TimeAwareAnimation.prototype.clearAnimationPoll = function () {
        clearInterval(this.animationPoll);
        this.animationPoll = null;
    };
    TimeAwareAnimation.prototype.getTimeToAdd = function () {
        var lastTime = new Date(this.polylineUtils.getLatestTime()).getTime();
        var currentTime = new Date(this.currentTime).getTime();
        var totalDuration = (lastTime - currentTime) / 1000;
        var factor = 1;
        if (typeof totalDuration == 'number') {
            var mid = 5;
            var power = 2;
            if (totalDuration > mid) {
                factor = Math.pow(totalDuration, power) / Math.pow(mid, power);
            }
        }
        return factor * this.animationProps.interval;
    };
    TimeAwareAnimation.prototype.currentTimePolylineData = function () {
        var polylineData = this.polylineUtils.getPolylineToTime(this.currentTime);
        var path = polylineData.path.map(function (array) {
            return { lat: array[0], lng: array[1] };
        });
        return { path: path, bearing: polylineData.bearing };
    };
    TimeAwareAnimation.prototype.clear = function () {
        this.clearAnimationPoll();
    };
    
    TimeAwareAnimation.prototype.addISOTime = function (time, timeToAdd) {
        return new Date(new Date(time).getTime() + timeToAdd).toISOString();
    };
    
    return TimeAwareAnimation;
}());
var CustomEvent = /** @class */ (function () {
    function CustomEvent() {
        this.topics = {};
        this.hOP = this.topics.hasOwnProperty;
    }
    CustomEvent.prototype.publish = function (topic, info) {
        // If the topic doesn't exist, or there's no listeners in queue, just leave
        if (!this.hOP.call(this.topics, topic))
            return;
        // Cycle through topics queue, fire!
        this.topics[topic].forEach(function (item) {
            item(info != undefined ? info : {});
        });
    };
    CustomEvent.prototype.subscribe = function (topic, listener) {
        // Create the topic's object if not yet created
        if (!this.hOP.call(this.topics, topic))
            this.topics[topic] = [];
        // Add the listener to queue
        var index = this.topics[topic].push(listener) - 1;
        // Provide handle back for removal of topic
        return {
            unsubscribe: function () {
                delete this.topics[topic][index];
            }
        };
    };
    return CustomEvent;
}());

// export interface IPathBearing {
//   path: HtPosition[],
//   bearing: number,
// }

exports.TimeAwareEncoder = TimeAwareEncoder;
exports.EARTH_RADIUS = EARTH_RADIUS;
exports.PolylineUtils = PolylineUtils;
exports.TimeAwareAnimation = TimeAwareAnimation;
exports.CustomEvent = CustomEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=time-aware-polyline_browser.js.map
