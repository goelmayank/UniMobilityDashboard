"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var polyline_1 = require("./polyline");
var TimeAwareAnimation = /** @class */ (function () {
    function TimeAwareAnimation() {
        this.polylineUtils = new polyline_1.PolylineUtils();
        this.animationSpeed = 20;
        this.animationProps = { speedScale: 1, interval: 20 };
        this.updateEvent = new CustomEvent();
    }
    /*
    Update animation from encoded polyline string
    */
    TimeAwareAnimation.prototype.updatePolylineString = function (timeAwarePolylineString) {
        var timeAwarePolyline = this.polylineUtils.encoder.decodeTimeAwarePolyline(timeAwarePolylineString);
        this.update(timeAwarePolyline);
    };
    /*
    Update animation from encoded time aware array [lat, lng, time]
     */
    TimeAwareAnimation.prototype.update = function (timeAwarePolyline) {
        if (!timeAwarePolyline) {
            this.clear();
            return true;
        }
        ;
        this.polylineUtils.timeAwarePolyline = timeAwarePolyline;
        if (!this.animationPoll)
            this.handleAnimation(timeAwarePolyline);
    };
    TimeAwareAnimation.prototype.handleAnimation = function (timeAwarePolyline) {
        var _this = this;
        if (!timeAwarePolyline)
            return;
        if (this.animationPoll)
            this.clearAnimationPoll();
        this.updateCurrentTime();
        this.setPathBearing();
        this.animationPoll = setInterval(function () {
            _this.updateCurrentTime();
            _this.setPathBearing();
        }, this.animationSpeed);
    };
    TimeAwareAnimation.prototype.updateCurrentTime = function () {
        var _this = this;
        if (this.currentTime) {
            var timeToAdd = this.getTimeToAdd();
            this.currentTime = this.addISOTime(this.currentTime, timeToAdd);
        }
        else {
            var last = this.polylineUtils.getLatestTime();
            var delay = new Date().getTime() - new Date(last).getTime();
            var timeToAdd = delay > 15 * 60 * 1000 ? 0 : -20000;
            this.currentTime = this.addISOTime(last, timeToAdd);
        }
        this.capTime(function () {
            _this.clearAnimationPoll();
        });
    };
    TimeAwareAnimation.prototype.setPathBearing = function () {
        var _a = this.currentTimePolylineData(), path = _a.path, bearing = _a.bearing;
        this.updatePathBearing(path, bearing);
        this.updateEvent.publish('update', { path: path, bearing: bearing, time: this.currentTime });
    };
    ;
    TimeAwareAnimation.prototype.updatePathBearing = function (path, bearing) {
    };
    TimeAwareAnimation.prototype.capTime = function (callback) {
        if (new Date(this.currentTime) > new Date(this.polylineUtils.getLatestTime())) {
            this.currentTime = this.polylineUtils.getLatestTime();
            if (callback && typeof callback == 'function')
                callback();
            return true;
        }
        else {
            return false;
        }
    };
    TimeAwareAnimation.prototype.clearAnimationPoll = function () {
        clearInterval(this.animationPoll);
        this.animationPoll = null;
    };
    TimeAwareAnimation.prototype.getTimeToAdd = function () {
        var lastTime = new Date(this.polylineUtils.getLatestTime()).getTime();
        var currentTime = new Date(this.currentTime).getTime();
        var totalDuration = (lastTime - currentTime) / 1000;
        var factor = 1;
        if (typeof totalDuration == 'number') {
            var mid = 5;
            var power = 2;
            if (totalDuration > mid) {
                factor = Math.pow(totalDuration, power) / Math.pow(mid, power);
            }
        }
        return factor * this.animationProps.interval;
    };
    TimeAwareAnimation.prototype.currentTimePolylineData = function () {
        var polylineData = this.polylineUtils.getPolylineToTime(this.currentTime);
        var path = polylineData.path.map(function (array) {
            return { lat: array[0], lng: array[1] };
        });
        return { path: path, bearing: polylineData.bearing };
    };
    TimeAwareAnimation.prototype.clear = function () {
        this.clearAnimationPoll();
    };
    ;
    TimeAwareAnimation.prototype.addISOTime = function (time, timeToAdd) {
        return new Date(new Date(time).getTime() + timeToAdd).toISOString();
    };
    ;
    return TimeAwareAnimation;
}());
exports.TimeAwareAnimation = TimeAwareAnimation;
var CustomEvent = /** @class */ (function () {
    function CustomEvent() {
        this.topics = {};
        this.hOP = this.topics.hasOwnProperty;
    }
    CustomEvent.prototype.publish = function (topic, info) {
        // If the topic doesn't exist, or there's no listeners in queue, just leave
        if (!this.hOP.call(this.topics, topic))
            return;
        // Cycle through topics queue, fire!
        this.topics[topic].forEach(function (item) {
            item(info != undefined ? info : {});
        });
    };
    CustomEvent.prototype.subscribe = function (topic, listener) {
        // Create the topic's object if not yet created
        if (!this.hOP.call(this.topics, topic))
            this.topics[topic] = [];
        // Add the listener to queue
        var index = this.topics[topic].push(listener) - 1;
        // Provide handle back for removal of topic
        return {
            unsubscribe: function () {
                delete this.topics[topic][index];
            }
        };
    };
    return CustomEvent;
}());
exports.CustomEvent = CustomEvent;
;
// export interface IPathBearing {
//   path: HtPosition[],
//   bearing: number,
// }
//# sourceMappingURL=animate.js.map