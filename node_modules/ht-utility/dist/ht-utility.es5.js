import { isToday, isTomorrow, isValid, isYesterday, format, startOfMinute, addMilliseconds, isSameMinute, addDays, endOfToday, endOfYesterday, isSameDay, startOfDay, startOfMonth, startOfToday, startOfYesterday } from 'date-fns';
import { determine } from 'jstz';

var AuthLessReqOptions = function () {
    var headers = {
        "Content-Type": "application/json",
        Authorization: null
    };
    var options = { headers: headers };
    return options;
};

function ArrayHumanize(array) {
    return array.reduce(function (acc, string, i) {
        var connector = ", ";
        if (i == 0)
            connector = "";
        if (i == array.length - 1)
            connector = " and ";
        return acc + connector + string;
    }, "");
}

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/**
 * Works similar to underscore indexBy, converts array to object
 * @param array : this is convereted to object
 * @param key(default = 'id') : indexBy prop name
 */
var indexBy = function (array, key) {
    if (key === void 0) { key = 'id'; }
    return array.reduce(function (acc, item) {
        return __assign({}, acc, (_a = {}, _a[item[key]] = item, _a));
        var _a;
    }, {});
};

var Color = {
    green: "#85C487",
    greenLight: "#94dc96",
    greenDark: "#6bb564",
    red: "#E6413E",
    redDark: "#ac3532",
    redLight: "#f06f49",
    grey2: "#C9D6DE",
    grey3: "#A9BAC4",
    grey4: "#798E9B",
    grey5: "#52616A",
    black: "#000000",
    blue: "#5496F8",
    blueLight: "#77b1f8",
    blueDark: "#497cd0",
    mapBg: "#d7d5d5",
    stop: "#FFBB44",
    stopDark: "#ef9040"
};

var COUNTRIES = [
    "Afghanistan",
    "Albania",
    "Algeria",
    "American Samoa",
    "Andorra",
    "Angola",
    "Anguilla",
    "Antartica",
    "Antigua and Barbuda",
    "Argentina",
    "Armenia",
    "Aruba",
    "Australia",
    "Austria",
    "Azerbaijan",
    "Bahamas",
    "Bahrain",
    "Bangladesh",
    "Barbados",
    "Belarus",
    "Belgium",
    "Belize",
    "Benin",
    "Bermuda",
    "Bhutan",
    "Bolivia",
    "Bosnia and Herzegowina",
    "Botswana",
    "Bouvet Island",
    "Brazil",
    "British Indian Ocean Territory",
    "Brunei Darussalam",
    "Bulgaria",
    "Burkina Faso",
    "Burundi",
    "Cambodia",
    "Cameroon",
    "Canada",
    "Cape Verde",
    "Cayman Islands",
    "Central African Republic",
    "Chad",
    "Chile",
    "China",
    "Christmas Island",
    "Cocos Islands",
    "Colombia",
    "Comoros",
    "Congo",
    "Congo",
    "Cook Islands",
    "Costa Rica",
    "Cota D'Ivoire",
    "Croatia",
    "Cuba",
    "Cyprus",
    "Czech Republic",
    "Denmark",
    "Djibouti",
    "Dominica",
    "Dominican Republic",
    "East Timor",
    "Ecuador",
    "Egypt",
    "El Salvador",
    "Equatorial Guinea",
    "Eritrea",
    "Estonia",
    "Ethiopia",
    "Falkland Islands",
    "Faroe Islands",
    "Fiji",
    "Finland",
    "France",
    "France Metropolitan",
    "French Guiana",
    "French Polynesia",
    "French Southern Territories",
    "Gabon",
    "Gambia",
    "Georgia",
    "Germany",
    "Ghana",
    "Gibraltar",
    "Greece",
    "Greenland",
    "Grenada",
    "Guadeloupe",
    "Guam",
    "Guatemala",
    "Guinea",
    "Guinea-Bissau",
    "Guyana",
    "Haiti",
    "Heard and McDonald Islands",
    "Holy See",
    "Honduras",
    "Hong Kong",
    "Hungary",
    "Iceland",
    "India",
    "Indonesia",
    "Iran",
    "Iraq",
    "Ireland",
    "Israel",
    "Italy",
    "Jamaica",
    "Japan",
    "Jordan",
    "Kazakhstan",
    "Kenya",
    "Kiribati",
    "Democratic People's Republic of Korea",
    "Korea",
    "Kuwait",
    "Kyrgyzstan",
    "Lao",
    "Latvia",
    "Lebanon",
    "Lesotho",
    "Liberia",
    "Libyan Arab Jamahiriya",
    "Liechtenstein",
    "Lithuania",
    "Luxembourg",
    "Macau",
    "Macedonia",
    "Madagascar",
    "Malawi",
    "Malaysia",
    "Maldives",
    "Mali",
    "Malta",
    "Marshall Islands",
    "Martinique",
    "Mauritania",
    "Mauritius",
    "Mayotte",
    "Mexico",
    "Micronesia",
    "Moldova",
    "Monaco",
    "Mongolia",
    "Montserrat",
    "Morocco",
    "Mozambique",
    "Myanmar",
    "Namibia",
    "Nauru",
    "Nepal",
    "Netherlands",
    "Netherlands Antilles",
    "New Caledonia",
    "New Zealand",
    "Nicaragua",
    "Niger",
    "Nigeria",
    "Niue",
    "Norfolk Island",
    "Northern Mariana Islands",
    "Norway",
    "Oman",
    "Pakistan",
    "Palau",
    "Panama",
    "Papua New Guinea",
    "Paraguay",
    "Peru",
    "Philippines",
    "Pitcairn",
    "Poland",
    "Portugal",
    "Puerto Rico",
    "Qatar",
    "Reunion",
    "Romania",
    "Russia",
    "Rwanda",
    "Saint Kitts and Nevis",
    "Saint LUCIA",
    "Saint Vincent",
    "Samoa",
    "San Marino",
    "Sao Tome and Principe",
    "Saudi Arabia",
    "Senegal",
    "Seychelles",
    "Sierra",
    "Singapore",
    "Slovakia",
    "Slovenia",
    "Solomon Islands",
    "Somalia",
    "South Africa",
    "South Georgia",
    "Span",
    "SriLanka",
    "St. Helena",
    "St. Pierre and Miguelon",
    "Sudan",
    "Suriname",
    "Svalbard",
    "Swaziland",
    "Sweden",
    "Switzerland",
    "Syria",
    "Taiwan",
    "Tajikistan",
    "Tanzania",
    "Thailand",
    "Togo",
    "Tokelau",
    "Tonga",
    "Trinidad and Tobago",
    "Tunisia",
    "Turkey",
    "Turkmenistan",
    "Turks and Caicos",
    "Tuvalu",
    "Uganda",
    "Ukraine",
    "United Arab Emirates",
    "United Kingdom",
    "United States",
    "United States Minor Outlying Islands",
    "Uruguay",
    "Uzbekistan",
    "Vanuatu",
    "Venezuela",
    "Vietnam",
    "Virgin Islands (British)",
    "Virgin Islands (U.S)",
    "Wallis and Futana Islands",
    "Western Sahara",
    "Yemen",
    "Yugoslavia",
    "Zambia",
    "Zimbabwe"
];

function DateHumanize(value, arg) {
    if (arg === void 0) { arg = false; }
    if (typeof value == "string" && value.length > 4 && isValid(new Date(value))) {
        var date = new Date(value);
        if (isToday(date)) {
            return "Today";
        }
        else if (isYesterday(date)) {
            return "Yesterday";
        }
        else if (isTomorrow(date)) {
            return "Tomorrow";
        }
        else {
            return format(date, "D MMM");
        }
    }
    else {
        return value;
    }
}

function DateString(item, args) {
    if (typeof item == "string" && item.length > 4 && isValid(new Date(item))) {
        var formatString = args == "short" ? "MMM D" : "MMM D, YYYY";
        return format(new Date(item), formatString);
    }
    else {
        return item;
    }
}

function getTimezone() {
    return determine().name();
}

function DistanceLocale(meters, timezone) {
    if (timezone === void 0) { timezone = "_"; }
    timezone = timezone || getTimezone();
    if (meters != undefined && typeof meters == "number" && meters >= 0) {
        var america = timezone.indexOf("America") > -1;
        // console.log(config.timezone.indexOf('America'), america, config.timezone);
        // let test = false;
        if (america) {
            var miles = Math.round(meters * 0.00621371) / 10;
            var milesLocaleString = miles.toLocaleString(undefined, {
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            });
            return milesLocaleString + " miles";
        }
        else {
            var km = Math.round(meters / 100) / 10;
            var kmLocaleString = km.toLocaleString(undefined, {
                minimumFractionDigits: 1,
                maximumFractionDigits: 1
            });
            return kmLocaleString + " km";
        }
    }
    else {
        return "-";
    }
}

function DotString(value, dot) {
    if (dot === void 0) { dot = "--"; }
    return value || value === 0 || value === "" ? value : dot;
}

var HMString = function (timeMinutes, scale) {
    if (scale === void 0) { scale = 1; }
    if (timeMinutes) {
        var min = timeMinutes / scale;
        var minutes = min % 60;
        var hours = (min - minutes) / 60;
        var minuteCeiling = Math.ceil(minutes);
        var duration = minuteCeiling + " min";
        if (min >= 60 && hours <= 24) {
            duration = Math.floor(minutes) + " min";
            duration = hours + " hr " + duration;
        }
        else if (hours > 24) {
            var day = Math.floor(hours / 24);
            var hour = Math.floor(hours % 24);
            duration = day + " d";
            if (hour > 0 && day < 3) {
                duration = duration + " " + hour + " hr";
            }
        }
        return duration;
    }
    else if (timeMinutes == 0) {
        return "1 min";
    }
    else {
        return "";
    }
};

function HtShow(toShow, className) {
    if (className === void 0) { className = "flex"; }
    return "display: " + (toShow ? className : "none") + ";";
}

var NameCase = function (name, split) {
    if (split === void 0) { split = " "; }
    if (name && typeof name == "string") {
        var words = name.split(split);
        words = words.map(function (word) {
            var uppercase = word.toUpperCase();
            var lowercase = word.toLowerCase();
            if (word == uppercase || word == lowercase) {
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }
            else {
                return word;
            }
        });
        var newName = words.reduce(function (string, word) {
            return string + " " + word;
        }, "");
        return newName;
    }
    else {
        return name;
    }
};

var getNearestMinute = function (date) {
    // if (moment(date).seconds() > 30) {
    //   let roundedDate = moment(date).add(1, "minute");
    //   return moment(roundedDate).startOf('minute');
    // }
    return startOfMinute(date);
};
function TimeString(item, args) {
    if (typeof item == "string" && item.length > 4) {
        return format(getNearestMinute(item), "h:mm a");
        // return getNearestMinute(item).format("h:mm a");
    }
    else {
        return item;
    }
}

// export function DayAgoISO() {
//   return subDays(new Date(), 1).toISOString();
// }
function OffsetIsoTime(time, offset) {
    if (offset === void 0) { offset = 10; }
    return addMilliseconds(time, offset).toISOString();
}
function GetMinute(time) {
    var timeStamp = new Date(time).getTime();
    return Math.round(timeStamp - timeStamp % 60000);
}
function HasSameMinute(time1, time2) {
    return isSameMinute(time1, time2);
}
function humanizeDuration(second, scale) {
    if (second) {
        var min = second / (scale * 60);
        var minutes = min % 60;
        var hours = (min - minutes) / 60;
        var minuteCeiling = Math.ceil(minutes);
        var duration = minuteCeiling + " min";
        if (min >= 60 && hours <= 24) {
            duration = Math.floor(minutes) + " min";
            duration = hours + " hr " + duration;
        }
        else if (hours > 24) {
            var day = Math.floor(hours / 24);
            var hour = Math.floor(hours % 24);
            duration = day + " d";
            if (hour > 0 && day < 3) {
                duration = duration + " " + hour + " hr";
            }
        }
        return duration;
    }
    else if (second == 0) {
        return "1 min";
    }
    else {
        return "";
    }
}

var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var DateMapService = (function () {
    var instance;
    return {
        getInstance: function () {
            if (!instance) {
                instance = {
                    today_end: endOfToday().toISOString(),
                    today_start: startOfToday().toISOString(),
                    yesterday_start: startOfYesterday().toISOString(),
                    yesterday_end: endOfYesterday().toISOString(),
                    day_7_start: startOfDay(addDays(new Date(), -6)).toISOString(),
                    month_start: startOfMonth(new Date()).toISOString(),
                    day_30_start: startOfDay(addDays(new Date(), -29)).toISOString(),
                };
            }
            return instance;
        }
    };
})();
var DateRangeMap = {
    "today": {
        start: DateMapService.getInstance().today_start,
        end: DateMapService.getInstance().today_end
    },
    "yesterday": {
        start: DateMapService.getInstance().yesterday_start,
        end: DateMapService.getInstance().yesterday_end,
    },
    "last_7_days": {
        start: DateMapService.getInstance().day_7_start,
        end: DateMapService.getInstance().today_end
    },
    "this_month": {
        start: DateMapService.getInstance().month_start,
        end: DateMapService.getInstance().today_end
    },
    "last_30_days": {
        start: DateMapService.getInstance().day_30_start,
        end: DateMapService.getInstance().today_end
    }
};
var DateRangeLabelMap = [
    {
        label: "Today",
        range: DateRangeMap.today,
        isSingleDay: true,
        hasToday: true
    },
    {
        label: "Yesterday",
        range: DateRangeMap.yesterday,
        isSingleDay: true,
        hasToday: false
    },
    {
        label: "Last 7 days",
        range: DateRangeMap.last_7_days,
        isSingleDay: false,
        hasToday: true
    },
    {
        label: "This month",
        range: DateRangeMap.this_month,
        isSingleDay: false,
        hasToday: true
    },
    {
        label: "Last 30 days",
        range: DateRangeMap.last_30_days,
        isSingleDay: false,
        hasToday: true
    }
];
function isSameRange(range1, range2) {
    var start1 = range1.start;
    var start2 = range2.start;
    return isSameDay(start1, start2) && isSameDay(range1.end, range2.end);
}
function IsRangeToday(range) {
    if (range.start && range.end) {
        return range.start == startOfToday().toISOString() && range.end == endOfToday().toISOString();
    }
    else if (!range.start && !range.end) {
        return true;
    }
    else {
        return false;
    }
}
function GetDateRangeQuery(query, param) {
    if (param === void 0) { param = "created_at"; }
    var start = query["start"];
    var end = query["end"];
    return __assign$1({}, query, (_a = {}, _a["min_" + param] = start, _a["max_" + param] = end, _a.start = null, _a.end = null, _a));
    var _a;
}
function IsRangeADay(range) {
    if (range.start && range.end) {
        return isSameDay(range.end, range.start);
        // return moment(range.end).diff(moment(range.start), "days") == 0;
    }
    else if (!range.start && !range.end) {
        return true;
    }
    else {
        return false;
    }
}
function RangeHasToday(query) {
    if (query.end) {
        return query.end == endOfToday().toISOString();
    }
    else {
        return true;
    }
}
var dateRangeDisplay = function (range) {
    var rangeItem = DateRangeLabelMap.find(function (item) {
        return isSameDateRange(item.range, range);
    });
    if (rangeItem)
        return rangeItem.label;
    // const matchKey = Object.keys(DateRangeMap).find((key) => {
    //   return isSameDateRange(DateRangeMap[key], range)
    // });
    // return "";
    var customDate = DateRangeLabelMap.find(function (data) {
        var customRange = data.range;
        return isSameRange(range, customRange);
    });
    if (customDate)
        return customDate.label;
    var isSingleDay = IsRangeADay(range);
    if (isSingleDay) {
        var isToday$$1 = IsRangeToday(range);
        var suffix = isToday$$1 ? "Today " : "";
        var string = suffix + DateString(range.start);
        return string;
    }
    else {
        // console.log(DateString(range.start), range.start);
        return DateString(range.start) + " - " + DateString(range.end);
    }
};
var isSameDateRange = function (range1, range2) {
    function nearTime(t1, t2) {
        return isSameDay(t1, t2);
    }
    return (nearTime(range1.start, range2.start) && nearTime(range1.end, range2.end));
};

var IsValidUrl = function (url) {
    if (!url)
        return false;
    var urlRegex = /^https?\:\/\/[^\/\s]+(\/.*)?$/;
    var urlExpression = new RegExp(urlRegex);
    return urlExpression.test(url) || url == "";
};

var HtQuerySerialize = function (obj) {
    var str = [];
    for (var p in obj)
        if (obj.hasOwnProperty(p)) {
            if (obj[p] || obj[p] == 0 || obj[p] == false)
                str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
    return str.join("&");
};
var GetUrlParam = function (name, url) {
    url = url || window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
    if (!results)
        return null;
    if (!results[2])
        return "";
    return decodeURIComponent(results[2].replace(/\+/g, " "));
};

var HtCustomEvent = (function () {
    function HtCustomEvent() {
        this.topics = {};
        this.hOP = this.topics.hasOwnProperty;
    }
    HtCustomEvent.prototype.next = function (topic, info) {
        // If the topic doesn't exist, or there's no listeners in queue, just leave
        if (!this.hOP.call(this.topics, topic))
            return;
        // Cycle through topics queue, fire!
        this.topics[topic].forEach(function (item) {
            item(info != undefined ? info : {});
        });
    };
    HtCustomEvent.prototype.subscribe = function (topic, listener) {
        // Create the topic's object if not yet created
        if (!this.hOP.call(this.topics, topic))
            this.topics[topic] = [];
        // Add the listener to queue
        var index = this.topics[topic].push(listener) - 1;
        // Provide handle back for removal of topic
        return {
            unsubscribe: function () {
                delete this.topics[topic][index];
            }
        };
    };
    return HtCustomEvent;
}());

export { DateString, AuthLessReqOptions, ArrayHumanize, indexBy, Color, COUNTRIES, DateHumanize, DistanceLocale, DotString, HMString, HtShow, NameCase, TimeString, OffsetIsoTime, GetMinute, HasSameMinute, humanizeDuration, DateMapService, DateRangeMap, DateRangeLabelMap, isSameRange, IsRangeToday, GetDateRangeQuery, IsRangeADay, RangeHasToday, dateRangeDisplay, isSameDateRange, IsValidUrl, HtQuerySerialize, GetUrlParam, HtCustomEvent, getTimezone };
//# sourceMappingURL=ht-utility.es5.js.map
